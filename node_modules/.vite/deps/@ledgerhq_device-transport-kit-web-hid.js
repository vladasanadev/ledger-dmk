import {
  BehaviorSubject,
  EitherAsync,
  Maybe,
  W2 as W,
  __publicField,
  a6 as a,
  c3 as c,
  d2 as d,
  d3 as d2,
  from,
  l2 as l,
  left,
  map,
  n,
  nothing,
  right,
  s9 as s,
  switchMap,
  u,
  u2,
  v4_default
} from "./chunk-GDHLO7W6.js";

// node_modules/@ledgerhq/device-transport-kit-web-hid/lib/esm/api/model/Errors.js
var d3 = class extends n {
  constructor(r) {
    super(r);
    __publicField(this, "_tag", "WebHidTransportNotSupportedError");
    this.err = r;
  }
};
var p = class extends n {
  constructor(r) {
    super(r);
    __publicField(this, "_tag", "WebHidSendReportError");
    this.err = r;
  }
};

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d4, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
    d5.__proto__ = b3;
  } || function(d5, b3) {
    for (var p2 in b3) if (b3.hasOwnProperty(p2)) d5[p2] = b3[p2];
  };
  return extendStatics(d4, b2);
};
function __extends(d4, b2) {
  extendStatics(d4, b2);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o2[s2], i = 0;
  if (m) return m.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i >= o2.length) o2 = void 0;
      return { value: o2 && o2[i++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m) return o2;
  var i = m.call(o2), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}

// node_modules/@sentry/utils/esm/env.js
function isBrowserBundle() {
  return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
}

// node_modules/@sentry/utils/esm/node.js
function isNodeEnv() {
  return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
}
function dynamicRequire(mod, request) {
  return mod.require(request);
}

// node_modules/@sentry/utils/esm/global.js
var fallbackGlobalObject = {};
function getGlobalObject() {
  return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
}
function getGlobalSingleton(name, creator, obj) {
  var global4 = obj || getGlobalObject();
  var __SENTRY__ = global4.__SENTRY__ = global4.__SENTRY__ || {};
  var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}

// node_modules/@sentry/utils/esm/is.js
var objectToString = Object.prototype.toString;
function isBuiltin(wat, ty) {
  return objectToString.call(wat) === "[object " + ty + "]";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}

// node_modules/@sentry/utils/esm/polyfill.js
var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
function mixinProperties(obj, proto) {
  for (var prop in proto) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto[prop];
    }
  }
  return obj;
}

// node_modules/@sentry/utils/esm/error.js
var SentryError = (
  /** @class */
  function(_super) {
    __extends(SentryError2, _super);
    function SentryError2(message) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.name = _newTarget.prototype.constructor.name;
      setPrototypeOf(_this, _newTarget.prototype);
      return _this;
    }
    return SentryError2;
  }(Error)
);

// node_modules/@sentry/utils/esm/flags.js
var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/utils/esm/logger.js
var global2 = getGlobalObject();
var PREFIX = "Sentry Logger ";
var CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert"];
function consoleSandbox(callback) {
  var global4 = getGlobalObject();
  if (!("console" in global4)) {
    return callback();
  }
  var originalConsole = global4.console;
  var wrappedLevels = {};
  CONSOLE_LEVELS.forEach(function(level) {
    var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
    if (level in global4.console && originalWrappedFunc) {
      wrappedLevels[level] = originalConsole[level];
      originalConsole[level] = originalWrappedFunc;
    }
  });
  try {
    return callback();
  } finally {
    Object.keys(wrappedLevels).forEach(function(level) {
      originalConsole[level] = wrappedLevels[level];
    });
  }
}
function makeLogger() {
  var enabled = false;
  var logger2 = {
    enable: function() {
      enabled = true;
    },
    disable: function() {
      enabled = false;
    }
  };
  if (IS_DEBUG_BUILD) {
    CONSOLE_LEVELS.forEach(function(name) {
      logger2[name] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (enabled) {
          consoleSandbox(function() {
            var _a;
            (_a = global2.console)[name].apply(_a, __spread([PREFIX + "[" + name + "]:"], args));
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach(function(name) {
      logger2[name] = function() {
        return void 0;
      };
    });
  }
  return logger2;
}
var logger;
if (IS_DEBUG_BUILD) {
  logger = getGlobalSingleton("logger", makeLogger);
} else {
  logger = makeLogger();
}

// node_modules/@sentry/utils/esm/object.js
function dropUndefinedKeys(val) {
  var e_1, _a;
  if (isPlainObject(val)) {
    var rv = {};
    try {
      for (var _b = __values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (typeof val[key] !== "undefined") {
          rv[key] = dropUndefinedKeys(val[key]);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return rv;
  }
  if (Array.isArray(val)) {
    return val.map(dropUndefinedKeys);
  }
  return val;
}

// node_modules/@sentry/utils/esm/instrument.js
var global3 = getGlobalObject();

// node_modules/@sentry/utils/esm/misc.js
function uuid4() {
  var global4 = getGlobalObject();
  var crypto = global4.crypto || global4.msCrypto;
  if (!(crypto === void 0) && crypto.getRandomValues) {
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);
    arr[3] = arr[3] & 4095 | 16384;
    arr[4] = arr[4] & 16383 | 32768;
    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = "0" + v;
      }
      return v;
    };
    return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
  }
  return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
    var r = Math.random() * 16 | 0;
    var v = c2 === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

// node_modules/@sentry/utils/esm/syncpromise.js
var SyncPromise = (
  /** @class */
  function() {
    function SyncPromise2(executor) {
      var _this = this;
      this._state = 0;
      this._handlers = [];
      this._resolve = function(value) {
        _this._setResult(1, value);
      };
      this._reject = function(reason) {
        _this._setResult(2, reason);
      };
      this._setResult = function(state, value) {
        if (_this._state !== 0) {
          return;
        }
        if (isThenable(value)) {
          void value.then(_this._resolve, _this._reject);
          return;
        }
        _this._state = state;
        _this._value = value;
        _this._executeHandlers();
      };
      this._executeHandlers = function() {
        if (_this._state === 0) {
          return;
        }
        var cachedHandlers = _this._handlers.slice();
        _this._handlers = [];
        cachedHandlers.forEach(function(handler) {
          if (handler[0]) {
            return;
          }
          if (_this._state === 1) {
            handler[1](_this._value);
          }
          if (_this._state === 2) {
            handler[2](_this._value);
          }
          handler[0] = true;
        });
      };
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        _this._handlers.push([
          false,
          function(result) {
            if (!onfulfilled) {
              resolve(result);
            } else {
              try {
                resolve(onfulfilled(result));
              } catch (e) {
                reject(e);
              }
            }
          },
          function(reason) {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e) {
                reject(e);
              }
            }
          }
        ]);
        _this._executeHandlers();
      });
    };
    SyncPromise2.prototype.catch = function(onrejected) {
      return this.then(function(val) {
        return val;
      }, onrejected);
    };
    SyncPromise2.prototype.finally = function(onfinally) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        var val;
        var isRejected;
        return _this.then(function(value) {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, function(reason) {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(function() {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    };
    return SyncPromise2;
  }()
);

// node_modules/@sentry/types/esm/severity.js
var Severity;
(function(Severity2) {
  Severity2["Fatal"] = "fatal";
  Severity2["Error"] = "error";
  Severity2["Warning"] = "warning";
  Severity2["Log"] = "log";
  Severity2["Info"] = "info";
  Severity2["Debug"] = "debug";
  Severity2["Critical"] = "critical";
})(Severity || (Severity = {}));

// node_modules/@sentry/utils/esm/time.js
var dateTimestampSource = {
  nowSeconds: function() {
    return Date.now() / 1e3;
  }
};
function getBrowserPerformance() {
  var performance = getGlobalObject().performance;
  if (!performance || !performance.now) {
    return void 0;
  }
  var timeOrigin = Date.now() - performance.now();
  return {
    now: function() {
      return performance.now();
    },
    timeOrigin
  };
}
function getNodePerformance() {
  try {
    var perfHooks = dynamicRequire(module, "perf_hooks");
    return perfHooks.performance;
  } catch (_) {
    return void 0;
  }
}
var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
  nowSeconds: function() {
    return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
  }
};
var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
var _browserPerformanceTimeOriginMode;
var browserPerformanceTimeOrigin = function() {
  var performance = getGlobalObject().performance;
  if (!performance || !performance.now) {
    _browserPerformanceTimeOriginMode = "none";
    return void 0;
  }
  var threshold = 3600 * 1e3;
  var performanceNow = performance.now();
  var dateNow = Date.now();
  var timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;
  var timeOriginIsReliable = timeOriginDelta < threshold;
  var navigationStart = performance.timing && performance.timing.navigationStart;
  var hasNavigationStart = typeof navigationStart === "number";
  var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  var navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      _browserPerformanceTimeOriginMode = "timeOrigin";
      return performance.timeOrigin;
    } else {
      _browserPerformanceTimeOriginMode = "navigationStart";
      return navigationStart;
    }
  }
  _browserPerformanceTimeOriginMode = "dateNow";
  return dateNow;
}();

// node_modules/@sentry/utils/esm/tracing.js
var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");

// node_modules/@sentry/utils/esm/ratelimit.js
var DEFAULT_RETRY_AFTER = 60 * 1e3;

// node_modules/@sentry/hub/esm/scope.js
var MAX_BREADCRUMBS = 100;
var Scope = (
  /** @class */
  function() {
    function Scope2() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
    }
    Scope2.clone = function(scope) {
      var newScope = new Scope2();
      if (scope) {
        newScope._breadcrumbs = __spread(scope._breadcrumbs);
        newScope._tags = __assign({}, scope._tags);
        newScope._extra = __assign({}, scope._extra);
        newScope._contexts = __assign({}, scope._contexts);
        newScope._user = scope._user;
        newScope._level = scope._level;
        newScope._span = scope._span;
        newScope._session = scope._session;
        newScope._transactionName = scope._transactionName;
        newScope._fingerprint = scope._fingerprint;
        newScope._eventProcessors = __spread(scope._eventProcessors);
        newScope._requestSession = scope._requestSession;
      }
      return newScope;
    };
    Scope2.prototype.addScopeListener = function(callback) {
      this._scopeListeners.push(callback);
    };
    Scope2.prototype.addEventProcessor = function(callback) {
      this._eventProcessors.push(callback);
      return this;
    };
    Scope2.prototype.setUser = function(user) {
      this._user = user || {};
      if (this._session) {
        this._session.update({ user });
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getUser = function() {
      return this._user;
    };
    Scope2.prototype.getRequestSession = function() {
      return this._requestSession;
    };
    Scope2.prototype.setRequestSession = function(requestSession) {
      this._requestSession = requestSession;
      return this;
    };
    Scope2.prototype.setTags = function(tags) {
      this._tags = __assign(__assign({}, this._tags), tags);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTag = function(key, value) {
      var _a;
      this._tags = __assign(__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtras = function(extras) {
      this._extra = __assign(__assign({}, this._extra), extras);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtra = function(key, extra) {
      var _a;
      this._extra = __assign(__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setFingerprint = function(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setLevel = function(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransactionName = function(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransaction = function(name) {
      return this.setTransactionName(name);
    };
    Scope2.prototype.setContext = function(key, context) {
      var _a;
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts = __assign(__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setSpan = function(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSpan = function() {
      return this._span;
    };
    Scope2.prototype.getTransaction = function() {
      var span = this.getSpan();
      return span && span.transaction;
    };
    Scope2.prototype.setSession = function(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSession = function() {
      return this._session;
    };
    Scope2.prototype.update = function(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        var updatedScope = captureContext(this);
        return updatedScope instanceof Scope2 ? updatedScope : this;
      }
      if (captureContext instanceof Scope2) {
        this._tags = __assign(__assign({}, this._tags), captureContext._tags);
        this._extra = __assign(__assign({}, this._extra), captureContext._extra);
        this._contexts = __assign(__assign({}, this._contexts), captureContext._contexts);
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
        if (captureContext._requestSession) {
          this._requestSession = captureContext._requestSession;
        }
      } else if (isPlainObject(captureContext)) {
        captureContext = captureContext;
        this._tags = __assign(__assign({}, this._tags), captureContext.tags);
        this._extra = __assign(__assign({}, this._extra), captureContext.extra);
        this._contexts = __assign(__assign({}, this._contexts), captureContext.contexts);
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
        if (captureContext.requestSession) {
          this._requestSession = captureContext.requestSession;
        }
      }
      return this;
    };
    Scope2.prototype.clear = function() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
      var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      var mergedBreadcrumb = __assign({ timestamp: dateTimestampInSeconds() }, breadcrumb);
      this._breadcrumbs = __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.clearBreadcrumbs = function() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.applyToEvent = function(event2, hint) {
      if (this._extra && Object.keys(this._extra).length) {
        event2.extra = __assign(__assign({}, this._extra), event2.extra);
      }
      if (this._tags && Object.keys(this._tags).length) {
        event2.tags = __assign(__assign({}, this._tags), event2.tags);
      }
      if (this._user && Object.keys(this._user).length) {
        event2.user = __assign(__assign({}, this._user), event2.user);
      }
      if (this._contexts && Object.keys(this._contexts).length) {
        event2.contexts = __assign(__assign({}, this._contexts), event2.contexts);
      }
      if (this._level) {
        event2.level = this._level;
      }
      if (this._transactionName) {
        event2.transaction = this._transactionName;
      }
      if (this._span) {
        event2.contexts = __assign({ trace: this._span.getTraceContext() }, event2.contexts);
        var transactionName = this._span.transaction && this._span.transaction.name;
        if (transactionName) {
          event2.tags = __assign({ transaction: transactionName }, event2.tags);
        }
      }
      this._applyFingerprint(event2);
      event2.breadcrumbs = __spread(event2.breadcrumbs || [], this._breadcrumbs);
      event2.breadcrumbs = event2.breadcrumbs.length > 0 ? event2.breadcrumbs : void 0;
      event2.sdkProcessingMetadata = this._sdkProcessingMetadata;
      return this._notifyEventProcessors(__spread(getGlobalEventProcessors(), this._eventProcessors), event2, hint);
    };
    Scope2.prototype.setSDKProcessingMetadata = function(newData) {
      this._sdkProcessingMetadata = __assign(__assign({}, this._sdkProcessingMetadata), newData);
      return this;
    };
    Scope2.prototype._notifyEventProcessors = function(processors, event2, hint, index) {
      var _this = this;
      if (index === void 0) {
        index = 0;
      }
      return new SyncPromise(function(resolve, reject) {
        var processor = processors[index];
        if (event2 === null || typeof processor !== "function") {
          resolve(event2);
        } else {
          var result = processor(__assign({}, event2), hint);
          if (isThenable(result)) {
            void result.then(function(final) {
              return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
            }).then(null, reject);
          } else {
            void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
          }
        }
      });
    };
    Scope2.prototype._notifyScopeListeners = function() {
      var _this = this;
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach(function(callback) {
          callback(_this);
        });
        this._notifyingListeners = false;
      }
    };
    Scope2.prototype._applyFingerprint = function(event2) {
      event2.fingerprint = event2.fingerprint ? Array.isArray(event2.fingerprint) ? event2.fingerprint : [event2.fingerprint] : [];
      if (this._fingerprint) {
        event2.fingerprint = event2.fingerprint.concat(this._fingerprint);
      }
      if (event2.fingerprint && !event2.fingerprint.length) {
        delete event2.fingerprint;
      }
    };
    return Scope2;
  }()
);
function getGlobalEventProcessors() {
  return getGlobalSingleton("globalEventProcessors", function() {
    return [];
  });
}

// node_modules/@sentry/hub/esm/session.js
var Session = (
  /** @class */
  function() {
    function Session2(context) {
      this.errors = 0;
      this.sid = uuid4();
      this.duration = 0;
      this.status = "ok";
      this.init = true;
      this.ignoreDuration = false;
      var startingTime = timestampInSeconds();
      this.timestamp = startingTime;
      this.started = startingTime;
      if (context) {
        this.update(context);
      }
    }
    Session2.prototype.update = function(context) {
      if (context === void 0) {
        context = {};
      }
      if (context.user) {
        if (!this.ipAddress && context.user.ip_address) {
          this.ipAddress = context.user.ip_address;
        }
        if (!this.did && !context.did) {
          this.did = context.user.id || context.user.email || context.user.username;
        }
      }
      this.timestamp = context.timestamp || timestampInSeconds();
      if (context.ignoreDuration) {
        this.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        this.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== void 0) {
        this.init = context.init;
      }
      if (!this.did && context.did) {
        this.did = "" + context.did;
      }
      if (typeof context.started === "number") {
        this.started = context.started;
      }
      if (this.ignoreDuration) {
        this.duration = void 0;
      } else if (typeof context.duration === "number") {
        this.duration = context.duration;
      } else {
        var duration = this.timestamp - this.started;
        this.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        this.release = context.release;
      }
      if (context.environment) {
        this.environment = context.environment;
      }
      if (!this.ipAddress && context.ipAddress) {
        this.ipAddress = context.ipAddress;
      }
      if (!this.userAgent && context.userAgent) {
        this.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        this.errors = context.errors;
      }
      if (context.status) {
        this.status = context.status;
      }
    };
    Session2.prototype.close = function(status) {
      if (status) {
        this.update({ status });
      } else if (this.status === "ok") {
        this.update({ status: "exited" });
      } else {
        this.update();
      }
    };
    Session2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        sid: "" + this.sid,
        init: this.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(this.started * 1e3).toISOString(),
        timestamp: new Date(this.timestamp * 1e3).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: {
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        }
      });
    };
    return Session2;
  }()
);

// node_modules/@sentry/hub/esm/flags.js
var IS_DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

// node_modules/@sentry/hub/esm/hub.js
var API_VERSION = 4;
var DEFAULT_BREADCRUMBS = 100;
var Hub = (
  /** @class */
  function() {
    function Hub2(client, scope, _version) {
      if (scope === void 0) {
        scope = new Scope();
      }
      if (_version === void 0) {
        _version = API_VERSION;
      }
      this._version = _version;
      this._stack = [{}];
      this.getStackTop().scope = scope;
      if (client) {
        this.bindClient(client);
      }
    }
    Hub2.prototype.isOlderThan = function(version) {
      return this._version < version;
    };
    Hub2.prototype.bindClient = function(client) {
      var top = this.getStackTop();
      top.client = client;
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    };
    Hub2.prototype.pushScope = function() {
      var scope = Scope.clone(this.getScope());
      this.getStack().push({
        client: this.getClient(),
        scope
      });
      return scope;
    };
    Hub2.prototype.popScope = function() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    };
    Hub2.prototype.withScope = function(callback) {
      var scope = this.pushScope();
      try {
        callback(scope);
      } finally {
        this.popScope();
      }
    };
    Hub2.prototype.getClient = function() {
      return this.getStackTop().client;
    };
    Hub2.prototype.getScope = function() {
      return this.getStackTop().scope;
    };
    Hub2.prototype.getStack = function() {
      return this._stack;
    };
    Hub2.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    };
    Hub2.prototype.captureException = function(exception, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (exception2) {
          syntheticException = exception2;
        }
        finalHint = {
          originalException: exception,
          syntheticException
        };
      }
      this._invokeClient("captureException", exception, __assign(__assign({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureMessage = function(message, level, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error(message);
        } catch (exception) {
          syntheticException = exception;
        }
        finalHint = {
          originalException: message,
          syntheticException
        };
      }
      this._invokeClient("captureMessage", message, level, __assign(__assign({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureEvent = function(event2, hint) {
      var eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (event2.type !== "transaction") {
        this._lastEventId = eventId;
      }
      this._invokeClient("captureEvent", event2, __assign(__assign({}, hint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.lastEventId = function() {
      return this._lastEventId;
    };
    Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope || !client)
        return;
      var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
      if (maxBreadcrumbs <= 0)
        return;
      var timestamp = dateTimestampInSeconds();
      var mergedBreadcrumb = __assign({ timestamp }, breadcrumb);
      var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function() {
        return beforeBreadcrumb(mergedBreadcrumb, hint);
      }) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    Hub2.prototype.setUser = function(user) {
      var scope = this.getScope();
      if (scope)
        scope.setUser(user);
    };
    Hub2.prototype.setTags = function(tags) {
      var scope = this.getScope();
      if (scope)
        scope.setTags(tags);
    };
    Hub2.prototype.setExtras = function(extras) {
      var scope = this.getScope();
      if (scope)
        scope.setExtras(extras);
    };
    Hub2.prototype.setTag = function(key, value) {
      var scope = this.getScope();
      if (scope)
        scope.setTag(key, value);
    };
    Hub2.prototype.setExtra = function(key, extra) {
      var scope = this.getScope();
      if (scope)
        scope.setExtra(key, extra);
    };
    Hub2.prototype.setContext = function(name, context) {
      var scope = this.getScope();
      if (scope)
        scope.setContext(name, context);
    };
    Hub2.prototype.configureScope = function(callback) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (scope && client) {
        callback(scope);
      }
    };
    Hub2.prototype.run = function(callback) {
      var oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    };
    Hub2.prototype.getIntegration = function(integration) {
      var client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        IS_DEBUG_BUILD2 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
        return null;
      }
    };
    Hub2.prototype.startSpan = function(context) {
      return this._callExtensionMethod("startSpan", context);
    };
    Hub2.prototype.startTransaction = function(context, customSamplingContext) {
      return this._callExtensionMethod("startTransaction", context, customSamplingContext);
    };
    Hub2.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    };
    Hub2.prototype.captureSession = function(endSession) {
      if (endSession === void 0) {
        endSession = false;
      }
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    };
    Hub2.prototype.endSession = function() {
      var layer = this.getStackTop();
      var scope = layer && layer.scope;
      var session = scope && scope.getSession();
      if (session) {
        session.close();
      }
      this._sendSessionUpdate();
      if (scope) {
        scope.setSession();
      }
    };
    Hub2.prototype.startSession = function(context) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
      var global4 = getGlobalObject();
      var userAgent = (global4.navigator || {}).userAgent;
      var session = new Session(__assign(__assign(__assign({
        release,
        environment
      }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
      if (scope) {
        var currentSession = scope.getSession && scope.getSession();
        if (currentSession && currentSession.status === "ok") {
          currentSession.update({ status: "exited" });
        }
        this.endSession();
        scope.setSession(session);
      }
      return session;
    };
    Hub2.prototype._sendSessionUpdate = function() {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope)
        return;
      var session = scope.getSession && scope.getSession();
      if (session) {
        if (client && client.captureSession) {
          client.captureSession(session);
        }
      }
    };
    Hub2.prototype._invokeClient = function(method) {
      var _a;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
      if (client && client[method]) {
        (_a = client)[method].apply(_a, __spread(args, [scope]));
      }
    };
    Hub2.prototype._callExtensionMethod = function(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var carrier = getMainCarrier();
      var sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      IS_DEBUG_BUILD2 && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub2;
  }()
);
function getMainCarrier() {
  var carrier = getGlobalObject();
  carrier.__SENTRY__ = carrier.__SENTRY__ || {
    extensions: {},
    hub: void 0
  };
  return carrier;
}
function makeMain(hub) {
  var registry = getMainCarrier();
  var oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}
function getCurrentHub() {
  var registry = getMainCarrier();
  if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }
  if (isNodeEnv()) {
    return getHubFromActiveDomain(registry);
  }
  return getHubFromCarrier(registry);
}
function getHubFromActiveDomain(registry) {
  try {
    var sentry = getMainCarrier().__SENTRY__;
    var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
    if (!activeDomain) {
      return getHubFromCarrier(registry);
    }
    if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
      var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
      setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
    }
    return getHubFromCarrier(activeDomain);
  } catch (_Oo) {
    return getHubFromCarrier(registry);
  }
}
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
function getHubFromCarrier(carrier) {
  return getGlobalSingleton("hub", function() {
    return new Hub();
  }, carrier);
}
function setHubOnCarrier(carrier, hub) {
  if (!carrier)
    return false;
  var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.hub = hub;
  return true;
}

// node_modules/@sentry/hub/esm/sessionflusher.js
var SessionFlusher = (
  /** @class */
  function() {
    function SessionFlusher2(transport, attrs) {
      var _this = this;
      this.flushTimeout = 60;
      this._pendingAggregates = {};
      this._isEnabled = true;
      this._transport = transport;
      this._intervalId = setInterval(function() {
        return _this.flush();
      }, this.flushTimeout * 1e3);
      this._sessionAttrs = attrs;
    }
    SessionFlusher2.prototype.sendSessionAggregates = function(sessionAggregates) {
      if (!this._transport.sendSession) {
        IS_DEBUG_BUILD2 && logger.warn("Dropping session because custom transport doesn't implement sendSession");
        return;
      }
      void this._transport.sendSession(sessionAggregates).then(null, function(reason) {
        IS_DEBUG_BUILD2 && logger.error("Error while sending session:", reason);
      });
    };
    SessionFlusher2.prototype.flush = function() {
      var sessionAggregates = this.getSessionAggregates();
      if (sessionAggregates.aggregates.length === 0) {
        return;
      }
      this._pendingAggregates = {};
      this.sendSessionAggregates(sessionAggregates);
    };
    SessionFlusher2.prototype.getSessionAggregates = function() {
      var _this = this;
      var aggregates = Object.keys(this._pendingAggregates).map(function(key) {
        return _this._pendingAggregates[parseInt(key)];
      });
      var sessionAggregates = {
        attrs: this._sessionAttrs,
        aggregates
      };
      return dropUndefinedKeys(sessionAggregates);
    };
    SessionFlusher2.prototype.close = function() {
      clearInterval(this._intervalId);
      this._isEnabled = false;
      this.flush();
    };
    SessionFlusher2.prototype.incrementSessionStatusCount = function() {
      if (!this._isEnabled) {
        return;
      }
      var scope = getCurrentHub().getScope();
      var requestSession = scope && scope.getRequestSession();
      if (requestSession && requestSession.status) {
        this._incrementSessionStatusCount(requestSession.status, /* @__PURE__ */ new Date());
        if (scope) {
          scope.setRequestSession(void 0);
        }
      }
    };
    SessionFlusher2.prototype._incrementSessionStatusCount = function(status, date) {
      var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
      this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
      var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
      if (!aggregationCounts.started) {
        aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
      }
      switch (status) {
        case "errored":
          aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
          return aggregationCounts.errored;
        case "ok":
          aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
          return aggregationCounts.exited;
        default:
          aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
          return aggregationCounts.crashed;
      }
    };
    return SessionFlusher2;
  }()
);

// node_modules/@sentry/minimal/esm/index.js
function callOnHub(method) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var hub = getCurrentHub();
  if (hub && hub[method]) {
    return hub[method].apply(hub, __spread(args));
  }
  throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
}
function captureException(exception, captureContext) {
  var syntheticException = new Error("Sentry syntheticException");
  return callOnHub("captureException", exception, {
    captureContext,
    originalException: exception,
    syntheticException
  });
}

// node_modules/@ledgerhq/device-transport-kit-web-hid/lib/esm/api/data/WebHidConfig.js
var E = 64;
var o = 6e3;

// node_modules/@ledgerhq/device-transport-kit-web-hid/lib/esm/api/transport/WebHidApduSender.js
var b = class {
  constructor({ dependencies: e, apduSenderFactory: t, apduReceiverFactory: d4 }, r) {
    __publicField(this, "dependencies");
    __publicField(this, "apduSender");
    __publicField(this, "apduReceiver");
    __publicField(this, "sendApduPromiseResolver");
    __publicField(this, "logger");
    const i = Maybe.of(u2.numberToByteArray(Math.floor(Math.random() * 65535), 2));
    this.logger = r("WebHidApduSender"), this.apduSender = t({ frameSize: E, channel: i, padding: true }), this.apduReceiver = d4({ channel: i }), this.sendApduPromiseResolver = nothing, this.dependencies = e, this.logger.info("ðŸ”Œ Connected to device");
  }
  async sendApdu(e, t, d4) {
    let r;
    const i = new Promise((n2) => {
      this.sendApduPromiseResolver = Maybe.of((...o2) => (r && clearTimeout(r), n2(...o2)));
    });
    for (const n2 of this.apduSender.getFrames(e)) try {
      await this.dependencies.device.sendReport(0, new Uint8Array(n2.getRawData()));
    } catch (o2) {
      return this.logger.info("Error sending frame", { data: { error: o2 } }), Promise.resolve(left(new p(o2)));
    }
    return d4 && (r = setTimeout(() => {
      this.logger.debug("[sendApdu] Abort timeout", { data: { abortTimeout: d4 } }), this.sendApduPromiseResolver.map((n2) => n2(left(new u("Abort timeout"))));
    }, d4)), i;
  }
  receiveHidInputReport(e) {
    const t = new Uint8Array(e.data.buffer);
    this.apduReceiver.handleFrame(t).map((r) => {
      r.map((i) => {
        this.sendApduPromiseResolver.map((n2) => n2(right(i)));
      });
    }).mapLeft((r) => {
      this.sendApduPromiseResolver.map((i) => i(left(r)));
    });
  }
  getDependencies() {
    return this.dependencies;
  }
  setDependencies(e) {
    this.dependencies = e;
  }
  async setupConnection() {
    try {
      this.dependencies.device.oninputreport = (e) => this.receiveHidInputReport(e), await this.dependencies.device.open();
    } catch (e) {
      if (e instanceof DOMException && e.name === "InvalidStateError") this.logger.info("Device is already opened");
      else {
        const t = new c(e);
        throw this.logger.error("Error while opening device", { data: { error: e } }), captureException(t), e;
      }
    }
  }
  closeConnection() {
    this.logger.info("ðŸ”š Disconnect");
    try {
      this.dependencies.device.close();
    } catch (e) {
      this.logger.error("Error while closing device", { data: { device: this.dependencies.device, error: e } });
    }
  }
};

// node_modules/@ledgerhq/device-transport-kit-web-hid/lib/esm/api/transport/WebHidTransport.js
var P = "WEB-HID";
var R = class {
  constructor(e, i, t, n2, o2 = (c2) => new W(c2), s2 = (c2, p2) => new b(c2, p2)) {
    __publicField(this, "_transportDiscoveredDevices", new BehaviorSubject([]));
    __publicField(this, "_deviceConnectionsByHidDevice", /* @__PURE__ */ new Map());
    __publicField(this, "_deviceConnectionsPendingReconnection", /* @__PURE__ */ new Set());
    __publicField(this, "_connectionListenersAbortController", new AbortController());
    __publicField(this, "_logger");
    __publicField(this, "connectionType", "USB");
    __publicField(this, "identifier", P);
    this._deviceModelDataSource = e;
    this._loggerServiceFactory = i;
    this._apduSenderFactory = t;
    this._apduReceiverFactory = n2;
    this._deviceConnectionStateMachineFactory = o2;
    this._deviceApduSenderFactory = s2;
    this._logger = i("WebWebHidTransport"), this.startListeningToConnectionEvents();
  }
  get hidApi() {
    return this.isSupported() ? right(navigator.hid) : left(new d3("WebHID not supported"));
  }
  isSupported() {
    try {
      const e = !!(navigator == null ? void 0 : navigator.hid);
      return this._logger.debug(`isSupported: ${e}`), e;
    } catch (e) {
      return this._logger.error("isSupported: error", { data: { error: e } }), false;
    }
  }
  getIdentifier() {
    return this.identifier;
  }
  async getDevices() {
    return EitherAsync.liftEither(this.hidApi).map(async (e) => {
      try {
        return (await e.getDevices()).filter((t) => t.vendorId === l);
      } catch (i) {
        const t = new d(i);
        throw this._logger.error("getDevices: error getting devices", { data: { error: i } }), captureException(t), t;
      }
    });
  }
  mapHIDDeviceToTransportDiscoveredDevice(e) {
    const i = this._transportDiscoveredDevices.getValue().find((o2) => o2.hidDevice === e);
    if (i) return i;
    const t = this._deviceConnectionsByHidDevice.get(e);
    return this.getDeviceModel(e).caseOf({ Just: (o2) => {
      const s2 = (t == null ? void 0 : t.getDeviceId()) ?? v4_default(), c2 = { id: s2, deviceModel: o2, hidDevice: e, transport: this.identifier };
      return this._logger.debug(`Discovered device ${s2} ${c2.deviceModel.productName}`), c2;
    }, Nothing: () => {
      throw this._logger.warn(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`), new s(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`);
    } });
  }
  listenToAvailableDevices() {
    return this.updateTransportDiscoveredDevices(), this._transportDiscoveredDevices.pipe(map((e) => e.map(({ hidDevice: i, ...t }) => t)));
  }
  async updateTransportDiscoveredDevices() {
    (await this.getDevices()).caseOf({ Left: (i) => {
      this._logger.error("Error while getting accessible device", { data: { error: i } }), captureException(i);
    }, Right: (i) => {
      this._transportDiscoveredDevices.next(i.map((t) => this.mapHIDDeviceToTransportDiscoveredDevice(t)));
    } });
  }
  async promptDeviceAccess() {
    return EitherAsync.liftEither(this.hidApi).map(async (e) => {
      let i = [];
      try {
        i = await e.requestDevice({ filters: [{ vendorId: l }] }), await this.updateTransportDiscoveredDevices();
      } catch (n2) {
        const o2 = new d(n2);
        throw this._logger.error("promptDeviceAccess: error requesting device", { data: { error: n2 } }), captureException(o2), o2;
      }
      if (this._logger.debug(`promptDeviceAccess: hidDevices len ${i.length}`), i.length === 0) throw this._logger.warn("No device was selected"), new d("No selected device");
      const t = [];
      for (const n2 of i) t.push(n2), this._logger.debug("promptDeviceAccess: selected device", { data: { hidDevice: n2 } });
      return t;
    }).run();
  }
  startDiscovering() {
    return this._logger.debug("startDiscovering"), from(this.promptDeviceAccess()).pipe(switchMap((e) => e.caseOf({ Left: (i) => {
      throw this._logger.error("Error while getting accessible device", { data: { error: i } }), captureException(i), i;
    }, Right: (i) => {
      this._logger.info(`Got access to ${i.length} HID devices`);
      const t = i.map((n2) => this.mapHIDDeviceToTransportDiscoveredDevice(n2));
      return from(t);
    } })));
  }
  stopDiscovering() {
  }
  startListeningToConnectionEvents() {
    this._logger.debug("startListeningToConnectionEvents"), this.hidApi.map((e) => {
      e.addEventListener("connect", (i) => this.handleDeviceConnectionEvent(i), { signal: this._connectionListenersAbortController.signal }), e.addEventListener("disconnect", (i) => this.handleDeviceDisconnectionEvent(i), { signal: this._connectionListenersAbortController.signal });
    });
  }
  stopListeningToConnectionEvents() {
    this._logger.debug("stopListeningToConnectionEvents"), this._connectionListenersAbortController.abort();
  }
  async connect({ deviceId: e, onDisconnect: i }) {
    this._logger.debug("connect", { data: { deviceId: e } });
    const t = this._transportDiscoveredDevices.getValue().find((r) => r.id === e);
    if (!t) return this._logger.error(`Unknown device ${e}`), left(new a(`Unknown device ${e}`));
    const { deviceModel: n2 } = t, o2 = this._deviceConnectionsByHidDevice.get(t.hidDevice);
    if (o2) return right(new d2({ id: e, deviceModel: n2, type: this.connectionType, sendApdu: (...r) => o2.sendApdu(...r), transport: this.identifier }));
    const s2 = this._deviceApduSenderFactory({ apduSenderFactory: this._apduSenderFactory, apduReceiverFactory: this._apduReceiverFactory, dependencies: { device: t.hidDevice } }, this._loggerServiceFactory), c2 = this._deviceConnectionStateMachineFactory({ deviceId: e, deviceApduSender: s2, timeoutDuration: o, tryToReconnect: () => {
      this._deviceConnectionsByHidDevice.forEach((r, D) => {
        r.getDeviceId() === e && (this._deviceConnectionsPendingReconnection.add(r), this._deviceConnectionsByHidDevice.delete(D));
      });
    }, onTerminated: () => {
      this._deviceConnectionsPendingReconnection.forEach((r) => {
        r.getDeviceId() === e && (this._deviceConnectionsPendingReconnection.delete(r), i(r.getDeviceId()));
      }), this._deviceConnectionsByHidDevice.forEach((r, D) => {
        r.getDeviceId() === e && (this._deviceConnectionsByHidDevice.delete(D), i(r.getDeviceId()));
      });
    } });
    try {
      await s2.setupConnection();
    } catch (r) {
      return r instanceof c ? left(r) : left(new c(r));
    }
    this._deviceConnectionsByHidDevice.set(t.hidDevice, c2);
    const p2 = new d2({ sendApdu: (...r) => c2.sendApdu(...r), deviceModel: n2, id: e, type: this.connectionType, transport: this.identifier });
    return right(p2);
  }
  getDeviceModel(e) {
    const { productId: i } = e, t = this._deviceModelDataSource.getAllDeviceModels().find((n2) => n2.usbProductId === i >> 8 || n2.bootloaderUsbProductId === i);
    return t ? Maybe.of(t) : Maybe.zero();
  }
  getHidUsbProductId(e) {
    return this.getDeviceModel(e).caseOf({ Just: (i) => i.usbProductId, Nothing: () => e.productId >> 8 });
  }
  async disconnect(e) {
    this._logger.debug("disconnect", { data: { connectedDevice: e } });
    const i = Array.from(this._deviceConnectionsByHidDevice.values()).find((t) => t.getDeviceId() === e.connectedDevice.id);
    return i ? (i.closeConnection(), Promise.resolve(right(void 0))) : (this._logger.error("No matching device connection found", { data: { connectedDevice: e } }), Promise.resolve(left(new a(`Unknown device ${e.connectedDevice.id}`))));
  }
  isHIDConnectionEvent(e) {
    return "device" in e && typeof e.device == "object" && e.device !== null && "productId" in e.device && typeof e.device.productId == "number";
  }
  async handleDeviceDisconnectionEvent(e) {
    if (!this.isHIDConnectionEvent(e)) {
      this._logger.error("Invalid event", { data: { event: e } });
      return;
    }
    this._logger.info("[handleDeviceDisconnectionEvent] Device disconnected", { data: { event: e } }), this.updateTransportDiscoveredDevices();
    try {
      await e.device.close();
    } catch (t) {
      this._logger.error("Error while closing device ", { data: { event: e, error: t } });
    }
    const i = this._deviceConnectionsByHidDevice.get(e.device);
    i && i.eventDeviceDisconnected();
  }
  async handleDeviceReconnection(e, i) {
    this._deviceConnectionsPendingReconnection.delete(e), this._deviceConnectionsByHidDevice.set(i, e);
    try {
      e.setDependencies({ device: i }), await e.setupConnection(), e.eventDeviceConnected();
    } catch (t) {
      this._logger.error("Error while reconnecting to device", { data: { event, error: t } }), e.closeConnection();
    }
  }
  async handleDeviceConnectionEvent(e) {
    if (!this.isHIDConnectionEvent(e)) {
      this._logger.error("Invalid event", { data: { event: e } });
      return;
    }
    this._logger.info("[handleDeviceConnectionEvent] Device connected", { data: { event: e } });
    const i = Array.from(this._deviceConnectionsPendingReconnection).find((t) => this.getHidUsbProductId(t.getDependencies().device) === this.getHidUsbProductId(e.device));
    i && await this.handleDeviceReconnection(i, e.device), this.updateTransportDiscoveredDevices();
  }
  destroy() {
    this.stopListeningToConnectionEvents(), this._deviceConnectionsByHidDevice.forEach((e) => {
      e.closeConnection();
    }), this._deviceConnectionsPendingReconnection.clear();
  }
};
var U = ({ deviceModelDataSource: h, loggerServiceFactory: e, apduSenderServiceFactory: i, apduReceiverServiceFactory: t }) => new R(h, e, i, t);
export {
  p as WebHidSendReportError,
  R as WebHidTransport,
  d3 as WebHidTransportNotSupportedError,
  P as webHidIdentifier,
  U as webHidTransportFactory
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@ledgerhq_device-transport-kit-web-hid.js.map
