var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re2 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t23 = exports.t = {};
    var R6 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max2] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max2}}`).split(`${token}+`).join(`${token}{1,${max2}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R6++;
      debug(name, index, value);
      t23[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t23.NUMERICIDENTIFIER]})\\.(${src[t23.NUMERICIDENTIFIER]})\\.(${src[t23.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t23.NUMERICIDENTIFIERLOOSE]})\\.(${src[t23.NUMERICIDENTIFIERLOOSE]})\\.(${src[t23.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t23.NONNUMERICIDENTIFIER]}|${src[t23.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t23.NONNUMERICIDENTIFIER]}|${src[t23.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t23.PRERELEASEIDENTIFIER]}(?:\\.${src[t23.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t23.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t23.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t23.BUILDIDENTIFIER]}(?:\\.${src[t23.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t23.MAINVERSION]}${src[t23.PRERELEASE]}?${src[t23.BUILD]}?`);
    createToken("FULL", `^${src[t23.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t23.MAINVERSIONLOOSE]}${src[t23.PRERELEASELOOSE]}?${src[t23.BUILD]}?`);
    createToken("LOOSE", `^${src[t23.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t23.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t23.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t23.XRANGEIDENTIFIER]})(?:\\.(${src[t23.XRANGEIDENTIFIER]})(?:\\.(${src[t23.XRANGEIDENTIFIER]})(?:${src[t23.PRERELEASE]})?${src[t23.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t23.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t23.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t23.XRANGEIDENTIFIERLOOSE]})(?:${src[t23.PRERELEASELOOSE]})?${src[t23.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t23.GTLT]}\\s*${src[t23.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t23.GTLT]}\\s*${src[t23.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t23.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t23.COERCEPLAIN] + `(?:${src[t23.PRERELEASE]})?(?:${src[t23.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t23.COERCE], true);
    createToken("COERCERTLFULL", src[t23.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t23.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t23.LONETILDE]}${src[t23.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t23.LONETILDE]}${src[t23.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t23.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t23.LONECARET]}${src[t23.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t23.LONECARET]}${src[t23.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t23.GTLT]}\\s*(${src[t23.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t23.GTLT]}\\s*(${src[t23.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t23.GTLT]}\\s*(${src[t23.LOOSEPLAIN]}|${src[t23.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t23.XRANGEPLAIN]})\\s+-\\s+(${src[t23.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t23.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t23.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a24, b6) => {
      const anum = numeric.test(a24);
      const bnum = numeric.test(b6);
      if (anum && bnum) {
        a24 = +a24;
        b6 = +b6;
      }
      return a24 === b6 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a24 < b6 ? -1 : 1;
    };
    var rcompareIdentifiers = (a24, b6) => compareIdentifiers(b6, a24);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    "use strict";
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re2, t: t23 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m15 = version.trim().match(options.loose ? re2[t23.LOOSE] : re2[t23.FULL]);
        if (!m15) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m15[1];
        this.minor = +m15[2];
        this.patch = +m15[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m15[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m15[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m15[5] ? m15[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i23 = 0;
        do {
          const a24 = this.prerelease[i23];
          const b6 = other.prerelease[i23];
          debug("prerelease compare", i23, a24, b6);
          if (a24 === void 0 && b6 === void 0) {
            return 0;
          } else if (b6 === void 0) {
            return 1;
          } else if (a24 === void 0) {
            return -1;
          } else if (a24 === b6) {
            continue;
          } else {
            return compareIdentifiers(a24, b6);
          }
        } while (++i23);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i23 = 0;
        do {
          const a24 = this.build[i23];
          const b6 = other.build[i23];
          debug("build compare", i23, a24, b6);
          if (a24 === void 0 && b6 === void 0) {
            return 0;
          } else if (b6 === void 0) {
            return 1;
          } else if (a24 === void 0) {
            return -1;
          } else if (a24 === b6) {
            continue;
          } else {
            return compareIdentifiers(a24, b6);
          }
        } while (++i23);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re2[t23.PRERELEASELOOSE] : re2[t23.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i23 = this.prerelease.length;
              while (--i23 >= 0) {
                if (typeof this.prerelease[i23] === "number") {
                  this.prerelease[i23]++;
                  i23 = -2;
                }
              }
              if (i23 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    "use strict";
    var parse2 = require_parse();
    var valid = (version, options) => {
      const v22 = parse2(version, options);
      return v22 ? v22.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    "use strict";
    var parse2 = require_parse();
    var clean2 = (version, options) => {
      const s25 = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s25 ? s25.version : null;
    };
    module.exports = clean2;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    "use strict";
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse2(version1, null, true);
      const v22 = parse2(version2, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var major = (a24, loose) => new SemVer(a24, loose).major;
    module.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a24, loose) => new SemVer(a24, loose).minor;
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a24, loose) => new SemVer(a24, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    "use strict";
    var parse2 = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a24, b6, loose) => new SemVer(a24, loose).compare(new SemVer(b6, loose));
    module.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a24, b6, loose) => compare(b6, a24, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a24, b6) => compare(a24, b6, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a24, b6, loose) => {
      const versionA = new SemVer(a24, loose);
      const versionB = new SemVer(b6, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a24, b6) => compareBuild(a24, b6, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a24, b6) => compareBuild(b6, a24, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gt = (a24, b6, loose) => compare(a24, b6, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lt = (a24, b6, loose) => compare(a24, b6, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var eq = (a24, b6, loose) => compare(a24, b6, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var neq = (a24, b6, loose) => compare(a24, b6, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var gte = (a24, b6, loose) => compare(a24, b6, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    "use strict";
    var compare = require_compare();
    var lte = (a24, b6, loose) => compare(a24, b6, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a24, op, b6, loose) => {
      switch (op) {
        case "===":
          if (typeof a24 === "object") {
            a24 = a24.version;
          }
          if (typeof b6 === "object") {
            b6 = b6.version;
          }
          return a24 === b6;
        case "!==":
          if (typeof a24 === "object") {
            a24 = a24.version;
          }
          if (typeof b6 === "object") {
            b6 = b6.version;
          }
          return a24 !== b6;
        case "":
        case "=":
        case "==":
          return eq(a24, b6, loose);
        case "!=":
          return neq(a24, b6, loose);
        case ">":
          return gt(a24, b6, loose);
        case ">=":
          return gte(a24, b6, loose);
        case "<":
          return lt(a24, b6, loose);
        case "<=":
          return lte(a24, b6, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { safeRe: re2, t: t23 } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re2[t23.COERCEFULL] : re2[t23.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re2[t23.COERCERTLFULL] : re2[t23.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof _Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new _Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r10) => this.parseRange(r10.trim())).filter((c21) => c21.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c21) => !isNullSet(c21[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c21 of this.set) {
              if (c21.length === 1 && isAny(c21[0])) {
                this.set = [c21];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i23 = 0; i23 < this.set.length; i23++) {
            if (i23 > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i23];
            for (let k6 = 0; k6 < comps.length; k6++) {
              if (k6 > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k6].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re2[t23.HYPHENRANGELOOSE] : re2[t23.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re2[t23.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re2[t23.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re2[t23.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re2[t23.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i23 = 0; i23 < this.set.length; i23++) {
          if (testSet(this.set[i23], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache2 = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re2,
      t: t23,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c21) => c21.value === "<0.0.0-0";
    var isAny = (c21) => c21.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c21) => replaceTilde(c21, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r10 = options.loose ? re2[t23.TILDELOOSE] : re2[t23.TILDE];
      return comp.replace(r10, (_6, M5, m15, p30, pr) => {
        debug("tilde", comp, _6, M5, m15, p30, pr);
        let ret;
        if (isX(M5)) {
          ret = "";
        } else if (isX(m15)) {
          ret = `>=${M5}.0.0 <${+M5 + 1}.0.0-0`;
        } else if (isX(p30)) {
          ret = `>=${M5}.${m15}.0 <${M5}.${+m15 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M5}.${m15}.${p30}-${pr} <${M5}.${+m15 + 1}.0-0`;
        } else {
          ret = `>=${M5}.${m15}.${p30} <${M5}.${+m15 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c21) => replaceCaret(c21, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r10 = options.loose ? re2[t23.CARETLOOSE] : re2[t23.CARET];
      const z3 = options.includePrerelease ? "-0" : "";
      return comp.replace(r10, (_6, M5, m15, p30, pr) => {
        debug("caret", comp, _6, M5, m15, p30, pr);
        let ret;
        if (isX(M5)) {
          ret = "";
        } else if (isX(m15)) {
          ret = `>=${M5}.0.0${z3} <${+M5 + 1}.0.0-0`;
        } else if (isX(p30)) {
          if (M5 === "0") {
            ret = `>=${M5}.${m15}.0${z3} <${M5}.${+m15 + 1}.0-0`;
          } else {
            ret = `>=${M5}.${m15}.0${z3} <${+M5 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M5 === "0") {
            if (m15 === "0") {
              ret = `>=${M5}.${m15}.${p30}-${pr} <${M5}.${m15}.${+p30 + 1}-0`;
            } else {
              ret = `>=${M5}.${m15}.${p30}-${pr} <${M5}.${+m15 + 1}.0-0`;
            }
          } else {
            ret = `>=${M5}.${m15}.${p30}-${pr} <${+M5 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M5 === "0") {
            if (m15 === "0") {
              ret = `>=${M5}.${m15}.${p30}${z3} <${M5}.${m15}.${+p30 + 1}-0`;
            } else {
              ret = `>=${M5}.${m15}.${p30}${z3} <${M5}.${+m15 + 1}.0-0`;
            }
          } else {
            ret = `>=${M5}.${m15}.${p30} <${+M5 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c21) => replaceXRange(c21, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r10 = options.loose ? re2[t23.XRANGELOOSE] : re2[t23.XRANGE];
      return comp.replace(r10, (ret, gtlt, M5, m15, p30, pr) => {
        debug("xRange", comp, ret, gtlt, M5, m15, p30, pr);
        const xM = isX(M5);
        const xm = xM || isX(m15);
        const xp = xm || isX(p30);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m15 = 0;
          }
          p30 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M5 = +M5 + 1;
              m15 = 0;
              p30 = 0;
            } else {
              m15 = +m15 + 1;
              p30 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M5 = +M5 + 1;
            } else {
              m15 = +m15 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M5}.${m15}.${p30}${pr}`;
        } else if (xm) {
          ret = `>=${M5}.0.0${pr} <${+M5 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M5}.${m15}.0${pr} <${M5}.${+m15 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re2[t23.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re2[options.includePrerelease ? t23.GTE0PRE : t23.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from2, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from2 = "";
      } else if (isX(fm)) {
        from2 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from2 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from2 = `>=${from2}`;
      } else {
        from2 = `>=${from2}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from2} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i23 = 0; i23 < set.length; i23++) {
        if (!set[i23].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i23 = 0; i23 < set.length; i23++) {
          debug(set[i23].semver);
          if (set[i23].semver === Comparator.ANY) {
            continue;
          }
          if (set[i23].semver.prerelease.length > 0) {
            const allowed = set[i23].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r10 = this.options.loose ? re2[t23.COMPARATORLOOSE] : re2[t23.COMPARATOR];
        const m15 = comp.match(r10);
        if (!m15) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m15[1] !== void 0 ? m15[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m15[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m15[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re2, t: t23 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var satisfies = (version, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c21) => c21.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range2, options) => {
      let max2 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v22) => {
        if (rangeObj.test(v22)) {
          if (!max2 || maxSV.compare(v22) === -1) {
            max2 = v22;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min2 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v22) => {
        if (rangeObj.test(v22)) {
          if (!min2 || minSV.compare(v22) === 1) {
            min2 = v22;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i23 = 0; i23 < range2.set.length; ++i23) {
        const comparators = range2.set[i23];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range2, hilo, options) => {
      version = new SemVer(version, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range2, options)) {
        return false;
      }
      for (let i23 = 0; i23 < range2.set.length; ++i23) {
        const comparators = range2.set[i23];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var gtr = (version, range2, options) => outside(version, range2, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    "use strict";
    var outside = require_outside();
    var ltr = (version, range2, options) => outside(version, range2, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range2, options) => {
      const set = [];
      let first2 = null;
      let prev = null;
      const v22 = versions.sort((a24, b6) => compare(a24, b6, options));
      for (const version of v22) {
        const included = satisfies(version, range2, options);
        if (included) {
          prev = version;
          if (!first2) {
            first2 = version;
          }
        } else {
          if (prev) {
            set.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set.push([first2, null]);
      }
      const ranges = [];
      for (const [min2, max2] of set) {
        if (min2 === max2) {
          ranges.push(min2);
        } else if (!max2 && min2 === v22[0]) {
          ranges.push("*");
        } else if (!max2) {
          ranges.push(`>=${min2}`);
        } else if (min2 === v22[0]) {
          ranges.push(`<=${max2}`);
        } else {
          ranges.push(`${min2} - ${max2}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c21 of sub) {
        if (c21.operator === ">" || c21.operator === ">=") {
          gt = higherGT(gt, c21, options);
        } else if (c21.operator === "<" || c21.operator === "<=") {
          lt = lowerLT(lt, c21, options);
        } else {
          eqSet.add(c21.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c21 of dom) {
          if (!satisfies(eq, String(c21), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c21 of dom) {
        hasDomGT = hasDomGT || c21.operator === ">" || c21.operator === ">=";
        hasDomLT = hasDomLT || c21.operator === "<" || c21.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c21.semver.prerelease && c21.semver.prerelease.length && c21.semver.major === needDomGTPre.major && c21.semver.minor === needDomGTPre.minor && c21.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c21.operator === ">" || c21.operator === ">=") {
            higher = higherGT(gt, c21, options);
            if (higher === c21 && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c21), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c21.semver.prerelease && c21.semver.prerelease.length && c21.semver.major === needDomLTPre.major && c21.semver.minor === needDomLTPre.minor && c21.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c21.operator === "<" || c21.operator === "<=") {
            lower = lowerLT(lt, c21, options);
            if (lower === c21 && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c21), options)) {
            return false;
          }
        }
        if (!c21.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a24, b6, options) => {
      if (!a24) {
        return b6;
      }
      const comp = compare(a24.semver, b6.semver, options);
      return comp > 0 ? a24 : comp < 0 ? b6 : b6.operator === ">" && a24.operator === ">=" ? b6 : a24;
    };
    var lowerLT = (a24, b6, options) => {
      if (!a24) {
        return b6;
      }
      const comp = compare(a24.semver, b6.semver, options);
      return comp < 0 ? a24 : comp > 0 ? b6 : b6.operator === "<" && a24.operator === "<=" ? b6 : a24;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean2 = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse2,
      valid,
      clean: clean2,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map2(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string2, fn) {
        var parts = string2.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string2 = parts[1];
        }
        string2 = string2.replace(regexSeparators, ".");
        var labels = string2.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string2) {
        var output = [], counter = 0, length = string2.length, value, extra;
        while (counter < length) {
          value = string2.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string2.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map2(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k6 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k6 += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k6 + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i23 = 0, n18 = initialN, bias = initialBias, basic, j4, index, oldi, w8, k6, digit, t23, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j4 = 0; j4 < basic; ++j4) {
          if (input.charCodeAt(j4) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j4));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i23, w8 = 1, k6 = base; ; k6 += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i23) / w8)) {
              error("overflow");
            }
            i23 += digit * w8;
            t23 = k6 <= bias ? tMin : k6 >= bias + tMax ? tMax : k6 - bias;
            if (digit < t23) {
              break;
            }
            baseMinusT = base - t23;
            if (w8 > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w8 *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i23 - oldi, out, oldi == 0);
          if (floor(i23 / out) > maxInt - n18) {
            error("overflow");
          }
          n18 += floor(i23 / out);
          i23 %= out;
          output.splice(i23++, 0, n18);
        }
        return ucs2encode(output);
      }
      function encode3(input) {
        var n18, delta, handledCPCount, basicLength, bias, j4, m15, q3, k6, t23, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n18 = initialN;
        delta = 0;
        bias = initialBias;
        for (j4 = 0; j4 < inputLength; ++j4) {
          currentValue = input[j4];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m15 = maxInt, j4 = 0; j4 < inputLength; ++j4) {
            currentValue = input[j4];
            if (currentValue >= n18 && currentValue < m15) {
              m15 = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m15 - n18 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m15 - n18) * handledCPCountPlusOne;
          n18 = m15;
          for (j4 = 0; j4 < inputLength; ++j4) {
            currentValue = input[j4];
            if (currentValue < n18 && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n18) {
              for (q3 = delta, k6 = base; ; k6 += base) {
                t23 = k6 <= bias ? tMin : k6 >= bias + tMax ? tMax : k6 - bias;
                if (q3 < t23) {
                  break;
                }
                qMinusT = q3 - t23;
                baseMinusT = base - t23;
                output.push(
                  stringFromCharCode(digitToBasic(t23 + qMinusT % baseMinusT, 0))
                );
                q3 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q3, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n18;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string2) {
          return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string2) {
          return regexNonASCII.test(string2) ? "xn--" + encode3(string2) : string2;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode3,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag2 = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O4) {
      return O4.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray6(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from2, noIndent) {
        if (from2) {
          seen = $arrSlice.call(seen);
          seen.push(from2);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp2(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s25 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i23 = 0; i23 < attrs.length; i23++) {
          s25 += " " + attrs[i23].name + "=" + wrapQuotes(quote(attrs[i23].value), "double", opts);
        }
        s25 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s25 += "...";
        }
        s25 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s25;
      }
      if (isArray6(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate2(obj) && !isRegExp2(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag2 && Object(obj) === obj && toStringTag2 in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s25, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s25 + quoteChar;
    }
    function quote(s25) {
      return $replace.call(String(s25), /"/g, "&quot;");
    }
    function canTrustToString(obj) {
      return !toStringTag2 || !(typeof obj === "object" && (toStringTag2 in obj || typeof obj[toStringTag2] !== "undefined"));
    }
    function isArray6(obj) {
      return toStr(obj) === "[object Array]" && canTrustToString(obj);
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && canTrustToString(obj);
    }
    function isRegExp2(obj) {
      return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && canTrustToString(obj);
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && canTrustToString(obj);
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && canTrustToString(obj);
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e18) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e18) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f9) {
      if (f9.name) {
        return f9.name;
      }
      var m15 = $match.call(functionToString.call(f9), /^function\s*([\w$]+)/);
      if (m15) {
        return m15[1];
      }
      return null;
    }
    function indexOf(xs, x8) {
      if (xs.indexOf) {
        return xs.indexOf(x8);
      }
      for (var i23 = 0, l19 = xs.length; i23 < l19; i23++) {
        if (xs[i23] === x8) {
          return i23;
        }
      }
      return -1;
    }
    function isMap(x8) {
      if (!mapSize || !x8 || typeof x8 !== "object") {
        return false;
      }
      try {
        mapSize.call(x8);
        try {
          setSize.call(x8);
        } catch (s25) {
          return true;
        }
        return x8 instanceof Map;
      } catch (e18) {
      }
      return false;
    }
    function isWeakMap(x8) {
      if (!weakMapHas || !x8 || typeof x8 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x8, weakMapHas);
        try {
          weakSetHas.call(x8, weakSetHas);
        } catch (s25) {
          return true;
        }
        return x8 instanceof WeakMap;
      } catch (e18) {
      }
      return false;
    }
    function isWeakRef(x8) {
      if (!weakRefDeref || !x8 || typeof x8 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x8);
        return true;
      } catch (e18) {
      }
      return false;
    }
    function isSet(x8) {
      if (!setSize || !x8 || typeof x8 !== "object") {
        return false;
      }
      try {
        setSize.call(x8);
        try {
          mapSize.call(x8);
        } catch (m15) {
          return true;
        }
        return x8 instanceof Set;
      } catch (e18) {
      }
      return false;
    }
    function isWeakSet(x8) {
      if (!weakSetHas || !x8 || typeof x8 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x8, weakSetHas);
        try {
          weakMapHas.call(x8, weakMapHas);
        } catch (s25) {
          return true;
        }
        return x8 instanceof WeakSet;
      } catch (e18) {
      }
      return false;
    }
    function isElement(x8) {
      if (!x8 || typeof x8 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x8 instanceof HTMLElement) {
        return true;
      }
      return typeof x8.nodeName === "string" && typeof x8.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s25 = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s25, "single", opts);
    }
    function lowbyte(c21) {
      var n18 = c21.charCodeAt(0);
      var x8 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n18];
      if (x8) {
        return "\\" + x8;
      }
      return "\\x" + (n18 < 16 ? "0" : "") + $toUpperCase.call(n18.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i23 = 0; i23 < xs.length; i23++) {
        if (indexOf(xs[i23], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray6(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i23 = 0; i23 < obj.length; i23++) {
          xs[i23] = has(obj, i23) ? inspect(obj[i23], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k6 = 0; k6 < syms.length; k6++) {
          symMap["$" + syms[k6]] = syms[k6];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j4 = 0; j4 < syms.length; j4++) {
          if (isEnumerable.call(obj, syms[j4])) {
            xs.push("[" + inspect(syms[j4]) + "]: " + inspect(obj[syms[j4]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/side-channel-list/index.js"(exports, module) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root && root === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range2 = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a24) {
      return a24 !== a24;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number2) {
      if ($isNaN(number2) || number2 === 0) {
        return number2;
      }
      return number2 < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e18) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e18) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _6 in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a24, b6) {
      var arr = [];
      for (var i23 = 0; i23 < a24.length; i23 += 1) {
        arr[i23] = a24[i23];
      }
      for (var j4 = 0; j4 < b6.length; j4 += 1) {
        arr[j4 + a24.length] = b6[j4];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i23 = offset || 0, j4 = 0; i23 < arrLike.length; i23 += 1, j4 += 1) {
        arr[j4] = arrLike[i23];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i23 = 0; i23 < arr.length; i23 += 1) {
        str += arr[i23];
        if (i23 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind3(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max2(0, target.length - args.length);
      var boundArgs = [];
      for (var i23 = 0; i23 < boundLength; i23++) {
        boundArgs[i23] = "$" + i23;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind3 = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind3.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind3 = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind3, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e18) {
      if (!e18 || typeof e18 !== "object" || !("code" in e18) || e18.code !== "ERR_PROTO_ACCESS") {
        throw e18;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O4) {
      return reflectGetProto(O4);
    } : originalGetProto ? function getProto(O4) {
      if (!O4 || typeof O4 !== "object" && typeof O4 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O4);
    } : getDunderProto ? function getProto(O4) {
      return getDunderProto(O4);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind3 = require_function_bind();
    module.exports = bind3.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range2();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max2 = require_max();
    var min2 = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e18) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max2,
      "%Math.min%": min2,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e18) {
        errorProto = getProto(getProto(e18));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen2 = doEval2("%AsyncGenerator%");
        if (gen2 && getProto) {
          value = getProto(gen2.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind3 = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind3.call($call, Array.prototype.concat);
    var $spliceApply = bind3.call($apply, Array.prototype.splice);
    var $replace = bind3.call($call, String.prototype.replace);
    var $strSlice = bind3.call($call, String.prototype.slice);
    var $exec = bind3.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first2 = $strSlice(string2, 0, 1);
      var last3 = $strSlice(string2, -1);
      if (first2 === "%" && last3 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last3 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i23 = 1, isOwn = true; i23 < parts.length; i23 += 1) {
        var part = parts[i23];
        var first2 = $strSlice(part, 0, 1);
        var last3 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last3 === '"' || last3 === "'" || last3 === "`")) && first2 !== last3) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i23 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/side-channel-map/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/side-channel-weakmap/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray6 = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i23 = 0; i23 < 256; ++i23) {
        array.push("%" + ((i23 < 16 ? "0" : "") + i23.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray6(obj)) {
          var compacted = [];
          for (var j4 = 0; j4 < obj.length; ++j4) {
            if (typeof obj[j4] !== "undefined") {
              compacted.push(obj[j4]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject2 = function arrayToObject3(source, options) {
      var obj = options && options.plainObjects ? { __proto__: null } : {};
      for (var i23 = 0; i23 < source.length; ++i23) {
        if (typeof source[i23] !== "undefined") {
          obj[i23] = source[i23];
        }
      }
      return obj;
    };
    var merge4 = function merge5(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray6(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray6(target) && !isArray6(source)) {
        mergeTarget = arrayToObject2(target, options);
      }
      if (isArray6(target) && isArray6(source)) {
        source.forEach(function(item, i23) {
          if (has.call(target, i23)) {
            var targetItem = target[i23];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i23] = merge5(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i23] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge5(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e18) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode3 = function encode4(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string2 = str;
      if (typeof str === "symbol") {
        string2 = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string2 = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j4 = 0; j4 < string2.length; j4 += limit) {
        var segment = string2.length >= limit ? string2.slice(j4, j4 + limit) : string2;
        var arr = [];
        for (var i23 = 0; i23 < segment.length; ++i23) {
          var c21 = segment.charCodeAt(i23);
          if (c21 === 45 || c21 === 46 || c21 === 95 || c21 === 126 || c21 >= 48 && c21 <= 57 || c21 >= 65 && c21 <= 90 || c21 >= 97 && c21 <= 122 || format === formats.RFC1738 && (c21 === 40 || c21 === 41)) {
            arr[arr.length] = segment.charAt(i23);
            continue;
          }
          if (c21 < 128) {
            arr[arr.length] = hexTable[c21];
            continue;
          }
          if (c21 < 2048) {
            arr[arr.length] = hexTable[192 | c21 >> 6] + hexTable[128 | c21 & 63];
            continue;
          }
          if (c21 < 55296 || c21 >= 57344) {
            arr[arr.length] = hexTable[224 | c21 >> 12] + hexTable[128 | c21 >> 6 & 63] + hexTable[128 | c21 & 63];
            continue;
          }
          i23 += 1;
          c21 = 65536 + ((c21 & 1023) << 10 | segment.charCodeAt(i23) & 1023);
          arr[arr.length] = hexTable[240 | c21 >> 18] + hexTable[128 | c21 >> 12 & 63] + hexTable[128 | c21 >> 6 & 63] + hexTable[128 | c21 & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue2 = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i23 = 0; i23 < queue2.length; ++i23) {
        var item = queue2[i23];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j4 = 0; j4 < keys.length; ++j4) {
          var key = keys[j4];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value;
    };
    var isRegExp2 = function isRegExp3(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer2 = function isBuffer3(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a24, b6) {
      return [].concat(a24, b6);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray6(val)) {
        var mapped = [];
        for (var i23 = 0; i23 < val.length; i23 += 1) {
          mapped.push(fn(val[i23]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject: arrayToObject2,
      assign: assign2,
      combine,
      compact,
      decode,
      encode: encode3,
      isBuffer: isBuffer2,
      isRegExp: isRegExp2,
      maybeMap,
      merge: merge4
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat2(prefix) {
        return prefix;
      }
    };
    var isArray6 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray6(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults2 = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date2) {
        return toISO.call(date2);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v22) {
      return typeof v22 === "string" || typeof v22 === "number" || typeof v22 === "boolean" || typeof v22 === "symbol" || typeof v22 === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter3, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter3 === "function") {
        obj = filter3(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray6(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray6(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray6(filter3)) {
        objKeys = filter3;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray6(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray6(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j4 = 0; j4 < objKeys.length; ++j4) {
        var key = objKeys[j4];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray6(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray6(obj) ? null : encoder,
          filter3,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults2.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter3 = defaults2.filter;
      if (typeof opts.filter === "function" || isArray6(opts.filter)) {
        filter3 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults2.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults2.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
        filter: filter3,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter3;
      if (typeof options.filter === "function") {
        filter3 = options.filter;
        obj = filter3("", obj);
      } else if (isArray6(options.filter)) {
        filter3 = options.filter;
        objKeys = filter3;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i23 = 0; i23 < objKeys.length; ++i23) {
        var key = objKeys[i23];
        var value = obj[key];
        if (options.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray6 = Array.isArray;
    var defaults2 = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options, currentArrayLength) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(
        options.delimiter,
        options.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i23;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i23 = 0; i23 < parts.length; ++i23) {
          if (parts[i23].indexOf("utf8=") === 0) {
            if (parts[i23] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i23] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i23;
            i23 = parts.length;
          }
        }
      }
      for (i23 = 0; i23 < parts.length; ++i23) {
        if (i23 === skipIndex) {
          continue;
        }
        var part = parts[i23];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options.decoder(part, defaults2.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults2.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(
              part.slice(pos + 1),
              options,
              isArray6(obj[key]) ? obj[key].length : 0
            ),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults2.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray6(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var currentArrayLength = 0;
      if (chain.length > 0 && chain[chain.length - 1] === "[]") {
        var parentKey = chain.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
      for (var i23 = chain.length - 1; i23 >= 0; --i23) {
        var obj;
        var root = chain[i23];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils.combine([], leaf);
        } else {
          obj = options.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i23 = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i23 < options.depth) {
        i23 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults2;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults2.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults2.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults2.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults2.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults2.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? { __proto__: null } : {};
      var keys = Object.keys(tempObj);
      for (var i23 = 0; i23 < keys.length; ++i23) {
        var key = keys[i23];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse2 = require_parse2();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// node_modules/url/url.js
var require_url = __commonJS({
  "node_modules/url/url.js"(exports) {
    "use strict";
    var punycode = require_punycode();
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    var unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    var hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_lib();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof url === "object" && url instanceof Url) {
        return url;
      }
      var u14 = new Url();
      u14.parse(url, parseQueryString, slashesDenoteHost);
      return u14;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i23 = 0; i23 < hostEndingChars.length; i23++) {
          var hec = rest.indexOf(hostEndingChars[i23]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i23 = 0; i23 < nonHostChars.length; i23++) {
          var hec = rest.indexOf(nonHostChars[i23]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i23 = 0, l19 = hostparts.length; i23 < l19; i23++) {
            var part = hostparts[i23];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j4 = 0, k6 = part.length; j4 < k6; j4++) {
                if (part.charCodeAt(j4) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j4];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i23);
                var notHost = hostparts.slice(i23 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p30 = this.port ? ":" + this.port : "";
        var h5 = this.hostname || "";
        this.host = h5 + p30;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i23 = 0, l19 = autoEscape.length; i23 < l19; i23++) {
          var ae2 = autoEscape[i23];
          if (rest.indexOf(ae2) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae2);
          if (esc === ae2) {
            esc = escape(ae2);
          }
          rest = rest.split(ae2).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p30 = this.pathname || "";
        var s25 = this.search || "";
        this.path = p30 + s25;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source) {
        return relative;
      }
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (typeof relative === "string") {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v22 = 0; v22 < keys.length; v22++) {
            var k6 = keys[v22];
            result[k6] = relative[k6];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift())) {
          }
          if (!relative.host) {
            relative.host = "";
          }
          if (!relative.hostname) {
            relative.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p30 = result.pathname || "";
          var s25 = result.search || "";
          result.path = p30 + s25;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "") {
              relPath[0] = relative.host;
            } else {
              relPath.unshift(relative.host);
            }
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (relative.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last3 = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last3 === "." || last3 === "..") || last3 === "";
      var up = 0;
      for (var i23 = srcPath.length; i23 >= 0; i23--) {
        last3 = srcPath[i23];
        if (last3 === ".") {
          srcPath.splice(i23, 1);
        } else if (last3 === "..") {
          srcPath.splice(i23, 1);
          up++;
        } else if (up) {
          srcPath.splice(i23, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
  }
});

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
(function(Reflect3) {
  (function(factory2) {
    var root = typeof globalThis === "object" ? globalThis : typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : sloppyModeThis();
    var exporter = makeExporter(Reflect3);
    if (typeof root.Reflect !== "undefined") {
      exporter = makeExporter(root.Reflect, exporter);
    }
    factory2(exporter, root);
    if (typeof root.Reflect === "undefined") {
      root.Reflect = Reflect3;
    }
    function makeExporter(target, previous) {
      return function(key, value) {
        Object.defineProperty(target, key, { configurable: true, writable: true, value });
        if (previous)
          previous(key, value);
      };
    }
    function functionThis() {
      try {
        return Function("return this;")();
      } catch (_6) {
      }
    }
    function indirectEvalThis() {
      try {
        return (void 0, eval)("(function() { return this; })()");
      } catch (_6) {
      }
    }
    function sloppyModeThis() {
      return functionThis() || indirectEvalThis();
    }
  })(function(exporter, root) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var supportsSymbol = typeof Symbol === "function";
    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
    var supportsCreate = typeof Object.create === "function";
    var supportsProto = { __proto__: [] } instanceof Array;
    var downLevel = !supportsCreate && !supportsProto;
    var HashMap = {
      // create an object in dictionary mode (a.k.a. "slow" mode in v8)
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({ __proto__: null });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key);
      } : function(map2, key) {
        return key in map2;
      },
      get: downLevel ? function(map2, key) {
        return hasOwn.call(map2, key) ? map2[key] : void 0;
      } : function(map2, key) {
        return map2[key];
      }
    };
    var functionPrototype = Object.getPrototypeOf(Function);
    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
    var registrySymbol = supportsSymbol ? Symbol.for("@reflect-metadata:registry") : void 0;
    var metadataRegistry = GetOrCreateMetadataRegistry();
    var metadataProvider = CreateMetadataProvider(metadataRegistry);
    function decorate(decorators, target, propertyKey, attributes) {
      if (!IsUndefined(propertyKey)) {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsObject(target))
          throw new TypeError();
        if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
          throw new TypeError();
        if (IsNull(attributes))
          attributes = void 0;
        propertyKey = ToPropertyKey(propertyKey);
        return DecorateProperty(decorators, target, propertyKey, attributes);
      } else {
        if (!IsArray(decorators))
          throw new TypeError();
        if (!IsConstructor(target))
          throw new TypeError();
        return DecorateConstructor(decorators, target);
      }
    }
    exporter("decorate", decorate);
    function metadata(metadataKey, metadataValue) {
      function decorator(target, propertyKey) {
        if (!IsObject(target))
          throw new TypeError();
        if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
          throw new TypeError();
        OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      return decorator;
    }
    exporter("metadata", metadata);
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    exporter("defineMetadata", defineMetadata);
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasMetadata", hasMetadata);
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("hasOwnMetadata", hasOwnMetadata);
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    exporter("getMetadata", getMetadata);
    function getOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
    }
    exporter("getOwnMetadata", getOwnMetadata);
    function getMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryMetadataKeys(target, propertyKey);
    }
    exporter("getMetadataKeys", getMetadataKeys);
    function getOwnMetadataKeys(target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      return OrdinaryOwnMetadataKeys(target, propertyKey);
    }
    exporter("getOwnMetadataKeys", getOwnMetadataKeys);
    function deleteMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      if (!IsObject(target))
        throw new TypeError();
      if (!IsUndefined(propertyKey))
        propertyKey = ToPropertyKey(propertyKey);
      var provider = GetMetadataProvider(
        target,
        propertyKey,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);
    }
    exporter("deleteMetadata", deleteMetadata);
    function DecorateConstructor(decorators, target) {
      for (var i23 = decorators.length - 1; i23 >= 0; --i23) {
        var decorator = decorators[i23];
        var decorated = decorator(target);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsConstructor(decorated))
            throw new TypeError();
          target = decorated;
        }
      }
      return target;
    }
    function DecorateProperty(decorators, target, propertyKey, descriptor) {
      for (var i23 = decorators.length - 1; i23 >= 0; --i23) {
        var decorator = decorators[i23];
        var decorated = decorator(target, propertyKey, descriptor);
        if (!IsUndefined(decorated) && !IsNull(decorated)) {
          if (!IsObject(decorated))
            throw new TypeError();
          descriptor = decorated;
        }
      }
      return descriptor;
    }
    function OrdinaryHasMetadata(MetadataKey, O4, P6) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O4, P6);
      if (hasOwn2)
        return true;
      var parent = OrdinaryGetPrototypeOf(O4);
      if (!IsNull(parent))
        return OrdinaryHasMetadata(MetadataKey, parent, P6);
      return false;
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O4, P6) {
      var provider = GetMetadataProvider(
        O4,
        P6,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return false;
      return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O4, P6));
    }
    function OrdinaryGetMetadata(MetadataKey, O4, P6) {
      var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O4, P6);
      if (hasOwn2)
        return OrdinaryGetOwnMetadata(MetadataKey, O4, P6);
      var parent = OrdinaryGetPrototypeOf(O4);
      if (!IsNull(parent))
        return OrdinaryGetMetadata(MetadataKey, parent, P6);
      return void 0;
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O4, P6) {
      var provider = GetMetadataProvider(
        O4,
        P6,
        /*Create*/
        false
      );
      if (IsUndefined(provider))
        return;
      return provider.OrdinaryGetOwnMetadata(MetadataKey, O4, P6);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O4, P6) {
      var provider = GetMetadataProvider(
        O4,
        P6,
        /*Create*/
        true
      );
      provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O4, P6);
    }
    function OrdinaryMetadataKeys(O4, P6) {
      var ownKeys = OrdinaryOwnMetadataKeys(O4, P6);
      var parent = OrdinaryGetPrototypeOf(O4);
      if (parent === null)
        return ownKeys;
      var parentKeys = OrdinaryMetadataKeys(parent, P6);
      if (parentKeys.length <= 0)
        return ownKeys;
      if (ownKeys.length <= 0)
        return parentKeys;
      var set = new _Set();
      var keys = [];
      for (var _i2 = 0, ownKeys_1 = ownKeys; _i2 < ownKeys_1.length; _i2++) {
        var key = ownKeys_1[_i2];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      for (var _a7 = 0, parentKeys_1 = parentKeys; _a7 < parentKeys_1.length; _a7++) {
        var key = parentKeys_1[_a7];
        var hasKey = set.has(key);
        if (!hasKey) {
          set.add(key);
          keys.push(key);
        }
      }
      return keys;
    }
    function OrdinaryOwnMetadataKeys(O4, P6) {
      var provider = GetMetadataProvider(
        O4,
        P6,
        /*create*/
        false
      );
      if (!provider) {
        return [];
      }
      return provider.OrdinaryOwnMetadataKeys(O4, P6);
    }
    function Type(x8) {
      if (x8 === null)
        return 1;
      switch (typeof x8) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return x8 === null ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x8) {
      return x8 === void 0;
    }
    function IsNull(x8) {
      return x8 === null;
    }
    function IsSymbol(x8) {
      return typeof x8 === "symbol";
    }
    function IsObject(x8) {
      return typeof x8 === "object" ? x8 !== null : typeof x8 === "function";
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
          return input;
        case 1:
          return input;
        case 2:
          return input;
        case 3:
          return input;
        case 4:
          return input;
        case 5:
          return input;
      }
      var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
      var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (exoticToPrim !== void 0) {
        var result = exoticToPrim.call(input, hint);
        if (IsObject(result))
          throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
    }
    function OrdinaryToPrimitive(O4, hint) {
      if (hint === "string") {
        var toString_1 = O4.toString;
        if (IsCallable(toString_1)) {
          var result = toString_1.call(O4);
          if (!IsObject(result))
            return result;
        }
        var valueOf = O4.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O4);
          if (!IsObject(result))
            return result;
        }
      } else {
        var valueOf = O4.valueOf;
        if (IsCallable(valueOf)) {
          var result = valueOf.call(O4);
          if (!IsObject(result))
            return result;
        }
        var toString_2 = O4.toString;
        if (IsCallable(toString_2)) {
          var result = toString_2.call(O4);
          if (!IsObject(result))
            return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      var key = ToPrimitive(
        argument,
        3
        /* String */
      );
      if (IsSymbol(key))
        return key;
      return ToString(key);
    }
    function IsArray(argument) {
      return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
    }
    function IsCallable(argument) {
      return typeof argument === "function";
    }
    function IsConstructor(argument) {
      return typeof argument === "function";
    }
    function IsPropertyKey(argument) {
      switch (Type(argument)) {
        case 3:
          return true;
        case 4:
          return true;
        default:
          return false;
      }
    }
    function SameValueZero(x8, y6) {
      return x8 === y6 || x8 !== x8 && y6 !== y6;
    }
    function GetMethod(V3, P6) {
      var func = V3[P6];
      if (func === void 0 || func === null)
        return void 0;
      if (!IsCallable(func))
        throw new TypeError();
      return func;
    }
    function GetIterator(obj) {
      var method = GetMethod(obj, iteratorSymbol);
      if (!IsCallable(method))
        throw new TypeError();
      var iterator3 = method.call(obj);
      if (!IsObject(iterator3))
        throw new TypeError();
      return iterator3;
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IteratorStep(iterator3) {
      var result = iterator3.next();
      return result.done ? false : result;
    }
    function IteratorClose(iterator3) {
      var f9 = iterator3["return"];
      if (f9)
        f9.call(iterator3);
    }
    function OrdinaryGetPrototypeOf(O4) {
      var proto = Object.getPrototypeOf(O4);
      if (typeof O4 !== "function" || O4 === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      var prototype3 = O4.prototype;
      var prototypeProto = prototype3 && Object.getPrototypeOf(prototype3);
      if (prototypeProto == null || prototypeProto === Object.prototype)
        return proto;
      var constructor = prototypeProto.constructor;
      if (typeof constructor !== "function")
        return proto;
      if (constructor === O4)
        return proto;
      return constructor;
    }
    function CreateMetadataRegistry() {
      var fallback;
      if (!IsUndefined(registrySymbol) && typeof root.Reflect !== "undefined" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === "function") {
        fallback = CreateFallbackProvider(root.Reflect);
      }
      var first2;
      var second;
      var rest;
      var targetProviderMap = new _WeakMap();
      var registry = {
        registerProvider,
        getProvider,
        setProvider
      };
      return registry;
      function registerProvider(provider) {
        if (!Object.isExtensible(registry)) {
          throw new Error("Cannot add provider to a frozen registry.");
        }
        switch (true) {
          case fallback === provider:
            break;
          case IsUndefined(first2):
            first2 = provider;
            break;
          case first2 === provider:
            break;
          case IsUndefined(second):
            second = provider;
            break;
          case second === provider:
            break;
          default:
            if (rest === void 0)
              rest = new _Set();
            rest.add(provider);
            break;
        }
      }
      function getProviderNoCache(O4, P6) {
        if (!IsUndefined(first2)) {
          if (first2.isProviderFor(O4, P6))
            return first2;
          if (!IsUndefined(second)) {
            if (second.isProviderFor(O4, P6))
              return first2;
            if (!IsUndefined(rest)) {
              var iterator3 = GetIterator(rest);
              while (true) {
                var next = IteratorStep(iterator3);
                if (!next) {
                  return void 0;
                }
                var provider = IteratorValue(next);
                if (provider.isProviderFor(O4, P6)) {
                  IteratorClose(iterator3);
                  return provider;
                }
              }
            }
          }
        }
        if (!IsUndefined(fallback) && fallback.isProviderFor(O4, P6)) {
          return fallback;
        }
        return void 0;
      }
      function getProvider(O4, P6) {
        var providerMap = targetProviderMap.get(O4);
        var provider;
        if (!IsUndefined(providerMap)) {
          provider = providerMap.get(P6);
        }
        if (!IsUndefined(provider)) {
          return provider;
        }
        provider = getProviderNoCache(O4, P6);
        if (!IsUndefined(provider)) {
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O4, providerMap);
          }
          providerMap.set(P6, provider);
        }
        return provider;
      }
      function hasProvider(provider) {
        if (IsUndefined(provider))
          throw new TypeError();
        return first2 === provider || second === provider || !IsUndefined(rest) && rest.has(provider);
      }
      function setProvider(O4, P6, provider) {
        if (!hasProvider(provider)) {
          throw new Error("Metadata provider not registered.");
        }
        var existingProvider = getProvider(O4, P6);
        if (existingProvider !== provider) {
          if (!IsUndefined(existingProvider)) {
            return false;
          }
          var providerMap = targetProviderMap.get(O4);
          if (IsUndefined(providerMap)) {
            providerMap = new _Map();
            targetProviderMap.set(O4, providerMap);
          }
          providerMap.set(P6, provider);
        }
        return true;
      }
    }
    function GetOrCreateMetadataRegistry() {
      var metadataRegistry2;
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        metadataRegistry2 = root.Reflect[registrySymbol];
      }
      if (IsUndefined(metadataRegistry2)) {
        metadataRegistry2 = CreateMetadataRegistry();
      }
      if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {
        Object.defineProperty(root.Reflect, registrySymbol, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: metadataRegistry2
        });
      }
      return metadataRegistry2;
    }
    function CreateMetadataProvider(registry) {
      var metadata2 = new _WeakMap();
      var provider = {
        isProviderFor: function(O4, P6) {
          var targetMetadata = metadata2.get(O4);
          if (IsUndefined(targetMetadata))
            return false;
          return targetMetadata.has(P6);
        },
        OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata2,
        OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata2,
        OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata2,
        OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys2,
        OrdinaryDeleteMetadata
      };
      metadataRegistry.registerProvider(provider);
      return provider;
      function GetOrCreateMetadataMap(O4, P6, Create) {
        var targetMetadata = metadata2.get(O4);
        var createdTargetMetadata = false;
        if (IsUndefined(targetMetadata)) {
          if (!Create)
            return void 0;
          targetMetadata = new _Map();
          metadata2.set(O4, targetMetadata);
          createdTargetMetadata = true;
        }
        var metadataMap = targetMetadata.get(P6);
        if (IsUndefined(metadataMap)) {
          if (!Create)
            return void 0;
          metadataMap = new _Map();
          targetMetadata.set(P6, metadataMap);
          if (!registry.setProvider(O4, P6, provider)) {
            targetMetadata.delete(P6);
            if (createdTargetMetadata) {
              metadata2.delete(O4);
            }
            throw new Error("Wrong provider for target.");
          }
        }
        return metadataMap;
      }
      function OrdinaryHasOwnMetadata2(MetadataKey, O4, P6) {
        var metadataMap = GetOrCreateMetadataMap(
          O4,
          P6,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        return ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetOwnMetadata2(MetadataKey, O4, P6) {
        var metadataMap = GetOrCreateMetadataMap(
          O4,
          P6,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return void 0;
        return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata2(MetadataKey, MetadataValue, O4, P6) {
        var metadataMap = GetOrCreateMetadataMap(
          O4,
          P6,
          /*Create*/
          true
        );
        metadataMap.set(MetadataKey, MetadataValue);
      }
      function OrdinaryOwnMetadataKeys2(O4, P6) {
        var keys = [];
        var metadataMap = GetOrCreateMetadataMap(
          O4,
          P6,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return keys;
        var keysObj = metadataMap.keys();
        var iterator3 = GetIterator(keysObj);
        var k6 = 0;
        while (true) {
          var next = IteratorStep(iterator3);
          if (!next) {
            keys.length = k6;
            return keys;
          }
          var nextValue = IteratorValue(next);
          try {
            keys[k6] = nextValue;
          } catch (e18) {
            try {
              IteratorClose(iterator3);
            } finally {
              throw e18;
            }
          }
          k6++;
        }
      }
      function OrdinaryDeleteMetadata(MetadataKey, O4, P6) {
        var metadataMap = GetOrCreateMetadataMap(
          O4,
          P6,
          /*Create*/
          false
        );
        if (IsUndefined(metadataMap))
          return false;
        if (!metadataMap.delete(MetadataKey))
          return false;
        if (metadataMap.size === 0) {
          var targetMetadata = metadata2.get(O4);
          if (!IsUndefined(targetMetadata)) {
            targetMetadata.delete(P6);
            if (targetMetadata.size === 0) {
              metadata2.delete(targetMetadata);
            }
          }
        }
        return true;
      }
    }
    function CreateFallbackProvider(reflect) {
      var defineMetadata2 = reflect.defineMetadata, hasOwnMetadata2 = reflect.hasOwnMetadata, getOwnMetadata2 = reflect.getOwnMetadata, getOwnMetadataKeys2 = reflect.getOwnMetadataKeys, deleteMetadata2 = reflect.deleteMetadata;
      var metadataOwner = new _WeakMap();
      var provider = {
        isProviderFor: function(O4, P6) {
          var metadataPropertySet = metadataOwner.get(O4);
          if (!IsUndefined(metadataPropertySet) && metadataPropertySet.has(P6)) {
            return true;
          }
          if (getOwnMetadataKeys2(O4, P6).length) {
            if (IsUndefined(metadataPropertySet)) {
              metadataPropertySet = new _Set();
              metadataOwner.set(O4, metadataPropertySet);
            }
            metadataPropertySet.add(P6);
            return true;
          }
          return false;
        },
        OrdinaryDefineOwnMetadata: defineMetadata2,
        OrdinaryHasOwnMetadata: hasOwnMetadata2,
        OrdinaryGetOwnMetadata: getOwnMetadata2,
        OrdinaryOwnMetadataKeys: getOwnMetadataKeys2,
        OrdinaryDeleteMetadata: deleteMetadata2
      };
      return provider;
    }
    function GetMetadataProvider(O4, P6, Create) {
      var registeredProvider = metadataRegistry.getProvider(O4, P6);
      if (!IsUndefined(registeredProvider)) {
        return registeredProvider;
      }
      if (Create) {
        if (metadataRegistry.setProvider(O4, P6, metadataProvider)) {
          return metadataProvider;
        }
        throw new Error("Illegal state.");
      }
      return void 0;
    }
    function CreateMapPolyfill() {
      var cacheSentinel = {};
      var arraySentinel = [];
      var MapIterator = (
        /** @class */
        function() {
          function MapIterator2(keys, values, selector) {
            this._index = 0;
            this._keys = keys;
            this._values = values;
            this._selector = selector;
          }
          MapIterator2.prototype["@@iterator"] = function() {
            return this;
          };
          MapIterator2.prototype[iteratorSymbol] = function() {
            return this;
          };
          MapIterator2.prototype.next = function() {
            var index = this._index;
            if (index >= 0 && index < this._keys.length) {
              var result = this._selector(this._keys[index], this._values[index]);
              if (index + 1 >= this._keys.length) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              } else {
                this._index++;
              }
              return { value: result, done: false };
            }
            return { value: void 0, done: true };
          };
          MapIterator2.prototype.throw = function(error) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            throw error;
          };
          MapIterator2.prototype.return = function(value) {
            if (this._index >= 0) {
              this._index = -1;
              this._keys = arraySentinel;
              this._values = arraySentinel;
            }
            return { value, done: true };
          };
          return MapIterator2;
        }()
      );
      var Map2 = (
        /** @class */
        function() {
          function Map3() {
            this._keys = [];
            this._values = [];
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          }
          Object.defineProperty(Map3.prototype, "size", {
            get: function() {
              return this._keys.length;
            },
            enumerable: true,
            configurable: true
          });
          Map3.prototype.has = function(key) {
            return this._find(
              key,
              /*insert*/
              false
            ) >= 0;
          };
          Map3.prototype.get = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            return index >= 0 ? this._values[index] : void 0;
          };
          Map3.prototype.set = function(key, value) {
            var index = this._find(
              key,
              /*insert*/
              true
            );
            this._values[index] = value;
            return this;
          };
          Map3.prototype.delete = function(key) {
            var index = this._find(
              key,
              /*insert*/
              false
            );
            if (index >= 0) {
              var size = this._keys.length;
              for (var i23 = index + 1; i23 < size; i23++) {
                this._keys[i23 - 1] = this._keys[i23];
                this._values[i23 - 1] = this._values[i23];
              }
              this._keys.length--;
              this._values.length--;
              if (SameValueZero(key, this._cacheKey)) {
                this._cacheKey = cacheSentinel;
                this._cacheIndex = -2;
              }
              return true;
            }
            return false;
          };
          Map3.prototype.clear = function() {
            this._keys.length = 0;
            this._values.length = 0;
            this._cacheKey = cacheSentinel;
            this._cacheIndex = -2;
          };
          Map3.prototype.keys = function() {
            return new MapIterator(this._keys, this._values, getKey);
          };
          Map3.prototype.values = function() {
            return new MapIterator(this._keys, this._values, getValue);
          };
          Map3.prototype.entries = function() {
            return new MapIterator(this._keys, this._values, getEntry);
          };
          Map3.prototype["@@iterator"] = function() {
            return this.entries();
          };
          Map3.prototype[iteratorSymbol] = function() {
            return this.entries();
          };
          Map3.prototype._find = function(key, insert) {
            if (!SameValueZero(this._cacheKey, key)) {
              this._cacheIndex = -1;
              for (var i23 = 0; i23 < this._keys.length; i23++) {
                if (SameValueZero(this._keys[i23], key)) {
                  this._cacheIndex = i23;
                  break;
                }
              }
            }
            if (this._cacheIndex < 0 && insert) {
              this._cacheIndex = this._keys.length;
              this._keys.push(key);
              this._values.push(void 0);
            }
            return this._cacheIndex;
          };
          return Map3;
        }()
      );
      return Map2;
      function getKey(key, _6) {
        return key;
      }
      function getValue(_6, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      var Set2 = (
        /** @class */
        function() {
          function Set3() {
            this._map = new _Map();
          }
          Object.defineProperty(Set3.prototype, "size", {
            get: function() {
              return this._map.size;
            },
            enumerable: true,
            configurable: true
          });
          Set3.prototype.has = function(value) {
            return this._map.has(value);
          };
          Set3.prototype.add = function(value) {
            return this._map.set(value, value), this;
          };
          Set3.prototype.delete = function(value) {
            return this._map.delete(value);
          };
          Set3.prototype.clear = function() {
            this._map.clear();
          };
          Set3.prototype.keys = function() {
            return this._map.keys();
          };
          Set3.prototype.values = function() {
            return this._map.keys();
          };
          Set3.prototype.entries = function() {
            return this._map.entries();
          };
          Set3.prototype["@@iterator"] = function() {
            return this.keys();
          };
          Set3.prototype[iteratorSymbol] = function() {
            return this.keys();
          };
          return Set3;
        }()
      );
      return Set2;
    }
    function CreateWeakMapPolyfill() {
      var UUID_SIZE = 16;
      var keys = HashMap.create();
      var rootKey = CreateUniqueKey();
      return (
        /** @class */
        function() {
          function WeakMap2() {
            this._key = CreateUniqueKey();
          }
          WeakMap2.prototype.has = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.has(table, this._key) : false;
          };
          WeakMap2.prototype.get = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? HashMap.get(table, this._key) : void 0;
          };
          WeakMap2.prototype.set = function(target, value) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              true
            );
            table[this._key] = value;
            return this;
          };
          WeakMap2.prototype.delete = function(target) {
            var table = GetOrCreateWeakMapTable(
              target,
              /*create*/
              false
            );
            return table !== void 0 ? delete table[this._key] : false;
          };
          WeakMap2.prototype.clear = function() {
            this._key = CreateUniqueKey();
          };
          return WeakMap2;
        }()
      );
      function CreateUniqueKey() {
        var key;
        do
          key = "@@WeakMap@@" + CreateUUID();
        while (HashMap.has(keys, key));
        keys[key] = true;
        return key;
      }
      function GetOrCreateWeakMapTable(target, create) {
        if (!hasOwn.call(target, rootKey)) {
          if (!create)
            return void 0;
          Object.defineProperty(target, rootKey, { value: HashMap.create() });
        }
        return target[rootKey];
      }
      function FillRandomBytes(buffer2, size) {
        for (var i23 = 0; i23 < size; ++i23)
          buffer2[i23] = Math.random() * 255 | 0;
        return buffer2;
      }
      function GenRandomBytes(size) {
        if (typeof Uint8Array === "function") {
          var array = new Uint8Array(size);
          if (typeof crypto !== "undefined") {
            crypto.getRandomValues(array);
          } else if (typeof msCrypto !== "undefined") {
            msCrypto.getRandomValues(array);
          } else {
            FillRandomBytes(array, size);
          }
          return array;
        }
        return FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        var data = GenRandomBytes(UUID_SIZE);
        data[6] = data[6] & 79 | 64;
        data[8] = data[8] & 191 | 128;
        var result = "";
        for (var offset = 0; offset < UUID_SIZE; ++offset) {
          var byte = data[offset];
          if (offset === 4 || offset === 6 || offset === 8)
            result += "-";
          if (byte < 16)
            result += "0";
          result += byte.toString(16).toLowerCase();
        }
        return result;
      }
    }
    function MakeDictionary(obj) {
      obj.__ = void 0;
      delete obj.__;
      return obj;
    }
  });
})(Reflect2 || (Reflect2 = {}));

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/model/Apdu.js
var s = class {
  constructor(t23, n18, r10, a24, e18) {
    __publicField(this, "cla");
    __publicField(this, "ins");
    __publicField(this, "p1");
    __publicField(this, "p2");
    __publicField(this, "data");
    this.cla = t23, this.ins = n18, this.p1 = r10, this.p2 = a24, this.data = e18 ?? new Uint8Array();
  }
  getRawApdu() {
    const t23 = Uint8Array.from([this.cla, this.ins, this.p1, this.p2, this.data.length]), n18 = new Uint8Array(t23.length + this.data.length);
    return n18.set(t23, 0), this.data.length > 0 && n18.set(this.data, t23.length), n18;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/utils/HexaString.js
function e(r10) {
  return typeof r10 == "string" && /^0x[0-9a-fA-F]*$/.test(r10);
}
function f(r10) {
  var _a7;
  if (r10.startsWith("0x") && (r10 = r10.slice(2)), r10.length === 0) return new Uint8Array();
  if (r10.length % 2 !== 0 && (r10 = "0" + r10), /^[0-9a-fA-F]*$/.test(r10) === false) return null;
  const t23 = (_a7 = r10.match(/.{1,2}/g)) == null ? void 0 : _a7.map((n18) => parseInt(n18, 16));
  return !t23 || t23.some(isNaN) ? null : new Uint8Array(t23);
}
function o(r10, t23 = true) {
  return `${t23 ? "0x" : ""}${Array.from(r10, (i23) => i23.toString(16).padStart(2, "0")).join("")}`;
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/utils/AppBuilderError.js
var l = class {
  constructor(r10, e18 = r) {
    __publicField(this, "_tag", "ValueOverflow");
    __publicField(this, "originalError");
    __publicField(this, "message");
    this.message = `Value overflow for ${r10}, max is ${e18}`;
  }
};
var s2 = class {
  constructor(r10, e18 = 0) {
    __publicField(this, "_tag", "DataOverflow");
    __publicField(this, "message");
    __publicField(this, "originalError");
    this.message = e18 === 0 ? `this.data is already full (value: ${r10})` : `this.data will overflow with "${r10}", remaining bytes: ${e18}`;
  }
};
var i = class {
  constructor(r10) {
    __publicField(this, "_tag", "HexaString");
    __publicField(this, "message");
    __publicField(this, "originalError");
    this.message = `Invalid encoded hexa string or length is null: ${r10}`;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/utils/ByteArrayBuilder.js
var b = 4294967295;
var g = class {
  constructor(t23 = b) {
    __publicField(this, "data", new Uint8Array());
    __publicField(this, "errors", []);
    __publicField(this, "build", () => this.data);
    __publicField(this, "tryBuild", () => this.hasErrors() ? void 0 : this.data);
    __publicField(this, "add8BitUIntToData", (t23) => this.addNumberToData(t23, 8n, false, false));
    __publicField(this, "add16BitUIntToData", (t23, r10 = true) => this.addNumberToData(t23, 16n, false, r10));
    __publicField(this, "add32BitUIntToData", (t23, r10 = true) => this.addNumberToData(t23, 32n, false, r10));
    __publicField(this, "add64BitUIntToData", (t23, r10 = true) => this.addNumberToData(t23, 64n, false, r10));
    __publicField(this, "add128BitUIntToData", (t23, r10 = true) => this.addNumberToData(t23, 128n, false, r10));
    __publicField(this, "add256BitUIntToData", (t23, r10 = true) => this.addNumberToData(t23, 256n, false, r10));
    __publicField(this, "add16BitIntToData", (t23, r10 = true) => this.addNumberToData(t23, 16n, true, r10));
    __publicField(this, "add32BitIntToData", (t23, r10 = true) => this.addNumberToData(t23, 32n, true, r10));
    __publicField(this, "add64BitIntToData", (t23, r10 = true) => this.addNumberToData(t23, 64n, true, r10));
    __publicField(this, "add128BitIntToData", (t23, r10 = true) => this.addNumberToData(t23, 128n, true, r10));
    __publicField(this, "add256BitIntToData", (t23, r10 = true) => this.addNumberToData(t23, 256n, true, r10));
    __publicField(this, "addBufferToData", (t23) => this.hasEnoughLengthRemaining(t23) ? (this.data = Uint8Array.from([...this.data, ...t23]), this) : (this.errors.push(new s2(t23.toString())), this));
    __publicField(this, "addHexaStringToData", (t23) => {
      const r10 = f(t23);
      return r10 === null || r10.length === 0 ? (this.errors.push(new i(t23)), this) : (this.addBufferToData(r10), this);
    });
    __publicField(this, "addAsciiStringToData", (t23) => {
      const r10 = new TextEncoder().encode(t23);
      return this.addBufferToData(r10), this;
    });
    __publicField(this, "encodeInLVFromHexa", (t23) => {
      const r10 = f(t23);
      return r10 === null || r10.length === 0 ? (this.errors.push(new i(t23)), this) : this.hasEnoughLengthRemaining(r10, true) ? (this.add8BitUIntToData(r10.length), this.addBufferToData(r10), this) : (this.errors.push(new s2(t23)), this);
    });
    __publicField(this, "encodeInLVFromBuffer", (t23) => this.hasEnoughLengthRemaining(t23, true) ? (this.add8BitUIntToData(t23.length), this.addBufferToData(t23), this) : (this.errors.push(new s2(t23.toString())), this));
    __publicField(this, "encodeInLVFromAscii", (t23) => this.hasEnoughLengthRemaining(t23, true) ? (this.add8BitUIntToData(t23.length), this.addAsciiStringToData(t23), this) : (this.errors.push(new s2(t23)), this));
    __publicField(this, "encodeInTLVFromAscii", (t23, r10) => (this.add8BitUIntToData(t23), this.encodeInLVFromAscii(r10)));
    __publicField(this, "encodeInTLVFromHexa", (t23, r10) => (this.add8BitUIntToData(t23), this.encodeInLVFromHexa(r10)));
    __publicField(this, "encodeInTLVFromBuffer", (t23, r10) => (this.add8BitUIntToData(t23), this.encodeInLVFromBuffer(r10)));
    __publicField(this, "encodeInTLVFromUInt8", (t23, r10) => (this.add8BitUIntToData(t23), this.add8BitUIntToData(1), this.add8BitUIntToData(r10)));
    __publicField(this, "encodeInTLVFromUInt16", (t23, r10, e18 = true) => (this.add8BitUIntToData(t23), this.add8BitUIntToData(2), this.add16BitUIntToData(r10, e18)));
    __publicField(this, "encodeInTLVFromUInt32", (t23, r10, e18 = true) => (this.add8BitUIntToData(t23), this.add8BitUIntToData(4), this.add32BitUIntToData(r10, e18)));
    __publicField(this, "encodeInTLVFromUInt64", (t23, r10, e18 = true) => (this.add8BitUIntToData(t23), this.add8BitUIntToData(8), this.add64BitUIntToData(r10, e18)));
    __publicField(this, "getAvailablePayloadLength", () => this.maxPayloadSize - this.data.length);
    __publicField(this, "getErrors", () => this.errors);
    __publicField(this, "hasErrors", () => this.errors.length !== 0);
    __publicField(this, "hasEnoughLengthRemaining", (t23, r10 = false) => this.data.length + t23.length + (r10 ? 1 : 0) <= this.maxPayloadSize);
    this.maxPayloadSize = t23;
  }
  addNumberToData(t23, r10, e18, n18) {
    let i23 = this.checkBoundsAndConvert(t23, r10, e18);
    if (i23 === void 0) return this;
    const d18 = Number(r10) / 8, u14 = new Uint8Array(d18);
    if (n18) for (let a24 = d18 - 1; a24 >= 0; a24--) u14[a24] = Number(i23 & 0xffn), i23 >>= 8n;
    else for (let a24 = 0; a24 < d18; a24++) u14[a24] = Number(i23 & 0xffn), i23 >>= 8n;
    return this.addBufferToData(u14);
  }
  checkBoundsAndConvert(t23, r10, e18) {
    if (typeof t23 == "number") {
      if (!Number.isInteger(t23) || t23 > Number.MAX_SAFE_INTEGER) {
        this.errors.push(new l(t23.toString()));
        return;
      }
      t23 = BigInt(t23);
    }
    if (e18) {
      const n18 = 1n << r10 - 1n;
      if (t23 >= n18 || t23 < -n18) {
        this.errors.push(new l(t23.toString(), n18 - 1n));
        return;
      }
      if (t23 < 0n) {
        const i23 = (1n << r10) - 1n;
        t23 = -t23, t23 = (~t23 & i23) + 1n;
      }
    } else {
      const n18 = 1n << r10;
      if (t23 < 0 || t23 >= n18) {
        this.errors.push(new l(t23.toString(), n18 - 1n));
        return;
      }
    }
    return t23;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/utils/ApduBuilder.js
var r = 255;
var l2 = r + 5;
var A = class {
  constructor({ ins: t23, cla: a24, p1: e18, p2: d18 }) {
    __publicField(this, "_ins");
    __publicField(this, "_cla");
    __publicField(this, "_p1");
    __publicField(this, "p2");
    __publicField(this, "data", new g(r));
    __publicField(this, "build", () => new s(this._cla, this._ins, this._p1, this.p2, this.data.build()));
    __publicField(this, "add8BitUIntToData", (t23) => (this.data.add8BitUIntToData(t23), this));
    __publicField(this, "add16BitUIntToData", (t23) => (this.data.add16BitUIntToData(t23), this));
    __publicField(this, "add32BitUIntToData", (t23) => (this.data.add32BitUIntToData(t23), this));
    __publicField(this, "addBufferToData", (t23) => (this.data.addBufferToData(t23), this));
    __publicField(this, "addHexaStringToData", (t23) => (this.data.addHexaStringToData(t23), this));
    __publicField(this, "addAsciiStringToData", (t23) => (this.data.addAsciiStringToData(t23), this));
    __publicField(this, "encodeInLVFromHexa", (t23) => (this.data.encodeInLVFromHexa(t23), this));
    __publicField(this, "encodeInLVFromBuffer", (t23) => (this.data.encodeInLVFromBuffer(t23), this));
    __publicField(this, "encodeInLVFromAscii", (t23) => (this.data.encodeInLVFromAscii(t23), this));
    __publicField(this, "getAvailablePayloadLength", () => this.data.getAvailablePayloadLength());
    __publicField(this, "getErrors", () => this.data.getErrors());
    this._cla = a24 & 255, this._ins = t23 & 255, this._p1 = e18 & 255, this.p2 = d18 & 255;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/utils/ByteArrayParser.js
var s3 = class {
  constructor(e18) {
    __publicField(this, "index", 0);
    this.buffer = e18;
  }
  testMinimalLength(e18) {
    return e18 <= this.buffer.length - this.index;
  }
  extract8BitUInt() {
    if (!this.outOfRange(1)) return this.buffer[this.index++];
  }
  extract16BitUInt(e18 = true) {
    const t23 = this.extractNumber(16n, false, e18);
    return t23 === void 0 ? void 0 : Number(t23);
  }
  extract16BitInt(e18 = true) {
    const t23 = this.extractNumber(16n, true, e18);
    return t23 === void 0 ? void 0 : Number(t23);
  }
  extract32BitUInt(e18 = true) {
    const t23 = this.extractNumber(32n, false, e18);
    return t23 === void 0 ? void 0 : Number(t23);
  }
  extract32BitInt(e18 = true) {
    const t23 = this.extractNumber(32n, true, e18);
    return t23 === void 0 ? void 0 : Number(t23);
  }
  extract64BitUInt(e18 = true) {
    return this.extractNumber(64n, false, e18);
  }
  extract64BitInt(e18 = true) {
    return this.extractNumber(64n, true, e18);
  }
  extract128BitUInt(e18 = true) {
    return this.extractNumber(128n, false, e18);
  }
  extract128BitInt(e18 = true) {
    return this.extractNumber(128n, true, e18);
  }
  extract256BitUInt(e18 = true) {
    return this.extractNumber(256n, false, e18);
  }
  extract256BitInt(e18 = true) {
    return this.extractNumber(256n, true, e18);
  }
  extractFieldByLength(e18) {
    if (this.outOfRange(e18)) return;
    if (e18 === 0) return new Uint8Array();
    const t23 = this.buffer.slice(this.index, this.index + e18);
    return this.index += e18, t23;
  }
  extractFieldLVEncoded() {
    const e18 = this.extract8BitUInt();
    if (e18 === void 0) return;
    if (e18 === 0) return new Uint8Array();
    const t23 = this.extractFieldByLength(e18);
    return t23 === void 0 && this.index--, t23;
  }
  extractFieldTLVEncoded() {
    if (this.outOfRange(2)) return;
    const e18 = this.index, t23 = this.extract8BitUInt(), n18 = this.extractFieldLVEncoded();
    if (t23 === void 0 || n18 === void 0) {
      this.index--;
      return;
    }
    const i23 = this.index;
    return { tag: t23, value: n18, tlv: this.buffer.slice(e18, i23) };
  }
  encodeToHexaString(e18, t23 = false) {
    if (e18 === void 0 || e18.length === 0) return "";
    const n18 = o(e18);
    return t23 ? n18 : n18.slice(2);
  }
  encodeToString(e18) {
    let t23 = "", n18 = 0;
    if (!e18) return t23;
    for (; n18 <= e18.length; ) {
      const i23 = e18[n18];
      i23 && (t23 += String.fromCharCode(i23)), n18++;
    }
    return t23;
  }
  getCurrentIndex() {
    return this.index;
  }
  resetIndex() {
    this.index = 0;
  }
  getUnparsedRemainingLength() {
    return this.buffer.length - this.index;
  }
  outOfRange(e18) {
    return this.index + e18 > this.buffer.length;
  }
  extractNumber(e18, t23, n18) {
    const i23 = Number(e18) / 8;
    if (this.outOfRange(i23)) return;
    let u14 = 0n;
    if (n18) for (let r10 = 0; r10 < i23; r10++) u14 = u14 << 8n | BigInt(this.buffer[r10 + this.index]);
    else for (let r10 = i23 - 1; r10 >= 0; r10--) u14 = u14 << 8n | BigInt(this.buffer[r10 + this.index]);
    if (t23) {
      const r10 = 1n << e18 - 1n;
      u14 & r10 && (u14 -= r10 << 1n);
    }
    return this.index += i23, u14;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/apdu/utils/ApduParser.js
var i2 = class {
  constructor(e18) {
    __publicField(this, "parser");
    __publicField(this, "testMinimalLength", (e18) => this.parser.testMinimalLength(e18));
    __publicField(this, "extract8BitUInt", () => this.parser.extract8BitUInt());
    __publicField(this, "extract16BitUInt", () => this.parser.extract16BitUInt());
    __publicField(this, "extract32BitUInt", () => this.parser.extract32BitUInt());
    __publicField(this, "extractFieldByLength", (e18) => this.parser.extractFieldByLength(e18));
    __publicField(this, "extractFieldLVEncoded", () => this.parser.extractFieldLVEncoded());
    __publicField(this, "extractFieldTLVEncoded", () => this.parser.extractFieldTLVEncoded());
    __publicField(this, "encodeToString", (e18) => this.parser.encodeToString(e18));
    __publicField(this, "getUnparsedRemainingLength", () => this.parser.getUnparsedRemainingLength());
    this.parser = new s3(e18.data);
  }
  encodeToHexaString(e18, r10 = false) {
    return r10 ? this.parser.encodeToHexaString(e18, true) : this.parser.encodeToHexaString(e18, false);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/Errors.js
var a = class {
  constructor(r10) {
    __publicField(this, "_tag", "InvalidStatusWordError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Invalid status word.");
  }
};
var t = class {
  constructor(r10) {
    __publicField(this, "_tag", "InvalidBatteryStatusTypeError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Invalid battery status type.");
  }
};
var n = class {
  constructor(r10) {
    __publicField(this, "_tag", "InvalidBatteryDataError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Invalid battery data.");
  }
};
var i3 = class {
  constructor(r10) {
    __publicField(this, "_tag", "InvalidResponseFormatError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Invalid response format.");
  }
};
var s4 = class {
  constructor(r10) {
    __publicField(this, "_tag", "InvalidGetFirmwareMetadataResponseError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Invalid Firmware Metadata response error.");
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/model/CommandResult.js
var a2 = ((e18) => (e18.Error = "ERROR", e18.Success = "SUCCESS", e18))(a2 || {});
function o2({ data: r10, error: t23 }) {
  return t23 ? { status: "ERROR", error: t23 } : { status: "SUCCESS", data: r10 };
}
function s5(r10) {
  return r10.status === "SUCCESS";
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/utils/CommandUtils.js
var e2 = class _e5 {
  static isValidStatusCode(r10) {
    return r10.length === 2;
  }
  static isSuccessResponse({ statusCode: r10 }) {
    return _e5.isValidStatusCode(r10) ? r10[0] === 144 && r10[1] === 0 : false;
  }
  static isLockedDeviceResponse({ statusCode: r10 }) {
    return _e5.isValidStatusCode(r10) ? r10[0] === 85 && r10[1] === 21 || r10[0] === 105 && r10[1] === 130 || r10[0] === 83 && r10[1] === 3 : false;
  }
  static isRefusedByUser({ statusCode: r10 }) {
    return _e5.isValidStatusCode(r10) ? r10[0] === 85 && r10[1] === 1 || r10[0] === 105 && r10[1] === 133 : false;
  }
  static isAppAlreadyInstalled({ statusCode: r10 }) {
    return _e5.isValidStatusCode(r10) ? r10[0] === 106 && r10[1] === 128 || r10[0] === 106 && r10[1] === 129 || r10[0] === 106 && r10[1] === 142 || r10[0] === 106 && r10[1] === 143 : false;
  }
  static isOutOfMemory({ statusCode: r10 }) {
    return _e5.isValidStatusCode(r10) ? r10[0] === 106 && r10[1] === 132 || r10[0] === 106 && r10[1] === 133 || r10[0] === 81 && r10[1] === 2 || r10[0] === 81 && r10[1] === 3 : false;
  }
  static isApduThatTriggersDisconnection(r10) {
    const x8 = /* @__PURE__ */ new Map();
    return x8.set("openApp", new Uint8Array([224, 216, 0, 0])), x8.set("closeApp", new Uint8Array([176, 167, 0, 0])), Array.from(x8.values()).some((n18) => {
      for (let i23 = 0; i23 < 4; i23++) if (n18[i23] !== r10[i23]) return false;
      return true;
    });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/Error.js
var s6 = class {
  constructor({ tag: r10, errorCode: o12, originalError: n18, message: i23 }) {
    __publicField(this, "_tag");
    __publicField(this, "originalError");
    __publicField(this, "errorCode");
    __publicField(this, "message");
    this._tag = r10, this.originalError = n18, this.errorCode = o12, this.message = i23 ?? "An error occured during device exchange.";
  }
};
var a3 = class {
  constructor(r10) {
    __publicField(this, "_tag", "UnknownDeviceExchangeError");
    __publicField(this, "originalError");
    __publicField(this, "message");
    this.originalError = r10, this.message = "Unexpected device exchange error happened.";
  }
};
var c = class {
  constructor(r10) {
    __publicField(this, "_tag", "DeviceBusyError");
    __publicField(this, "originalError");
    this.originalError = r10 ?? new Error("Device is busy, please try again later");
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/utils/CommandErrors.js
var o3 = (r10, e18) => Object.keys(e18).includes(r10);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/utils/GlobalCommandError.js
var d = class extends s6 {
  constructor(r10) {
    super({ tag: "GlobalCommandError", ...r10 });
  }
};
var o4 = { 5515: { message: "Device is locked.", tag: "DeviceLockedError" }, 5501: { message: "Action refused on device.", tag: "ActionRefusedError" }, 5502: { message: "Pin is not set", tag: "PinNotSetError" }, 5223: { message: "Device internal error", tag: "DeviceInternalError" }, "6e00": { message: "CLA not supported", tag: "DeviceInternalError" }, "6d00": { message: "INS not supported", tag: "DeviceInternalError" } };
var p = class {
  static handle(r10) {
    const e18 = new i2(r10).encodeToHexaString(r10.statusCode);
    return o3(e18, o4) ? new d({ ...o4[e18], errorCode: e18 }) : new a3({ message: "UnknownError", errorCode: e18 });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/CloseAppCommand.js
var i4 = class {
  constructor() {
    __publicField(this, "name", "closeApp");
    __publicField(this, "args");
    __publicField(this, "triggersDisconnection", true);
  }
  getApdu() {
    const e18 = { cla: 176, ins: 167, p1: 0, p2: 0 };
    return new A(e18).build();
  }
  parseResponse(e18) {
    return e2.isSuccessResponse(e18) ? o2({ data: void 0 }) : o2({ error: p.handle(e18) });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/GetAppAndVersionCommand.js
var R = class {
  constructor() {
    __publicField(this, "name", "getAppAndVersion");
    __publicField(this, "args");
  }
  getApdu() {
    const r10 = { cla: 176, ins: 1, p1: 0, p2: 0 };
    return new A(r10).build();
  }
  parseResponse(r10) {
    if (!e2.isSuccessResponse(r10)) return o2({ error: p.handle(r10) });
    const e18 = new i2(r10);
    if (e18.extract8BitUInt() !== 1) return o2({ error: new i3("getAppAndVersion: format not supported") });
    const o12 = e18.encodeToString(e18.extractFieldLVEncoded()), t23 = e18.encodeToString(e18.extractFieldLVEncoded());
    if (e18.getUnparsedRemainingLength() === 0) return o2({ data: { name: o12, version: t23 } });
    const p30 = e18.extractFieldLVEncoded();
    return o2({ data: { name: o12, version: t23, flags: p30 } });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/GetBatteryStatusCommand.js
var A2 = ((t23) => (t23[t23.BATTERY_PERCENTAGE = 0] = "BATTERY_PERCENTAGE", t23[t23.BATTERY_VOLTAGE = 1] = "BATTERY_VOLTAGE", t23[t23.BATTERY_TEMPERATURE = 2] = "BATTERY_TEMPERATURE", t23[t23.BATTERY_CURRENT = 3] = "BATTERY_CURRENT", t23[t23.BATTERY_FLAGS = 4] = "BATTERY_FLAGS", t23))(A2 || {});
var i5 = ((e18) => (e18[e18.NONE = 0] = "NONE", e18[e18.USB = 1] = "USB", e18[e18.QI = 2] = "QI", e18))(i5 || {});
var c2 = class {
  constructor(n18) {
    __publicField(this, "name", "getBatteryStatus");
    __publicField(this, "args");
    this.args = n18;
  }
  getApdu() {
    const n18 = { cla: 224, ins: 16, p1: 0, p2: this.args.statusType };
    return new A(n18).build();
  }
  parseResponse(n18) {
    const s25 = new i2(n18);
    switch (this.args.statusType) {
      case 0: {
        const e18 = s25.extract8BitUInt();
        return e18 === void 0 ? o2({ error: new n("Cannot parse APDU response") }) : o2({ data: e18 > 100 ? -1 : e18 });
      }
      case 1: {
        const e18 = s25.extract16BitUInt();
        return e18 === void 0 ? o2({ error: new n("Cannot parse APDU response") }) : o2({ data: e18 });
      }
      case 2:
      case 3: {
        const e18 = s25.extract8BitUInt();
        return e18 === void 0 ? o2({ error: new n("Cannot parse APDU response") }) : o2({ data: e18 << 24 >> 24 });
      }
      case 4: {
        const e18 = s25.extract32BitUInt();
        if (e18 === void 0) return o2({ error: new n("Cannot parse APDU response") });
        const o12 = !!(e18 & 8), t23 = !o12 && !!(e18 & 1);
        return o2({ data: { charging: t23 ? 2 : o12 ? 1 : 0, issueCharging: !!(e18 & 16), issueTemperature: !!(e18 & 32), issueBattery: !!(e18 & 128) } });
      }
      default:
        return o2({ error: new t("One or some case(s) not covered") });
    }
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/GetOsVersionCommand.js
var import_semver = __toESM(require_semver2());

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device/DeviceModel.js
var t2 = ((e18) => (e18.NANO_S = "nanoS", e18.NANO_SP = "nanoSP", e18.NANO_X = "nanoX", e18.STAX = "stax", e18.FLEX = "flex", e18.APEX = "apexp", e18))(t2 || {});
var i6 = class {
  constructor({ id: n18, model: o12, name: r10 }) {
    __publicField(this, "id");
    __publicField(this, "model");
    __publicField(this, "name");
    this.id = n18, this.model = o12, this.name = r10;
  }
};
var l3 = 11415;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/SecureElementFlagsParser.js
var r2 = class {
  constructor(e18) {
    this.seFlags = e18;
    if (this.seFlags.length !== 4) throw new Error("Invalid secure element flags length");
  }
  generalDeviceState() {
    const e18 = this.seFlags[0] ?? 0;
    return { isPinValidated: this._checkNthBitInByte(e18, 1), hasMcuSerialNumber: this._checkNthBitInByte(e18, 2), hasValidCertificate: this._checkNthBitInByte(e18, 3), isCustomAuthorityConnectionAllowed: this._checkNthBitInByte(e18, 4), isSecureConnectionAllowed: this._checkNthBitInByte(e18, 5), isOnboarded: this._checkNthBitInByte(e18, 6), isMcuCodeSigned: this._checkNthBitInByte(e18, 7), isInRecoveryMode: this._checkNthBitInByte(e18, 8) };
  }
  endorsementInformation() {
    throw new Error("Not implemented");
  }
  wordsInformation() {
    throw new Error("Not implemented");
  }
  onboardingStatus() {
    throw new Error("Not implemented");
  }
  _checkNthBitInByte(e18, t23) {
    return (e18 >> 8 - t23 & 1) === 1;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/GetOsVersionCommand.js
var P = class {
  constructor() {
    __publicField(this, "name", "getOsVersion");
    __publicField(this, "args");
  }
  getApdu() {
    const r10 = { cla: 224, ins: 1, p1: 0, p2: 0 };
    return new A(r10).build();
  }
  parseResponse(r10, n18) {
    if (!e2.isSuccessResponse(r10)) return o2({ error: p.handle(r10) });
    const e18 = new i2(r10), d18 = e18.extract32BitUInt();
    if (d18 === void 0) return o2({ error: new a("Missing target ID in OS version") });
    let a24 = e18.encodeToString(e18.extractFieldLVEncoded()), c21 = e18.extractFieldLVEncoded() ?? new Uint8Array(0);
    const x8 = { ...new r2(c21).generalDeviceState() };
    a24 || (a24 = "0.0.0", c21 = new Uint8Array());
    const g23 = (d18 & 4026531840) !== 805306368, I5 = a24.includes("-osu");
    let i23 = "", S13 = "", m15 = "", p30 = "", y6, l19, V3, A11;
    if (g23) {
      m15 = a24, y6 = d18;
      const o12 = e18.extractFieldLVEncoded();
      o12 && (o12.length >= 5 ? (i23 = e18.encodeToString(o12), l19 = parseInt(e18.encodeToHexaString(e18.extractFieldLVEncoded()), 16)) : l19 = parseInt(e18.encodeToHexaString(o12), 16));
    } else {
      if (i23 = a24, l19 = d18, S13 = e18.encodeToString(e18.extractFieldLVEncoded()), this.isBootloaderVersionSupported(i23, n18) && (m15 = e18.encodeToString(e18.extractFieldLVEncoded())), this.isHardwareVersionSupported(i23, n18) ? p30 = e18.encodeToHexaString(e18.extractFieldLVEncoded()) : p30 = "00", this.isLocalizationSupported(i23, n18)) {
        const o12 = e18.extractFieldLVEncoded();
        o12 !== void 0 && (V3 = parseInt(e18.encodeToHexaString(o12), 16));
      }
      if (this.isRecoverSupported(i23, n18)) {
        const o12 = e18.extractFieldLVEncoded();
        o12 !== void 0 && (A11 = parseInt(e18.encodeToHexaString(o12), 16));
      }
    }
    return o2({ data: { isBootloader: g23, isOsu: I5, targetId: d18, seTargetId: l19, mcuTargetId: y6, seVersion: i23, seFlags: c21, mcuSephVersion: S13, mcuBootloaderVersion: m15, hwVersion: p30, langId: V3, recoverState: A11, secureElementFlags: x8 } });
  }
  isBootloaderVersionSupported(r10, n18) {
    const e18 = (0, import_semver.coerce)(r10) ?? "";
    switch (n18) {
      case t2.NANO_S:
      case t2.NANO_X:
        return (0, import_semver.gte)(e18, "2.0.0");
      default:
        return true;
    }
  }
  isHardwareVersionSupported(r10, n18) {
    const e18 = (0, import_semver.coerce)(r10) ?? "";
    switch (n18) {
      case t2.NANO_X:
        return (0, import_semver.gte)(e18, "2.0.0");
      default:
        return false;
    }
  }
  isLocalizationSupported(r10, n18) {
    const e18 = (0, import_semver.coerce)(r10) ?? "";
    switch (n18) {
      case t2.NANO_S:
        return false;
      case t2.NANO_SP:
        return (0, import_semver.gte)(e18, "1.1.0");
      case t2.NANO_X:
        return (0, import_semver.gte)(e18, "2.1.0");
      default:
        return true;
    }
  }
  isRecoverSupported(r10, n18) {
    const e18 = (0, import_semver.coerce)(r10) ?? "";
    switch (n18) {
      case t2.NANO_S:
        return false;
      case t2.NANO_SP:
        return (0, import_semver.gte)(e18, "1.1.2");
      case t2.NANO_X:
        return (0, import_semver.gte)(e18, "2.2.3");
      case t2.STAX:
        return (0, import_semver.gte)(e18, "1.4.0");
      case t2.FLEX:
        return (0, import_semver.gte)(e18, "1.0.1");
      default:
        return true;
    }
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/ListAppsCommand.js
var p2 = { 6624: { message: "Invalid state (List applications command must be sent)" } };
var x = class extends s6 {
  constructor({ message: e18, errorCode: s25 }) {
    super({ message: e18, errorCode: s25, tag: "ListAppsCommandError" });
  }
};
var S = class {
  constructor(e18 = { isContinue: false }) {
    __publicField(this, "name", "listApps");
    __publicField(this, "args");
    this.args = e18;
  }
  getApdu() {
    const e18 = { cla: 224, ins: this.args.isContinue ? 223 : 222, p1: 0, p2: 0 };
    return new A(e18).build();
  }
  parseResponse(e18) {
    const s25 = [], r10 = new i2(e18);
    if (!e2.isSuccessResponse(e18)) {
      const t23 = r10.encodeToHexaString(e18.statusCode);
      return o3(t23, p2) ? o2({ error: new x({ ...p2[t23], errorCode: t23 }) }) : o2({ error: p.handle(e18) });
    }
    if (e18.data.length <= 0) return o2({ data: [] });
    for (r10.extract8BitUInt(); r10.getUnparsedRemainingLength() > 0; ) {
      const t23 = r10.extract8BitUInt(), a24 = r10.extract16BitUInt();
      r10.extract16BitUInt();
      const i23 = r10.encodeToHexaString(r10.extractFieldByLength(32)), d18 = r10.encodeToHexaString(r10.extractFieldByLength(32)), m15 = r10.encodeToString(r10.extractFieldLVEncoded());
      s25.push({ appEntryLength: t23, appSizeInBlocks: a24, appCodeHash: i23, appFullHash: d18, appName: m15 });
    }
    return o2({ data: s25 });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/LoadCertificateCommand.js
var a4 = { "422f": { message: "Incorrect structure type" }, 4230: { message: "Incorrect certificate version" }, 4231: { message: "Incorrect certificate validity" }, 4232: { message: "Incorrect certificate validity index" }, 4233: { message: "Unknown signer key ID" }, 4234: { message: "Unknown signature algorithm" }, 4235: { message: "Unknown public key ID" }, 4236: { message: "Unknown public key usage" }, 4237: { message: "Incorrect elliptic curve ID" }, 4238: { message: "Incorrect signature algorithm associated to the public key" }, 4239: { message: "Unknown target device" }, "422d": { message: "Unknown certificate tag" }, 3301: { message: "Failed to hash data" }, "422e": { message: "expected_key_usage doesn't match certificate key usage" }, 5720: { message: "Failed to verify signature" }, 4118: { message: "trusted_name buffer is too small to contain the trusted name" }, ffff: { message: "Cryptography-related error" } };
var g2 = class extends s6 {
  constructor({ message: e18, errorCode: o12 }) {
    super({ tag: "ProvidePkiCertificateCommandError", message: e18, errorCode: o12 });
  }
};
var k = class {
  constructor(e18) {
    __publicField(this, "name", "loadCertificate");
    __publicField(this, "args");
    __publicField(this, "triggersDisconnection", false);
    this.args = e18;
  }
  getApdu() {
    const e18 = { cla: 176, ins: 6, p1: this.args.keyUsage, p2: 0 };
    return new A(e18).addBufferToData(this.args.certificate).build();
  }
  parseResponse(e18) {
    if (e2.isSuccessResponse(e18)) return o2({ data: void 0 });
    const r10 = new i2(e18).encodeToHexaString(e18.statusCode);
    return o3(r10, a4) ? o2({ error: new g2({ ...a4[r10], errorCode: r10 }) }) : o2({ error: p.handle(e18) });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/OpenAppCommand.js
var n2 = { "670a": { message: "No app name provided" }, 6807: { message: "Unknown application name" } };
var u2 = class extends s6 {
  constructor({ message: r10, errorCode: p30 }) {
    super({ tag: "OpenAppCommandError", message: r10, errorCode: p30 });
  }
};
var f2 = class {
  constructor(r10) {
    __publicField(this, "name", "openApp");
    __publicField(this, "args");
    __publicField(this, "triggersDisconnection", true);
    this.args = r10;
  }
  getApdu() {
    const r10 = { cla: 224, ins: 216, p1: 0, p2: 0 };
    return new A(r10).addAsciiStringToData(this.args.appName).build();
  }
  parseResponse(r10) {
    if (e2.isSuccessResponse(r10)) return o2({ data: void 0 });
    const e18 = new i2(r10).encodeToHexaString(r10.statusCode);
    return o3(e18, n2) ? o2({ error: new u2({ ...n2[e18], errorCode: e18 }) }) : o2({ error: p.handle(r10) });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device/DeviceStatus.js
var E = ((C5) => (C5.LOCKED = "LOCKED", C5.BUSY = "BUSY", C5.CONNECTED = "CONNECTED", C5.NOT_CONNECTED = "NOT CONNECTED", C5))(E || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/model/DeviceActionState.js
var t3 = ((e18) => (e18.NotStarted = "not-started", e18.Pending = "pending", e18.Stopped = "stopped", e18.Completed = "completed", e18.Error = "error", e18))(t3 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/model/UserInteractionRequired.js
var s8 = ((p30) => (p30.None = "none", p30.UnlockDevice = "unlock-device", p30.AllowSecureConnection = "allow-secure-connection", p30.ConfirmOpenApp = "confirm-open-app", p30.SignTransaction = "sign-transaction", p30.SignTypedData = "sign-typed-data", p30.AllowListApps = "allow-list-apps", p30.VerifyAddress = "verify-address", p30.SignPersonalMessage = "sign-personal-message", p30.SignDelegationAuthorization = "sign-delegation-authorization", p30.Web3ChecksOptIn = "web3-checks-opt-in", p30.VerifySafeAddress = "verify-safe-address", p30))(s8 || {});

// node_modules/purify-ts/esm/Maybe.js
var Maybe = {
  of(value) {
    return just(value);
  },
  empty() {
    return nothing;
  },
  zero() {
    return nothing;
  },
  fromNullable(value) {
    return value == null ? nothing : just(value);
  },
  fromFalsy(value) {
    return value ? just(value) : nothing;
  },
  fromPredicate(pred, value) {
    switch (arguments.length) {
      case 1:
        return (value2) => Maybe.fromPredicate(pred, value2);
      default:
        return pred(value) ? just(value) : nothing;
    }
  },
  mapMaybe(f9, list) {
    switch (arguments.length) {
      case 1:
        return (list2) => Maybe.mapMaybe(f9, list2);
      default:
        return Maybe.catMaybes(list.map(f9));
    }
  },
  catMaybes(list) {
    let res = [];
    for (const e18 of list) {
      if (e18.isJust()) {
        res.push(e18.extract());
      }
    }
    return res;
  },
  encase(thunk) {
    try {
      return just(thunk());
    } catch {
      return nothing;
    }
  },
  isMaybe(x8) {
    return x8 instanceof Just || x8 instanceof Nothing;
  },
  sequence(maybes) {
    let res = [];
    for (const m15 of maybes) {
      if (m15.isJust()) {
        res.push(m15.extract());
      } else {
        return nothing;
      }
    }
    return just(res);
  },
  "fantasy-land/of"(value) {
    return this.of(value);
  },
  "fantasy-land/empty"() {
    return this.empty();
  },
  "fantasy-land/zero"() {
    return this.zero();
  }
};
var Just = class {
  constructor(__value) {
    this.__value = __value;
    this["fantasy-land/equals"] = this.equals;
    this["fantasy-land/map"] = this.map;
    this["fantasy-land/ap"] = this.ap;
    this["fantasy-land/alt"] = this.alt;
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/reduce"] = this.reduce;
    this["fantasy-land/extend"] = this.extend;
    this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return true;
  }
  isNothing() {
    return false;
  }
  inspect() {
    return `Just(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    const value = this.__value;
    return value instanceof Date ? value.toJSON() : value;
  }
  equals(other) {
    return this.extract() === other.extract();
  }
  map(f9) {
    return just(f9(this.__value));
  }
  ap(maybeF) {
    return maybeF.isJust() ? this.map(maybeF.extract()) : nothing;
  }
  alt(_6) {
    return this;
  }
  altLazy(_6) {
    return this;
  }
  chain(f9) {
    return f9(this.__value);
  }
  chainNullable(f9) {
    return Maybe.fromNullable(f9(this.__value));
  }
  join() {
    return this.__value;
  }
  reduce(reducer, initialValue) {
    return reducer(initialValue, this.__value);
  }
  extend(f9) {
    return just(f9(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(patterns) {
    return "_" in patterns ? patterns._() : patterns.Just(this.__value);
  }
  orDefault(_6) {
    return this.__value;
  }
  orDefaultLazy(_6) {
    return this.__value;
  }
  toList() {
    return [this.__value];
  }
  mapOrDefault(f9, _6) {
    return f9(this.__value);
  }
  extract() {
    return this.__value;
  }
  extractNullable() {
    return this.__value;
  }
  toEither(_6) {
    return right(this.__value);
  }
  ifJust(effect) {
    return effect(this.__value), this;
  }
  ifNothing(_6) {
    return this;
  }
  filter(pred) {
    return pred(this.__value) ? just(this.__value) : nothing;
  }
};
Just.prototype.constructor = Maybe;
var Nothing = class {
  constructor() {
    this["fantasy-land/equals"] = this.equals;
    this["fantasy-land/map"] = this.map;
    this["fantasy-land/ap"] = this.ap;
    this["fantasy-land/alt"] = this.alt;
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/reduce"] = this.reduce;
    this["fantasy-land/extend"] = this.extend;
    this["fantasy-land/filter"] = this.filter;
  }
  isJust() {
    return false;
  }
  isNothing() {
    return true;
  }
  inspect() {
    return "Nothing";
  }
  toString() {
    return this.inspect();
  }
  toJSON() {
    return this.__value;
  }
  equals(other) {
    return this.extract() === other.extract();
  }
  map(_6) {
    return nothing;
  }
  ap(_6) {
    return nothing;
  }
  alt(other) {
    return other;
  }
  altLazy(other) {
    return other();
  }
  chain(_6) {
    return nothing;
  }
  chainNullable(_6) {
    return nothing;
  }
  join() {
    return nothing;
  }
  reduce(_6, initialValue) {
    return initialValue;
  }
  extend(_6) {
    return nothing;
  }
  unsafeCoerce() {
    throw new Error("Maybe#unsafeCoerce was ran on a Nothing");
  }
  caseOf(patterns) {
    return "_" in patterns ? patterns._() : patterns.Nothing();
  }
  orDefault(defaultValue) {
    return defaultValue;
  }
  orDefaultLazy(getDefaultValue) {
    return getDefaultValue();
  }
  toList() {
    return [];
  }
  mapOrDefault(_6, defaultValue) {
    return defaultValue;
  }
  extract() {
    return void 0;
  }
  extractNullable() {
    return null;
  }
  toEither(left2) {
    return left(left2);
  }
  ifJust(_6) {
    return this;
  }
  ifNothing(effect) {
    return effect(), this;
  }
  filter(_6) {
    return nothing;
  }
};
Nothing.prototype.constructor = Maybe;
var just = (value) => new Just(value);
var nothing = new Nothing();

// node_modules/purify-ts/esm/Either.js
var Either = {
  of(value) {
    return right(value);
  },
  lefts(list) {
    let result = [];
    for (const x8 of list) {
      if (x8.isLeft()) {
        result.push(x8.extract());
      }
    }
    return result;
  },
  rights(list) {
    let result = [];
    for (const x8 of list) {
      if (x8.isRight()) {
        result.push(x8.extract());
      }
    }
    return result;
  },
  encase(throwsF) {
    try {
      return right(throwsF());
    } catch (e18) {
      return left(e18);
    }
  },
  sequence(eithers) {
    let res = [];
    for (const e18 of eithers) {
      if (e18.isLeft()) {
        return e18;
      }
      res.push(e18.extract());
    }
    return right(res);
  },
  isEither(x8) {
    return x8 instanceof Left || x8 instanceof Right;
  },
  "fantasy-land/of"(value) {
    return Either.of(value);
  }
};
var Right = class {
  constructor(__value) {
    this.__value = __value;
    this._ = "R";
    this["fantasy-land/bimap"] = this.bimap;
    this["fantasy-land/map"] = this.map;
    this["fantasy-land/ap"] = this.ap;
    this["fantasy-land/equals"] = this.equals;
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/alt"] = this.alt;
    this["fantasy-land/reduce"] = this.reduce;
    this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return false;
  }
  isRight() {
    return true;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Right(${this.__value})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(_6, g23) {
    return right(g23(this.__value));
  }
  map(f9) {
    return right(f9(this.__value));
  }
  mapLeft(_6) {
    return this;
  }
  ap(other) {
    return other.isRight() ? this.map(other.extract()) : other;
  }
  equals(other) {
    return other.isRight() ? this.__value === other.extract() : false;
  }
  chain(f9) {
    return f9(this.__value);
  }
  chainLeft(_6) {
    return this;
  }
  join() {
    return this.__value;
  }
  alt(_6) {
    return this;
  }
  altLazy(_6) {
    return this;
  }
  reduce(reducer, initialValue) {
    return reducer(initialValue, this.__value);
  }
  extend(f9) {
    return right(f9(this));
  }
  unsafeCoerce() {
    return this.__value;
  }
  caseOf(patterns) {
    return "_" in patterns ? patterns._() : patterns.Right(this.__value);
  }
  leftOrDefault(defaultValue) {
    return defaultValue;
  }
  orDefault(_6) {
    return this.__value;
  }
  orDefaultLazy(_6) {
    return this.__value;
  }
  leftOrDefaultLazy(getDefaultValue) {
    return getDefaultValue();
  }
  ifLeft(_6) {
    return this;
  }
  ifRight(effect) {
    return effect(this.__value), this;
  }
  toMaybe() {
    return just(this.__value);
  }
  leftToMaybe() {
    return nothing;
  }
  extract() {
    return this.__value;
  }
  swap() {
    return left(this.__value);
  }
};
Right.prototype.constructor = Either;
var Left = class {
  constructor(__value) {
    this.__value = __value;
    this._ = "L";
    this["fantasy-land/bimap"] = this.bimap;
    this["fantasy-land/map"] = this.map;
    this["fantasy-land/ap"] = this.ap;
    this["fantasy-land/equals"] = this.equals;
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/alt"] = this.alt;
    this["fantasy-land/reduce"] = this.reduce;
    this["fantasy-land/extend"] = this.extend;
  }
  isLeft() {
    return true;
  }
  isRight() {
    return false;
  }
  toJSON() {
    return this.__value;
  }
  inspect() {
    return `Left(${JSON.stringify(this.__value)})`;
  }
  toString() {
    return this.inspect();
  }
  bimap(f9, _6) {
    return left(f9(this.__value));
  }
  map(_6) {
    return this;
  }
  mapLeft(f9) {
    return left(f9(this.__value));
  }
  ap(other) {
    return other.isLeft() ? other : this;
  }
  equals(other) {
    return other.isLeft() ? other.extract() === this.__value : false;
  }
  chain(_6) {
    return this;
  }
  chainLeft(f9) {
    return f9(this.__value);
  }
  join() {
    return this;
  }
  alt(other) {
    return other;
  }
  altLazy(other) {
    return other();
  }
  reduce(_6, initialValue) {
    return initialValue;
  }
  extend(_6) {
    return this;
  }
  unsafeCoerce() {
    if (this.__value instanceof Error) {
      throw this.__value;
    }
    throw new Error("Either#unsafeCoerce was ran on a Left");
  }
  caseOf(patterns) {
    return "_" in patterns ? patterns._() : patterns.Left(this.__value);
  }
  leftOrDefault(_6) {
    return this.__value;
  }
  orDefault(defaultValue) {
    return defaultValue;
  }
  orDefaultLazy(getDefaultValue) {
    return getDefaultValue();
  }
  leftOrDefaultLazy(_6) {
    return this.__value;
  }
  ifLeft(effect) {
    return effect(this.__value), this;
  }
  ifRight(_6) {
    return this;
  }
  toMaybe() {
    return nothing;
  }
  leftToMaybe() {
    return just(this.__value);
  }
  extract() {
    return this.__value;
  }
  swap() {
    return right(this.__value);
  }
};
Left.prototype.constructor = Either;
var left = (value) => new Left(value);
var right = (value) => new Right(value);

// node_modules/purify-ts/esm/Function.js
var identity = (x8) => x8;

// node_modules/purify-ts/esm/NonEmptyList.js
var NonEmptyListConstructor = (list) => list;
var NonEmptyList = Object.assign(NonEmptyListConstructor, {
  fromArray: (source) => NonEmptyList.isNonEmpty(source) ? just(source) : nothing,
  unsafeCoerce: (source) => {
    if (NonEmptyList.isNonEmpty(source)) {
      return source;
    }
    throw new Error("NonEmptyList#unsafeCoerce was ran on an empty array");
  },
  fromTuple: (source) => NonEmptyList(source.toArray()),
  head: (list) => list[0],
  last: (list) => list[list.length - 1],
  isNonEmpty: (list) => list.length > 0,
  tail: (list) => list.slice(1)
});

// node_modules/purify-ts/esm/Codec.js
var serializeValue = (_6, value) => {
  return typeof value === "bigint" ? value.toString() : value;
};
var isObject = (obj) => typeof obj === "object" && obj !== null && !Array.isArray(obj);
var reportError = (expectedType, input) => {
  let receivedString = "";
  switch (typeof input) {
    case "undefined":
      receivedString = "undefined";
      break;
    case "object":
      receivedString = input === null ? "null" : Array.isArray(input) ? "an array with value " + JSON.stringify(input, serializeValue) : "an object with value " + JSON.stringify(input, serializeValue);
      break;
    case "boolean":
      receivedString = "a boolean";
      break;
    case "symbol":
      receivedString = "a symbol";
      break;
    case "function":
      receivedString = "a function";
      break;
    case "bigint":
      receivedString = `a bigint with value ${input.toString()}`;
  }
  receivedString = receivedString || `a ${typeof input} with value ${JSON.stringify(input, serializeValue)}`;
  return `Expected ${expectedType}, but received ${receivedString}`;
};
var removeOneOfWithSingleElement = (schema) => {
  var _a7;
  const schemaKeys = Object.keys(schema);
  if (schemaKeys.length === 1 && ((_a7 = schema.oneOf) == null ? void 0 : _a7.length) === 1 && typeof schema.oneOf[0] === "object") {
    Object.assign(schema, schema.oneOf[0]);
    delete schema.oneOf;
  }
  return schema;
};
var flattenNestedOneOf = (schema) => {
  if (Array.isArray(schema.oneOf)) {
    for (let i23 = 0; i23 < schema.oneOf.length; i23++) {
      const e18 = schema.oneOf[i23];
      if (typeof e18 === "object" && e18.oneOf) {
        schema.oneOf.splice(i23, 1);
        schema.oneOf.push(...e18.oneOf);
        return optimizeSchema(schema);
      }
    }
  }
  return schema;
};
var optimizeSchema = (schema) => {
  flattenNestedOneOf(schema);
  removeOneOfWithSingleElement(schema);
  return schema;
};
var Codec = {
  /** Creates a codec for any JSON object */
  interface(properties) {
    const keys = Object.keys(properties);
    const decode = (input) => {
      if (!isObject(input)) {
        return left(reportError("an object", input));
      }
      const result = {};
      for (const key of keys) {
        if (!input.hasOwnProperty(key) && !properties[key]._isOptional) {
          return left(`Problem with property "${key}": it does not exist in received object ${JSON.stringify(input, serializeValue)}`);
        }
        const decodedProperty = properties[key].decode(input[key]);
        if (decodedProperty.isLeft()) {
          return left(`Problem with the value of property "${key}": ${decodedProperty.extract()}`);
        }
        const value = decodedProperty.extract();
        if (value !== void 0) {
          result[key] = value;
        }
      }
      return right(result);
    };
    const encode3 = (input) => {
      const result = {};
      for (const key of keys) {
        result[key] = properties[key].encode(input[key]);
      }
      return result;
    };
    return {
      decode,
      encode: encode3,
      unsafeDecode: (input) => decode(input).mapLeft(Error).unsafeCoerce(),
      schema: () => keys.reduce((acc, key) => {
        const isOptional = properties[key]._isOptional;
        if (!isOptional) {
          acc.required.push(key);
        }
        acc.properties[key] = optimizeSchema(properties[key].schema());
        return acc;
      }, {
        type: "object",
        properties: {},
        required: []
      })
    };
  },
  /** Creates a codec for any type, you can add your own deserialization/validation logic in the decode argument */
  custom({ decode, encode: encode3, schema }) {
    return {
      decode,
      encode: encode3,
      unsafeDecode: (input) => decode(input).mapLeft(Error).unsafeCoerce(),
      schema: schema ?? (() => ({}))
    };
  }
};
var string = Codec.custom({
  decode: (input) => typeof input === "string" ? right(input) : left(reportError("a string", input)),
  encode: identity,
  schema: () => ({ type: "string" })
});
var number = Codec.custom({
  decode: (input) => typeof input === "number" ? right(input) : left(reportError("a number", input)),
  encode: identity,
  schema: () => ({ type: "number" })
});
var nullType = Codec.custom({
  decode: (input) => input === null ? right(input) : left(reportError("a null", input)),
  encode: identity,
  schema: () => ({ type: "null" })
});
var undefinedType = Codec.custom({
  decode: (input) => input === void 0 ? right(input) : left(reportError("an undefined", input)),
  encode: identity
});
var boolean = Codec.custom({
  decode: (input) => typeof input === "boolean" ? right(input) : left(reportError("a boolean", input)),
  encode: identity,
  schema: () => ({ type: "boolean" })
});
var unknown = Codec.custom({
  decode: right,
  encode: identity,
  schema: () => ({})
});
var numberString = Codec.custom({
  decode: (input) => string.decode(input).chain((x8) => isFinite(+x8) ? right(x8) : left(reportError("a number", input))),
  encode: identity,
  schema: number.schema
});
var date = Codec.custom({
  decode: (input) => string.decode(input).mapLeft((err) => `Problem with date string: ${err}`).chain((x8) => Number.isNaN(Date.parse(x8)) ? left("Expected a valid date string, but received a string that cannot be parsed") : right(new Date(x8))),
  encode: (input) => input.toISOString(),
  schema: () => ({ type: "string", format: "date-time" })
});

// node_modules/purify-ts/esm/Tuple.js
var TupleImpl = class {
  constructor(first2, second) {
    this.first = first2;
    this.second = second;
    this.length = 2;
    this["fantasy-land/equals"] = this.equals;
    this["fantasy-land/bimap"] = this.bimap;
    this["fantasy-land/map"] = this.map;
    this["fantasy-land/reduce"] = this.reduce;
    this["fantasy-land/ap"] = this.ap;
    this[0] = first2;
    this[1] = second;
  }
  *[Symbol.iterator]() {
    yield this.first;
    yield this.second;
  }
  toJSON() {
    return this.toArray();
  }
  inspect() {
    return `Tuple(${JSON.stringify(this.first)}, ${JSON.stringify(this.second)})`;
  }
  toString() {
    return this.inspect();
  }
  fst() {
    return this.first;
  }
  snd() {
    return this.second;
  }
  equals(other) {
    return this.first === other.fst() && this.second === other.snd();
  }
  bimap(f9, g23) {
    return Tuple(f9(this.first), g23(this.second));
  }
  mapFirst(f9) {
    return Tuple(f9(this.first), this.second);
  }
  map(f9) {
    return Tuple(this.first, f9(this.second));
  }
  reduce(reducer, initialValue) {
    return reducer(initialValue, this.second);
  }
  toArray() {
    return [this.first, this.second];
  }
  swap() {
    return Tuple(this.second, this.first);
  }
  ap(f9) {
    return Tuple(this.first, f9.snd()(this.second));
  }
  every(pred) {
    return pred(this.first) && pred(this.second);
  }
  some(pred) {
    return pred(this.first) || pred(this.second);
  }
};
var Tuple = Object.assign((fst, snd) => new TupleImpl(fst, snd), {
  fromArray: ([fst, snd]) => {
    return Tuple(fst, snd);
  },
  fanout: (...args) => {
    const [f9, g23, value] = args;
    switch (args.length) {
      case 3:
        return Tuple(f9(value), g23(value));
      case 2:
        return (value2) => Tuple.fanout(f9, g23, value2);
      default:
        return (g24) => (value2) => Tuple.fanout(f9, g24, value2);
    }
  }
});
TupleImpl.prototype.constructor = Tuple;

// node_modules/purify-ts/esm/EitherAsync.js
var _a;
var helpers = {
  liftEither(either) {
    if (either.isRight()) {
      return Promise.resolve(either.extract());
    }
    throw either.extract();
  },
  fromPromise(promise) {
    return promise.then(helpers.liftEither);
  },
  throwE(error) {
    throw error;
  }
};
var EitherAsyncImpl = class {
  constructor(runPromise) {
    this.runPromise = runPromise;
    this[_a] = "EitherAsync";
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/alt"] = this.alt;
    this.then = (onfulfilled, onrejected) => {
      return this.run().then(onfulfilled, onrejected);
    };
  }
  leftOrDefault(defaultValue) {
    return this.run().then((x8) => x8.leftOrDefault(defaultValue));
  }
  orDefault(defaultValue) {
    return this.run().then((x8) => x8.orDefault(defaultValue));
  }
  join() {
    return EitherAsync(async (helpers3) => {
      const either = await this;
      if (either.isRight()) {
        const nestedEither = await either.extract();
        return helpers3.liftEither(nestedEither);
      }
      return helpers3.liftEither(either);
    });
  }
  ap(eitherF) {
    return EitherAsync(async (helpers3) => {
      const otherValue = await eitherF;
      if (otherValue.isRight()) {
        const thisValue = await this.run();
        if (thisValue.isRight()) {
          return otherValue.extract()(thisValue.extract());
        } else {
          return helpers3.liftEither(thisValue);
        }
      }
      return helpers3.liftEither(otherValue);
    });
  }
  alt(other) {
    return EitherAsync(async (helpers3) => {
      const thisValue = await this.run();
      if (thisValue.isRight()) {
        return thisValue.extract();
      } else {
        const otherValue = await other;
        return helpers3.liftEither(otherValue);
      }
    });
  }
  extend(f9) {
    return EitherAsync(async (helpers3) => {
      const either = await this.run();
      if (either.isRight()) {
        const v22 = EitherAsync.liftEither(either);
        return helpers3.liftEither(right(f9(v22)));
      }
      return helpers3.liftEither(either);
    });
  }
  async run() {
    try {
      return right(await this.runPromise(helpers));
    } catch (e18) {
      return left(e18);
    }
  }
  bimap(f9, g23) {
    return EitherAsync(async (helpers3) => {
      const either = await this.run();
      try {
        return await helpers3.liftEither(either.bimap(f9, g23));
      } catch (e18) {
        throw await e18;
      }
    });
  }
  map(f9) {
    return EitherAsync((helpers3) => this.runPromise(helpers3).then(f9));
  }
  mapLeft(f9) {
    return EitherAsync(async (helpers3) => {
      try {
        return await this.runPromise(helpers3);
      } catch (e18) {
        throw await f9(e18);
      }
    });
  }
  chain(f9) {
    return EitherAsync(async (helpers3) => {
      const value = await this.runPromise(helpers3);
      return helpers3.fromPromise(f9(value));
    });
  }
  chainLeft(f9) {
    return EitherAsync(async (helpers3) => {
      try {
        return await this.runPromise(helpers3);
      } catch (e18) {
        return helpers3.fromPromise(f9(e18));
      }
    });
  }
  toMaybeAsync() {
    return MaybeAsync(async ({ liftMaybe }) => {
      const either = await this.run();
      return liftMaybe(either.toMaybe());
    });
  }
  swap() {
    return EitherAsync(async (helpers3) => {
      const either = await this.run();
      if (either.isRight())
        helpers3.throwE(either.extract());
      return helpers3.liftEither(right(either.extract()));
    });
  }
  ifLeft(effect) {
    return EitherAsync(async (helpers3) => {
      const either = await this.run();
      either.ifLeft(effect);
      return helpers3.liftEither(either);
    });
  }
  ifRight(effect) {
    return EitherAsync(async (helpers3) => {
      const either = await this.run();
      either.ifRight(effect);
      return helpers3.liftEither(either);
    });
  }
  void() {
    return this.map((_6) => {
    });
  }
  caseOf(patterns) {
    return this.run().then((x8) => x8.caseOf(patterns));
  }
  finally(effect) {
    return EitherAsync(({ fromPromise: fromPromise3 }) => fromPromise3(this.run().finally(effect)));
  }
};
_a = Symbol.toStringTag;
var EitherAsync = Object.assign((runPromise) => new EitherAsyncImpl(runPromise), {
  fromPromise: (f9) => EitherAsync(({ fromPromise: fP }) => fP(f9())),
  liftEither: (either) => EitherAsync(({ liftEither }) => liftEither(either)),
  lefts: (list) => Promise.all(list.map((x8) => x8.run())).then(Either.lefts),
  rights: (list) => Promise.all(list.map((x8) => x8.run())).then(Either.rights),
  sequence: (eas) => EitherAsync(async (helpers3) => {
    let res = [];
    for await (const e18 of eas) {
      if (e18.isLeft()) {
        return helpers3.liftEither(e18);
      }
      res.push(e18.extract());
    }
    return helpers3.liftEither(right(res));
  }),
  all: (eas) => EitherAsync.fromPromise(async () => Promise.all(eas).then(Either.sequence))
});
EitherAsyncImpl.prototype.constructor = EitherAsync;

// node_modules/purify-ts/esm/MaybeAsync.js
var _a2;
var helpers2 = {
  liftMaybe(maybe) {
    if (maybe.isJust()) {
      return Promise.resolve(maybe.extract());
    }
    throw nothing;
  },
  fromPromise(promise) {
    return promise.then(helpers2.liftMaybe);
  }
};
var MaybeAsyncImpl = class {
  constructor(runPromise) {
    this.runPromise = runPromise;
    this[_a2] = "MaybeAsync";
    this["fantasy-land/chain"] = this.chain;
    this["fantasy-land/filter"] = this.filter;
    this["fantasy-land/alt"] = this.alt;
  }
  orDefault(defaultValue) {
    return this.run().then((x8) => x8.orDefault(defaultValue));
  }
  join() {
    return MaybeAsync(async (helpers3) => {
      const maybe = await this.run();
      if (maybe.isJust()) {
        const nestedMaybe = await maybe.extract();
        return helpers3.liftMaybe(nestedMaybe);
      }
      return helpers3.liftMaybe(nothing);
    });
  }
  ap(maybeF) {
    return MaybeAsync(async (helpers3) => {
      const otherValue = await maybeF;
      if (otherValue.isJust()) {
        const thisValue = await this.run();
        if (thisValue.isJust()) {
          return otherValue.extract()(thisValue.extract());
        } else {
          return helpers3.liftMaybe(nothing);
        }
      }
      return helpers3.liftMaybe(nothing);
    });
  }
  alt(other) {
    return MaybeAsync(async (helpers3) => {
      const thisValue = await this.run();
      if (thisValue.isJust()) {
        return thisValue.extract();
      } else {
        const otherValue = await other;
        return helpers3.liftMaybe(otherValue);
      }
    });
  }
  extend(f9) {
    return MaybeAsync(async (helpers3) => {
      const maybe = await this.run();
      if (maybe.isJust()) {
        const v22 = MaybeAsync.liftMaybe(maybe);
        return helpers3.liftMaybe(just(f9(v22)));
      }
      return helpers3.liftMaybe(nothing);
    });
  }
  filter(pred) {
    return MaybeAsync(async (helpers3) => {
      const value = await this.run();
      return helpers3.liftMaybe(value.filter(pred));
    });
  }
  async run() {
    try {
      return just(await this.runPromise(helpers2));
    } catch {
      return nothing;
    }
  }
  map(f9) {
    return MaybeAsync((helpers3) => this.runPromise(helpers3).then(f9));
  }
  chain(f9) {
    return MaybeAsync(async (helpers3) => {
      const value = await this.runPromise(helpers3);
      return helpers3.fromPromise(f9(value));
    });
  }
  toEitherAsync(error) {
    return EitherAsync(async ({ liftEither }) => {
      const maybe = await this.run();
      return liftEither(maybe.toEither(error));
    });
  }
  ifJust(effect) {
    return MaybeAsync(async (helpers3) => {
      const maybe = await this.run();
      maybe.ifJust(effect);
      return helpers3.liftMaybe(maybe);
    });
  }
  ifNothing(effect) {
    return MaybeAsync(async (helpers3) => {
      const maybe = await this.run();
      maybe.ifNothing(effect);
      return helpers3.liftMaybe(maybe);
    });
  }
  void() {
    return this.map((_6) => {
    });
  }
  caseOf(patterns) {
    return this.run().then((x8) => x8.caseOf(patterns));
  }
  finally(effect) {
    return MaybeAsync(({ fromPromise: fromPromise3 }) => fromPromise3(this.run().finally(effect)));
  }
  then(onfulfilled, onrejected) {
    return this.run().then(onfulfilled, onrejected);
  }
};
_a2 = Symbol.toStringTag;
var MaybeAsync = Object.assign((runPromise) => new MaybeAsyncImpl(runPromise), {
  catMaybes: (list) => Promise.all(list).then(Maybe.catMaybes),
  fromPromise: (f9) => MaybeAsync(({ fromPromise: fP }) => fP(f9())),
  liftMaybe: (maybe) => MaybeAsync(({ liftMaybe }) => liftMaybe(maybe))
});
MaybeAsyncImpl.prototype.constructor = MaybeAsync;

// node_modules/xstate/dev/dist/xstate-dev.development.esm.js
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  {
    console.warn("XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues");
  }
}
function getDevTools() {
  const w8 = getGlobal();
  if (w8.__xstate__) {
    return w8.__xstate__;
  }
  return void 0;
}
var devToolsAdapter = (service) => {
  if (typeof window === "undefined") {
    return;
  }
  const devTools = getDevTools();
  if (devTools) {
    devTools.register(service);
  }
};

// node_modules/xstate/dist/raise-1db27a82.development.esm.js
var Mailbox = class {
  constructor(_process) {
    this._process = _process;
    this._active = false;
    this._current = null;
    this._last = null;
  }
  start() {
    this._active = true;
    this.flush();
  }
  clear() {
    if (this._current) {
      this._current.next = null;
      this._last = this._current;
    }
  }
  enqueue(event) {
    const enqueued = {
      value: event,
      next: null
    };
    if (this._current) {
      this._last.next = enqueued;
      this._last = enqueued;
      return;
    }
    this._current = enqueued;
    this._last = enqueued;
    if (this._active) {
      this.flush();
    }
  }
  flush() {
    while (this._current) {
      const consumed = this._current;
      this._process(consumed.value);
      this._current = consumed.next;
    }
    this._last = null;
  }
};
var STATE_DELIMITER = ".";
var TARGETLESS_KEY = "";
var NULL_EVENT = "";
var STATE_IDENTIFIER = "#";
var WILDCARD = "*";
var XSTATE_INIT = "xstate.init";
var XSTATE_STOP = "xstate.stop";
function createAfterEvent(delayRef, id) {
  return {
    type: `xstate.after.${delayRef}.${id}`
  };
}
function createDoneStateEvent(id, output) {
  return {
    type: `xstate.done.state.${id}`,
    output
  };
}
function createDoneActorEvent(invokeId, output) {
  return {
    type: `xstate.done.actor.${invokeId}`,
    output,
    actorId: invokeId
  };
}
function createErrorActorEvent(id, error) {
  return {
    type: `xstate.error.actor.${id}`,
    error,
    actorId: id
  };
}
function createInitEvent(input) {
  return {
    type: XSTATE_INIT,
    input
  };
}
function reportUnhandledError(err) {
  setTimeout(() => {
    throw err;
  });
}
var symbolObservable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
function matchesState(parentStateId, childStateId) {
  const parentStateValue = toStateValue(parentStateId);
  const childStateValue = toStateValue(childStateId);
  if (typeof childStateValue === "string") {
    if (typeof parentStateValue === "string") {
      return childStateValue === parentStateValue;
    }
    return false;
  }
  if (typeof parentStateValue === "string") {
    return parentStateValue in childStateValue;
  }
  return Object.keys(parentStateValue).every((key) => {
    if (!(key in childStateValue)) {
      return false;
    }
    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}
function toStatePath(stateId) {
  if (isArray(stateId)) {
    return stateId;
  }
  const result = [];
  let segment = "";
  for (let i23 = 0; i23 < stateId.length; i23++) {
    const char = stateId.charCodeAt(i23);
    switch (char) {
      case 92:
        segment += stateId[i23 + 1];
        i23++;
        continue;
      case 46:
        result.push(segment);
        segment = "";
        continue;
    }
    segment += stateId[i23];
  }
  result.push(segment);
  return result;
}
function toStateValue(stateValue) {
  if (isMachineSnapshot(stateValue)) {
    return stateValue.value;
  }
  if (typeof stateValue !== "string") {
    return stateValue;
  }
  const statePath = toStatePath(stateValue);
  return pathToStateValue(statePath);
}
function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }
  const value = {};
  let marker = value;
  for (let i23 = 0; i23 < statePath.length - 1; i23++) {
    if (i23 === statePath.length - 2) {
      marker[statePath[i23]] = statePath[i23 + 1];
    } else {
      const previous = marker;
      marker = {};
      previous[statePath[i23]] = marker;
    }
  }
  return value;
}
function mapValues(collection, iteratee) {
  const result = {};
  const collectionKeys = Object.keys(collection);
  for (let i23 = 0; i23 < collectionKeys.length; i23++) {
    const key = collectionKeys[i23];
    result[key] = iteratee(collection[key], key, collection, i23);
  }
  return result;
}
function toArrayStrict(value) {
  if (isArray(value)) {
    return value;
  }
  return [value];
}
function toArray(value) {
  if (value === void 0) {
    return [];
  }
  return toArrayStrict(value);
}
function resolveOutput(mapper, context2, event, self2) {
  if (typeof mapper === "function") {
    return mapper({
      context: context2,
      event,
      self: self2
    });
  }
  if (!!mapper && typeof mapper === "object" && Object.values(mapper).some((val) => typeof val === "function")) {
    console.warn(`Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.
Found object containing properties whose values are possibly mapping functions: ${Object.entries(mapper).filter(([, value]) => typeof value === "function").map(([key, value]) => `
 - ${key}: ${value.toString().replace(/\n\s*/g, "")}`).join("")}`);
  }
  return mapper;
}
function isArray(value) {
  return Array.isArray(value);
}
function isErrorActorEvent(event) {
  return event.type.startsWith("xstate.error.actor");
}
function toTransitionConfigArray(configLike) {
  return toArrayStrict(configLike).map((transitionLike) => {
    if (typeof transitionLike === "undefined" || typeof transitionLike === "string") {
      return {
        target: transitionLike
      };
    }
    return transitionLike;
  });
}
function normalizeTarget(target) {
  if (target === void 0 || target === TARGETLESS_KEY) {
    return void 0;
  }
  return toArray(target);
}
function toObserver(nextHandler, errorHandler, completionHandler) {
  var _a7, _b4, _c3;
  const isObserver2 = typeof nextHandler === "object";
  const self2 = isObserver2 ? nextHandler : void 0;
  return {
    next: (_a7 = isObserver2 ? nextHandler.next : nextHandler) == null ? void 0 : _a7.bind(self2),
    error: (_b4 = isObserver2 ? nextHandler.error : errorHandler) == null ? void 0 : _b4.bind(self2),
    complete: (_c3 = isObserver2 ? nextHandler.complete : completionHandler) == null ? void 0 : _c3.bind(self2)
  };
}
function createInvokeId(stateNodeId, index) {
  return `${index}.${stateNodeId}`;
}
function resolveReferencedActor(machine, src) {
  const match = src.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!match) {
    return machine.implementations.actors[src];
  }
  const [, indexStr, nodeId] = match;
  const node = machine.getStateNodeById(nodeId);
  const invokeConfig = node.config.invoke;
  return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;
}
function createScheduledEventId(actorRef, id) {
  return `${actorRef.sessionId}.${id}`;
}
var idCounter = 0;
function createSystem(rootActor, options) {
  const children = /* @__PURE__ */ new Map();
  const keyedActors = /* @__PURE__ */ new Map();
  const reverseKeyedActors = /* @__PURE__ */ new WeakMap();
  const inspectionObservers = /* @__PURE__ */ new Set();
  const timerMap = {};
  const {
    clock,
    logger
  } = options;
  const scheduler = {
    schedule: (source, target, event, delay2, id = Math.random().toString(36).slice(2)) => {
      const scheduledEvent = {
        source,
        target,
        event,
        delay: delay2,
        id,
        startedAt: Date.now()
      };
      const scheduledEventId = createScheduledEventId(source, id);
      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;
      const timeout2 = clock.setTimeout(() => {
        delete timerMap[scheduledEventId];
        delete system._snapshot._scheduledEvents[scheduledEventId];
        system._relay(source, target, event);
      }, delay2);
      timerMap[scheduledEventId] = timeout2;
    },
    cancel: (source, id) => {
      const scheduledEventId = createScheduledEventId(source, id);
      const timeout2 = timerMap[scheduledEventId];
      delete timerMap[scheduledEventId];
      delete system._snapshot._scheduledEvents[scheduledEventId];
      if (timeout2 !== void 0) {
        clock.clearTimeout(timeout2);
      }
    },
    cancelAll: (actorRef) => {
      for (const scheduledEventId in system._snapshot._scheduledEvents) {
        const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];
        if (scheduledEvent.source === actorRef) {
          scheduler.cancel(actorRef, scheduledEvent.id);
        }
      }
    }
  };
  const sendInspectionEvent = (event) => {
    if (!inspectionObservers.size) {
      return;
    }
    const resolvedInspectionEvent = {
      ...event,
      rootId: rootActor.sessionId
    };
    inspectionObservers.forEach((observer) => {
      var _a7;
      return (_a7 = observer.next) == null ? void 0 : _a7.call(observer, resolvedInspectionEvent);
    });
  };
  const system = {
    _snapshot: {
      _scheduledEvents: ((options == null ? void 0 : options.snapshot) && options.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${idCounter++}`,
    _register: (sessionId, actorRef) => {
      children.set(sessionId, actorRef);
      return sessionId;
    },
    _unregister: (actorRef) => {
      children.delete(actorRef.sessionId);
      const systemId = reverseKeyedActors.get(actorRef);
      if (systemId !== void 0) {
        keyedActors.delete(systemId);
        reverseKeyedActors.delete(actorRef);
      }
    },
    get: (systemId) => {
      return keyedActors.get(systemId);
    },
    _set: (systemId, actorRef) => {
      const existing = keyedActors.get(systemId);
      if (existing && existing !== actorRef) {
        throw new Error(`Actor with system ID '${systemId}' already exists.`);
      }
      keyedActors.set(systemId, actorRef);
      reverseKeyedActors.set(actorRef, systemId);
    },
    inspect: (observerOrFn) => {
      const observer = toObserver(observerOrFn);
      inspectionObservers.add(observer);
      return {
        unsubscribe() {
          inspectionObservers.delete(observer);
        }
      };
    },
    _sendInspectionEvent: sendInspectionEvent,
    _relay: (source, target, event) => {
      system._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: source,
        actorRef: target,
        event
      });
      target._send(event);
    },
    scheduler,
    getSnapshot: () => {
      return {
        _scheduledEvents: {
          ...system._snapshot._scheduledEvents
        }
      };
    },
    start: () => {
      const scheduledEvents = system._snapshot._scheduledEvents;
      system._snapshot._scheduledEvents = {};
      for (const scheduledId in scheduledEvents) {
        const {
          source,
          target,
          event,
          delay: delay2,
          id
        } = scheduledEvents[scheduledId];
        scheduler.schedule(source, target, event, delay2, id);
      }
    },
    _clock: clock,
    _logger: logger
  };
  return system;
}
var executingCustomAction = false;
var $$ACTOR_TYPE = 1;
var ProcessingStatus = function(ProcessingStatus2) {
  ProcessingStatus2[ProcessingStatus2["NotStarted"] = 0] = "NotStarted";
  ProcessingStatus2[ProcessingStatus2["Running"] = 1] = "Running";
  ProcessingStatus2[ProcessingStatus2["Stopped"] = 2] = "Stopped";
  return ProcessingStatus2;
}({});
var defaultOptions = {
  clock: {
    setTimeout: (fn, ms) => {
      return setTimeout(fn, ms);
    },
    clearTimeout: (id) => {
      return clearTimeout(id);
    }
  },
  logger: console.log.bind(console),
  devTools: false
};
var Actor = class {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(logic, options) {
    this.logic = logic;
    this._snapshot = void 0;
    this.clock = void 0;
    this.options = void 0;
    this.id = void 0;
    this.mailbox = new Mailbox(this._process.bind(this));
    this.observers = /* @__PURE__ */ new Set();
    this.eventListeners = /* @__PURE__ */ new Map();
    this.logger = void 0;
    this._processingStatus = ProcessingStatus.NotStarted;
    this._parent = void 0;
    this._syncSnapshot = void 0;
    this.ref = void 0;
    this._actorScope = void 0;
    this._systemId = void 0;
    this.sessionId = void 0;
    this.system = void 0;
    this._doneEvent = void 0;
    this.src = void 0;
    this._deferred = [];
    const resolvedOptions = {
      ...defaultOptions,
      ...options
    };
    const {
      clock,
      logger,
      parent,
      syncSnapshot,
      id,
      systemId,
      inspect
    } = resolvedOptions;
    this.system = parent ? parent.system : createSystem(this, {
      clock,
      logger
    });
    if (inspect && !parent) {
      this.system.inspect(toObserver(inspect));
    }
    this.sessionId = this.system._bookId();
    this.id = id ?? this.sessionId;
    this.logger = (options == null ? void 0 : options.logger) ?? this.system._logger;
    this.clock = (options == null ? void 0 : options.clock) ?? this.system._clock;
    this._parent = parent;
    this._syncSnapshot = syncSnapshot;
    this.options = resolvedOptions;
    this.src = resolvedOptions.src ?? logic;
    this.ref = this;
    this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (fn) => {
        this._deferred.push(fn);
      },
      system: this.system,
      stopChild: (child) => {
        if (child._parent !== this) {
          throw new Error(`Cannot stop child actor ${child.id} of ${this.id} because it is not a child`);
        }
        child._stop();
      },
      emit: (emittedEvent) => {
        const listeners = this.eventListeners.get(emittedEvent.type);
        const wildcardListener = this.eventListeners.get("*");
        if (!listeners && !wildcardListener) {
          return;
        }
        const allListeners = [...listeners ? listeners.values() : [], ...wildcardListener ? wildcardListener.values() : []];
        for (const handler of allListeners) {
          handler(emittedEvent);
        }
      },
      actionExecutor: (action) => {
        const exec = () => {
          this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: action.type,
              params: action.params
            }
          });
          if (!action.exec) {
            return;
          }
          const saveExecutingCustomAction = executingCustomAction;
          try {
            executingCustomAction = true;
            action.exec(action.info, action.params);
          } finally {
            executingCustomAction = saveExecutingCustomAction;
          }
        };
        if (this._processingStatus === ProcessingStatus.Running) {
          exec();
        } else {
          this._deferred.push(exec);
        }
      }
    };
    this.send = this.send.bind(this);
    this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    });
    if (systemId) {
      this._systemId = systemId;
      this.system._set(systemId, this);
    }
    this._initState((options == null ? void 0 : options.snapshot) ?? (options == null ? void 0 : options.state));
    if (systemId && this._snapshot.status !== "active") {
      this.system._unregister(this);
    }
  }
  _initState(persistedState) {
    var _a7;
    try {
      this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, (_a7 = this.options) == null ? void 0 : _a7.input);
    } catch (err) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: err
      };
    }
  }
  update(snapshot, event) {
    var _a7, _b4;
    this._snapshot = snapshot;
    let deferredFn;
    while (deferredFn = this._deferred.shift()) {
      try {
        deferredFn();
      } catch (err) {
        this._deferred.length = 0;
        this._snapshot = {
          ...snapshot,
          status: "error",
          error: err
        };
      }
    }
    switch (this._snapshot.status) {
      case "active":
        for (const observer of this.observers) {
          try {
            (_a7 = observer.next) == null ? void 0 : _a7.call(observer, snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        break;
      case "done":
        for (const observer of this.observers) {
          try {
            (_b4 = observer.next) == null ? void 0 : _b4.call(observer, snapshot);
          } catch (err) {
            reportUnhandledError(err);
          }
        }
        this._stopProcedure();
        this._complete();
        this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);
        if (this._parent) {
          this.system._relay(this, this._parent, this._doneEvent);
        }
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event,
      snapshot
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(nextListenerOrObserver, errorListener, completeListener) {
    var _a7;
    const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);
    if (this._processingStatus !== ProcessingStatus.Stopped) {
      this.observers.add(observer);
    } else {
      switch (this._snapshot.status) {
        case "done":
          try {
            (_a7 = observer.complete) == null ? void 0 : _a7.call(observer);
          } catch (err) {
            reportUnhandledError(err);
          }
          break;
        case "error": {
          const err = this._snapshot.error;
          if (!observer.error) {
            reportUnhandledError(err);
          } else {
            try {
              observer.error(err);
            } catch (err2) {
              reportUnhandledError(err2);
            }
          }
          break;
        }
      }
    }
    return {
      unsubscribe: () => {
        this.observers.delete(observer);
      }
    };
  }
  on(type, handler) {
    let listeners = this.eventListeners.get(type);
    if (!listeners) {
      listeners = /* @__PURE__ */ new Set();
      this.eventListeners.set(type, listeners);
    }
    const wrappedHandler = handler.bind(void 0);
    listeners.add(wrappedHandler);
    return {
      unsubscribe: () => {
        listeners.delete(wrappedHandler);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === ProcessingStatus.Running) {
      return this;
    }
    if (this._syncSnapshot) {
      this.subscribe({
        next: (snapshot) => {
          if (snapshot.status === "active") {
            this.system._relay(this, this._parent, {
              type: `xstate.snapshot.${this.id}`,
              snapshot
            });
          }
        },
        error: () => {
        }
      });
    }
    this.system._register(this.sessionId, this);
    if (this._systemId) {
      this.system._set(this._systemId, this);
    }
    this._processingStatus = ProcessingStatus.Running;
    const initEvent = createInitEvent(this.options.input);
    this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: initEvent
    });
    const status = this._snapshot.status;
    switch (status) {
      case "done":
        this.update(this._snapshot, initEvent);
        return this;
      case "error":
        this._error(this._snapshot.error);
        return this;
    }
    if (!this._parent) {
      this.system.start();
    }
    if (this.logic.start) {
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (err) {
        this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: err
        };
        this._error(err);
        return this;
      }
    }
    this.update(this._snapshot, initEvent);
    if (this.options.devTools) {
      this.attachDevTools();
    }
    this.mailbox.start();
    return this;
  }
  _process(event) {
    let nextState;
    let caughtError;
    try {
      nextState = this.logic.transition(this._snapshot, event, this._actorScope);
    } catch (err) {
      caughtError = {
        err
      };
    }
    if (caughtError) {
      const {
        err
      } = caughtError;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: err
      };
      this._error(err);
      return;
    }
    this.update(nextState, event);
    if (event.type === XSTATE_STOP) {
      this._stopProcedure();
      this._complete();
    }
  }
  _stop() {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      return this;
    }
    this.mailbox.clear();
    if (this._processingStatus === ProcessingStatus.NotStarted) {
      this._processingStatus = ProcessingStatus.Stopped;
      return this;
    }
    this.mailbox.enqueue({
      type: XSTATE_STOP
    });
    return this;
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent) {
      throw new Error("A non-root actor cannot be stopped directly.");
    }
    return this._stop();
  }
  _complete() {
    var _a7;
    for (const observer of this.observers) {
      try {
        (_a7 = observer.complete) == null ? void 0 : _a7.call(observer);
      } catch (err) {
        reportUnhandledError(err);
      }
    }
    this.observers.clear();
  }
  _reportError(err) {
    if (!this.observers.size) {
      if (!this._parent) {
        reportUnhandledError(err);
      }
      return;
    }
    let reportError2 = false;
    for (const observer of this.observers) {
      const errorListener = observer.error;
      reportError2 || (reportError2 = !errorListener);
      try {
        errorListener == null ? void 0 : errorListener(err);
      } catch (err2) {
        reportUnhandledError(err2);
      }
    }
    this.observers.clear();
    if (reportError2) {
      reportUnhandledError(err);
    }
  }
  _error(err) {
    this._stopProcedure();
    this._reportError(err);
    if (this._parent) {
      this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));
    }
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    if (this._processingStatus !== ProcessingStatus.Running) {
      return this;
    }
    this.system.scheduler.cancelAll(this);
    this.mailbox.clear();
    this.mailbox = new Mailbox(this._process.bind(this));
    this._processingStatus = ProcessingStatus.Stopped;
    this.system._unregister(this);
    return this;
  }
  /** @internal */
  _send(event) {
    if (this._processingStatus === ProcessingStatus.Stopped) {
      {
        const eventString = JSON.stringify(event);
        console.warn(`Event "${event.type}" was sent to stopped actor "${this.id} (${this.sessionId})". This actor has already reached its final state, and will not transition.
Event: ${eventString}`);
      }
      return;
    }
    this.mailbox.enqueue(event);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(event) {
    if (typeof event === "string") {
      throw new Error(`Only event objects may be sent to actors; use .send({ type: "${event}" }) instead`);
    }
    this.system._relay(void 0, this, event);
  }
  attachDevTools() {
    const {
      devTools
    } = this.options;
    if (devTools) {
      const resolvedDevToolsAdapter = typeof devTools === "function" ? devTools : devToolsAdapter;
      resolvedDevToolsAdapter(this);
    }
  }
  toJSON() {
    return {
      xstate$$type: $$ACTOR_TYPE,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(options) {
    return this.logic.getPersistedSnapshot(this._snapshot, options);
  }
  [symbolObservable]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    if (!this._snapshot) {
      throw new Error(`Snapshot can't be read while the actor initializes itself`);
    }
    return this._snapshot;
  }
};
function createActor(logic, ...[options]) {
  return new Actor(logic, options);
}
function resolveCancel(_6, snapshot, actionArgs, actionParams, {
  sendId
}) {
  const resolvedSendId = typeof sendId === "function" ? sendId(actionArgs, actionParams) : sendId;
  return [snapshot, {
    sendId: resolvedSendId
  }, void 0];
}
function executeCancel(actorScope, params) {
  actorScope.defer(() => {
    actorScope.system.scheduler.cancel(actorScope.self, params.sendId);
  });
}
function cancel(sendId) {
  function cancel2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  cancel2.type = "xstate.cancel";
  cancel2.sendId = sendId;
  cancel2.resolve = resolveCancel;
  cancel2.execute = executeCancel;
  return cancel2;
}
function resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, {
  id,
  systemId,
  src,
  input,
  syncSnapshot
}) {
  const logic = typeof src === "string" ? resolveReferencedActor(snapshot.machine, src) : src;
  const resolvedId = typeof id === "function" ? id(actionArgs) : id;
  let actorRef;
  let resolvedInput = void 0;
  if (logic) {
    resolvedInput = typeof input === "function" ? input({
      context: snapshot.context,
      event: actionArgs.event,
      self: actorScope.self
    }) : input;
    actorRef = createActor(logic, {
      id: resolvedId,
      src,
      parent: actorScope.self,
      syncSnapshot,
      systemId,
      input: resolvedInput
    });
  }
  if (!actorRef) {
    console.warn(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string
      `Actor type '${src}' not found in machine '${actorScope.id}'.`
    );
  }
  return [cloneMachineSnapshot(snapshot, {
    children: {
      ...snapshot.children,
      [resolvedId]: actorRef
    }
  }), {
    id,
    systemId,
    actorRef,
    src,
    input: resolvedInput
  }, void 0];
}
function executeSpawn(actorScope, {
  actorRef
}) {
  if (!actorRef) {
    return;
  }
  actorScope.defer(() => {
    if (actorRef._processingStatus === ProcessingStatus.Stopped) {
      return;
    }
    actorRef.start();
  });
}
function spawnChild(...[src, {
  id,
  systemId,
  input,
  syncSnapshot = false
} = {}]) {
  function spawnChild2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  spawnChild2.type = "xstate.spawnChild";
  spawnChild2.id = id;
  spawnChild2.systemId = systemId;
  spawnChild2.src = src;
  spawnChild2.input = input;
  spawnChild2.syncSnapshot = syncSnapshot;
  spawnChild2.resolve = resolveSpawn;
  spawnChild2.execute = executeSpawn;
  return spawnChild2;
}
function resolveStop(_6, snapshot, args, actionParams, {
  actorRef
}) {
  const actorRefOrString = typeof actorRef === "function" ? actorRef(args, actionParams) : actorRef;
  const resolvedActorRef = typeof actorRefOrString === "string" ? snapshot.children[actorRefOrString] : actorRefOrString;
  let children = snapshot.children;
  if (resolvedActorRef) {
    children = {
      ...children
    };
    delete children[resolvedActorRef.id];
  }
  return [cloneMachineSnapshot(snapshot, {
    children
  }), resolvedActorRef, void 0];
}
function executeStop(actorScope, actorRef) {
  if (!actorRef) {
    return;
  }
  actorScope.system._unregister(actorRef);
  if (actorRef._processingStatus !== ProcessingStatus.Running) {
    actorScope.stopChild(actorRef);
    return;
  }
  actorScope.defer(() => {
    actorScope.stopChild(actorRef);
  });
}
function stopChild(actorRef) {
  function stop2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  stop2.type = "xstate.stopChild";
  stop2.actorRef = actorRef;
  stop2.resolve = resolveStop;
  stop2.execute = executeStop;
  return stop2;
}
function evaluateGuard(guard, context2, event, snapshot) {
  const {
    machine
  } = snapshot;
  const isInline = typeof guard === "function";
  const resolved2 = isInline ? guard : machine.implementations.guards[typeof guard === "string" ? guard : guard.type];
  if (!isInline && !resolved2) {
    throw new Error(`Guard '${typeof guard === "string" ? guard : guard.type}' is not implemented.'.`);
  }
  if (typeof resolved2 !== "function") {
    return evaluateGuard(resolved2, context2, event, snapshot);
  }
  const guardArgs = {
    context: context2,
    event
  };
  const guardParams = isInline || typeof guard === "string" ? void 0 : "params" in guard ? typeof guard.params === "function" ? guard.params({
    context: context2,
    event
  }) : guard.params : void 0;
  if (!("check" in resolved2)) {
    return resolved2(guardArgs, guardParams);
  }
  const builtinGuard = resolved2;
  return builtinGuard.check(
    snapshot,
    guardArgs,
    resolved2
    // this holds all params
  );
}
var isAtomicStateNode = (stateNode) => stateNode.type === "atomic" || stateNode.type === "final";
function getChildren(stateNode) {
  return Object.values(stateNode.states).filter((sn) => sn.type !== "history");
}
function getProperAncestors(stateNode, toStateNode) {
  const ancestors = [];
  if (toStateNode === stateNode) {
    return ancestors;
  }
  let m15 = stateNode.parent;
  while (m15 && m15 !== toStateNode) {
    ancestors.push(m15);
    m15 = m15.parent;
  }
  return ancestors;
}
function getAllStateNodes(stateNodes) {
  const nodeSet = new Set(stateNodes);
  const adjList = getAdjList(nodeSet);
  for (const s25 of nodeSet) {
    if (s25.type === "compound" && (!adjList.get(s25) || !adjList.get(s25).length)) {
      getInitialStateNodesWithTheirAncestors(s25).forEach((sn) => nodeSet.add(sn));
    } else {
      if (s25.type === "parallel") {
        for (const child of getChildren(s25)) {
          if (child.type === "history") {
            continue;
          }
          if (!nodeSet.has(child)) {
            const initialStates = getInitialStateNodesWithTheirAncestors(child);
            for (const initialStateNode of initialStates) {
              nodeSet.add(initialStateNode);
            }
          }
        }
      }
    }
  }
  for (const s25 of nodeSet) {
    let m15 = s25.parent;
    while (m15) {
      nodeSet.add(m15);
      m15 = m15.parent;
    }
  }
  return nodeSet;
}
function getValueFromAdj(baseNode, adjList) {
  const childStateNodes = adjList.get(baseNode);
  if (!childStateNodes) {
    return {};
  }
  if (baseNode.type === "compound") {
    const childStateNode = childStateNodes[0];
    if (childStateNode) {
      if (isAtomicStateNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }
  const stateValue = {};
  for (const childStateNode of childStateNodes) {
    stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);
  }
  return stateValue;
}
function getAdjList(stateNodes) {
  const adjList = /* @__PURE__ */ new Map();
  for (const s25 of stateNodes) {
    if (!adjList.has(s25)) {
      adjList.set(s25, []);
    }
    if (s25.parent) {
      if (!adjList.has(s25.parent)) {
        adjList.set(s25.parent, []);
      }
      adjList.get(s25.parent).push(s25);
    }
  }
  return adjList;
}
function getStateValue(rootNode, stateNodes) {
  const config2 = getAllStateNodes(stateNodes);
  return getValueFromAdj(rootNode, getAdjList(config2));
}
function isInFinalState(stateNodeSet, stateNode) {
  if (stateNode.type === "compound") {
    return getChildren(stateNode).some((s25) => s25.type === "final" && stateNodeSet.has(s25));
  }
  if (stateNode.type === "parallel") {
    return getChildren(stateNode).every((sn) => isInFinalState(stateNodeSet, sn));
  }
  return stateNode.type === "final";
}
var isStateId = (str) => str[0] === STATE_IDENTIFIER;
function getCandidates(stateNode, receivedEventType) {
  const candidates = stateNode.transitions.get(receivedEventType) || [...stateNode.transitions.keys()].filter((eventDescriptor) => {
    if (eventDescriptor === WILDCARD) {
      return true;
    }
    if (!eventDescriptor.endsWith(".*")) {
      return false;
    }
    if (/.*\*.+/.test(eventDescriptor)) {
      console.warn(`Wildcards can only be the last token of an event descriptor (e.g., "event.*") or the entire event descriptor ("*"). Check the "${eventDescriptor}" event.`);
    }
    const partialEventTokens = eventDescriptor.split(".");
    const eventTokens = receivedEventType.split(".");
    for (let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++) {
      const partialEventToken = partialEventTokens[tokenIndex];
      const eventToken = eventTokens[tokenIndex];
      if (partialEventToken === "*") {
        const isLastToken = tokenIndex === partialEventTokens.length - 1;
        if (!isLastToken) {
          console.warn(`Infix wildcards in transition events are not allowed. Check the "${eventDescriptor}" transition.`);
        }
        return isLastToken;
      }
      if (partialEventToken !== eventToken) {
        return false;
      }
    }
    return true;
  }).sort((a24, b6) => b6.length - a24.length).flatMap((key) => stateNode.transitions.get(key));
  return candidates;
}
function getDelayedTransitions(stateNode) {
  const afterConfig = stateNode.config.after;
  if (!afterConfig) {
    return [];
  }
  const mutateEntryExit = (delay2) => {
    const afterEvent = createAfterEvent(delay2, stateNode.id);
    const eventType = afterEvent.type;
    stateNode.entry.push(raise(afterEvent, {
      id: eventType,
      delay: delay2
    }));
    stateNode.exit.push(cancel(eventType));
    return eventType;
  };
  const delayedTransitions = Object.keys(afterConfig).flatMap((delay2) => {
    const configTransition = afterConfig[delay2];
    const resolvedTransition = typeof configTransition === "string" ? {
      target: configTransition
    } : configTransition;
    const resolvedDelay = Number.isNaN(+delay2) ? delay2 : +delay2;
    const eventType = mutateEntryExit(resolvedDelay);
    return toArray(resolvedTransition).map((transition) => ({
      ...transition,
      event: eventType,
      delay: resolvedDelay
    }));
  });
  return delayedTransitions.map((delayedTransition) => {
    const {
      delay: delay2
    } = delayedTransition;
    return {
      ...formatTransition(stateNode, delayedTransition.event, delayedTransition),
      delay: delay2
    };
  });
}
function formatTransition(stateNode, descriptor, transitionConfig) {
  const normalizedTarget = normalizeTarget(transitionConfig.target);
  const reenter = transitionConfig.reenter ?? false;
  const target = resolveTarget(stateNode, normalizedTarget);
  if (transitionConfig.cond) {
    throw new Error(`State "${stateNode.id}" has declared \`cond\` for one of its transitions. This property has been renamed to \`guard\`. Please update your code.`);
  }
  const transition = {
    ...transitionConfig,
    actions: toArray(transitionConfig.actions),
    guard: transitionConfig.guard,
    target,
    source: stateNode,
    reenter,
    eventType: descriptor,
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: target ? target.map((t23) => `#${t23.id}`) : void 0
    })
  };
  return transition;
}
function formatTransitions(stateNode) {
  const transitions = /* @__PURE__ */ new Map();
  if (stateNode.config.on) {
    for (const descriptor of Object.keys(stateNode.config.on)) {
      if (descriptor === NULL_EVENT) {
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      }
      const transitionsConfig = stateNode.config.on[descriptor];
      transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t23) => formatTransition(stateNode, descriptor, t23)));
    }
  }
  if (stateNode.config.onDone) {
    const descriptor = `xstate.done.state.${stateNode.id}`;
    transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t23) => formatTransition(stateNode, descriptor, t23)));
  }
  for (const invokeDef of stateNode.invoke) {
    if (invokeDef.onDone) {
      const descriptor = `xstate.done.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t23) => formatTransition(stateNode, descriptor, t23)));
    }
    if (invokeDef.onError) {
      const descriptor = `xstate.error.actor.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t23) => formatTransition(stateNode, descriptor, t23)));
    }
    if (invokeDef.onSnapshot) {
      const descriptor = `xstate.snapshot.${invokeDef.id}`;
      transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t23) => formatTransition(stateNode, descriptor, t23)));
    }
  }
  for (const delayedTransition of stateNode.after) {
    let existing = transitions.get(delayedTransition.eventType);
    if (!existing) {
      existing = [];
      transitions.set(delayedTransition.eventType, existing);
    }
    existing.push(delayedTransition);
  }
  return transitions;
}
function formatInitialTransition(stateNode, _target) {
  const resolvedTarget = typeof _target === "string" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : void 0;
  if (!resolvedTarget && _target) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${_target}" not found on parent state node #${stateNode.id}`
    );
  }
  const transition = {
    source: stateNode,
    actions: !_target || typeof _target === "string" ? [] : toArray(_target.actions),
    eventType: null,
    reenter: false,
    target: resolvedTarget ? [resolvedTarget] : [],
    toJSON: () => ({
      ...transition,
      source: `#${stateNode.id}`,
      target: resolvedTarget ? [`#${resolvedTarget.id}`] : []
    })
  };
  return transition;
}
function resolveTarget(stateNode, targets) {
  if (targets === void 0) {
    return void 0;
  }
  return targets.map((target) => {
    if (typeof target !== "string") {
      return target;
    }
    if (isStateId(target)) {
      return stateNode.machine.getStateNodeById(target);
    }
    const isInternalTarget = target[0] === STATE_DELIMITER;
    if (isInternalTarget && !stateNode.parent) {
      return getStateNodeByPath(stateNode, target.slice(1));
    }
    const resolvedTarget = isInternalTarget ? stateNode.key + target : target;
    if (stateNode.parent) {
      try {
        const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);
        return targetStateNode;
      } catch (err) {
        throw new Error(`Invalid transition definition for state node '${stateNode.id}':
${err.message}`);
      }
    } else {
      throw new Error(`Invalid target: "${target}" is not a valid target from the root node. Did you mean ".${target}"?`);
    }
  });
}
function resolveHistoryDefaultTransition(stateNode) {
  const normalizedTarget = normalizeTarget(stateNode.config.target);
  if (!normalizedTarget) {
    return stateNode.parent.initial;
  }
  return {
    target: normalizedTarget.map((t23) => typeof t23 === "string" ? getStateNodeByPath(stateNode.parent, t23) : t23)
  };
}
function isHistoryNode(stateNode) {
  return stateNode.type === "history";
}
function getInitialStateNodesWithTheirAncestors(stateNode) {
  const states = getInitialStateNodes(stateNode);
  for (const initialState of states) {
    for (const ancestor of getProperAncestors(initialState, stateNode)) {
      states.add(ancestor);
    }
  }
  return states;
}
function getInitialStateNodes(stateNode) {
  const set = /* @__PURE__ */ new Set();
  function iter(descStateNode) {
    if (set.has(descStateNode)) {
      return;
    }
    set.add(descStateNode);
    if (descStateNode.type === "compound") {
      iter(descStateNode.initial.target[0]);
    } else if (descStateNode.type === "parallel") {
      for (const child of getChildren(descStateNode)) {
        iter(child);
      }
    }
  }
  iter(stateNode);
  return set;
}
function getStateNode(stateNode, stateKey) {
  if (isStateId(stateKey)) {
    return stateNode.machine.getStateNodeById(stateKey);
  }
  if (!stateNode.states) {
    throw new Error(`Unable to retrieve child state '${stateKey}' from '${stateNode.id}'; no child states exist.`);
  }
  const result = stateNode.states[stateKey];
  if (!result) {
    throw new Error(`Child state '${stateKey}' does not exist on '${stateNode.id}'`);
  }
  return result;
}
function getStateNodeByPath(stateNode, statePath) {
  if (typeof statePath === "string" && isStateId(statePath)) {
    try {
      return stateNode.machine.getStateNodeById(statePath);
    } catch {
    }
  }
  const arrayStatePath = toStatePath(statePath).slice();
  let currentStateNode = stateNode;
  while (arrayStatePath.length) {
    const key = arrayStatePath.shift();
    if (!key.length) {
      break;
    }
    currentStateNode = getStateNode(currentStateNode, key);
  }
  return currentStateNode;
}
function getStateNodes(stateNode, stateValue) {
  if (typeof stateValue === "string") {
    const childStateNode = stateNode.states[stateValue];
    if (!childStateNode) {
      throw new Error(`State '${stateValue}' does not exist on '${stateNode.id}'`);
    }
    return [stateNode, childStateNode];
  }
  const childStateKeys = Object.keys(stateValue);
  const childStateNodes = childStateKeys.map((subStateKey) => getStateNode(stateNode, subStateKey)).filter(Boolean);
  return [stateNode.machine.root, stateNode].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey) => {
    const subStateNode = getStateNode(stateNode, subStateKey);
    if (!subStateNode) {
      return allSubStateNodes;
    }
    const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);
    return allSubStateNodes.concat(subStateNodes);
  }, []));
}
function transitionAtomicNode(stateNode, stateValue, snapshot, event) {
  const childStateNode = getStateNode(stateNode, stateValue);
  const next = childStateNode.next(snapshot, event);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event);
  }
  return next;
}
function transitionCompoundNode(stateNode, stateValue, snapshot, event) {
  const subStateKeys = Object.keys(stateValue);
  const childStateNode = getStateNode(stateNode, subStateKeys[0]);
  const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);
  if (!next || !next.length) {
    return stateNode.next(snapshot, event);
  }
  return next;
}
function transitionParallelNode(stateNode, stateValue, snapshot, event) {
  const allInnerTransitions = [];
  for (const subStateKey of Object.keys(stateValue)) {
    const subStateValue = stateValue[subStateKey];
    if (!subStateValue) {
      continue;
    }
    const subStateNode = getStateNode(stateNode, subStateKey);
    const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);
    if (innerTransitions) {
      allInnerTransitions.push(...innerTransitions);
    }
  }
  if (!allInnerTransitions.length) {
    return stateNode.next(snapshot, event);
  }
  return allInnerTransitions;
}
function transitionNode(stateNode, stateValue, snapshot, event) {
  if (typeof stateValue === "string") {
    return transitionAtomicNode(stateNode, stateValue, snapshot, event);
  }
  if (Object.keys(stateValue).length === 1) {
    return transitionCompoundNode(stateNode, stateValue, snapshot, event);
  }
  return transitionParallelNode(stateNode, stateValue, snapshot, event);
}
function getHistoryNodes(stateNode) {
  return Object.keys(stateNode.states).map((key) => stateNode.states[key]).filter((sn) => sn.type === "history");
}
function isDescendant(childStateNode, parentStateNode) {
  let marker = childStateNode;
  while (marker.parent && marker.parent !== parentStateNode) {
    marker = marker.parent;
  }
  return marker.parent === parentStateNode;
}
function hasIntersection(s1, s25) {
  const set1 = new Set(s1);
  const set2 = new Set(s25);
  for (const item of set1) {
    if (set2.has(item)) {
      return true;
    }
  }
  for (const item of set2) {
    if (set1.has(item)) {
      return true;
    }
  }
  return false;
}
function removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {
  const filteredTransitions = /* @__PURE__ */ new Set();
  for (const t1 of enabledTransitions) {
    let t1Preempted = false;
    const transitionsToRemove = /* @__PURE__ */ new Set();
    for (const t23 of filteredTransitions) {
      if (hasIntersection(computeExitSet([t1], stateNodeSet, historyValue), computeExitSet([t23], stateNodeSet, historyValue))) {
        if (isDescendant(t1.source, t23.source)) {
          transitionsToRemove.add(t23);
        } else {
          t1Preempted = true;
          break;
        }
      }
    }
    if (!t1Preempted) {
      for (const t32 of transitionsToRemove) {
        filteredTransitions.delete(t32);
      }
      filteredTransitions.add(t1);
    }
  }
  return Array.from(filteredTransitions);
}
function findLeastCommonAncestor(stateNodes) {
  const [head, ...tail] = stateNodes;
  for (const ancestor of getProperAncestors(head, void 0)) {
    if (tail.every((sn) => isDescendant(sn, ancestor))) {
      return ancestor;
    }
  }
}
function getEffectiveTargetStates(transition, historyValue) {
  if (!transition.target) {
    return [];
  }
  const targets = /* @__PURE__ */ new Set();
  for (const targetNode of transition.target) {
    if (isHistoryNode(targetNode)) {
      if (historyValue[targetNode.id]) {
        for (const node of historyValue[targetNode.id]) {
          targets.add(node);
        }
      } else {
        for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)) {
          targets.add(node);
        }
      }
    } else {
      targets.add(targetNode);
    }
  }
  return [...targets];
}
function getTransitionDomain(transition, historyValue) {
  const targetStates = getEffectiveTargetStates(transition, historyValue);
  if (!targetStates) {
    return;
  }
  if (!transition.reenter && targetStates.every((target) => target === transition.source || isDescendant(target, transition.source))) {
    return transition.source;
  }
  const lca = findLeastCommonAncestor(targetStates.concat(transition.source));
  if (lca) {
    return lca;
  }
  if (transition.reenter) {
    return;
  }
  return transition.source.machine.root;
}
function computeExitSet(transitions, stateNodeSet, historyValue) {
  var _a7;
  const statesToExit = /* @__PURE__ */ new Set();
  for (const t23 of transitions) {
    if ((_a7 = t23.target) == null ? void 0 : _a7.length) {
      const domain = getTransitionDomain(t23, historyValue);
      if (t23.reenter && t23.source === domain) {
        statesToExit.add(domain);
      }
      for (const stateNode of stateNodeSet) {
        if (isDescendant(stateNode, domain)) {
          statesToExit.add(stateNode);
        }
      }
    }
  }
  return [...statesToExit];
}
function areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {
  if (prevStateNodes.length !== nextStateNodeSet.size) {
    return false;
  }
  for (const node of prevStateNodes) {
    if (!nextStateNodeSet.has(node)) {
      return false;
    }
  }
  return true;
}
function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {
  if (!transitions.length) {
    return currentSnapshot;
  }
  const mutStateNodeSet = new Set(currentSnapshot._nodes);
  let historyValue = currentSnapshot.historyValue;
  const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);
  let nextState = currentSnapshot;
  if (!isInitial) {
    [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);
  }
  nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t23) => t23.actions), internalQueue, void 0);
  nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);
  const nextStateNodes = [...mutStateNodeSet];
  if (nextState.status === "done") {
    nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a24, b6) => b6.order - a24.order).flatMap((state) => state.exit), internalQueue, void 0);
  }
  try {
    if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {
      return nextState;
    }
    return cloneMachineSnapshot(nextState, {
      _nodes: nextStateNodes,
      historyValue
    });
  } catch (e18) {
    throw e18;
  }
}
function getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {
  if (rootNode.output === void 0) {
    return;
  }
  const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== void 0 && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : void 0);
  return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);
}
function enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {
  let nextSnapshot = currentSnapshot;
  const statesToEnter = /* @__PURE__ */ new Set();
  const statesForDefaultEntry = /* @__PURE__ */ new Set();
  computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);
  if (isInitial) {
    statesForDefaultEntry.add(currentSnapshot.machine.root);
  }
  const completedNodes = /* @__PURE__ */ new Set();
  for (const stateNodeToEnter of [...statesToEnter].sort((a24, b6) => a24.order - b6.order)) {
    mutStateNodeSet.add(stateNodeToEnter);
    const actions = [];
    actions.push(...stateNodeToEnter.entry);
    for (const invokeDef of stateNodeToEnter.invoke) {
      actions.push(spawnChild(invokeDef.src, {
        ...invokeDef,
        syncSnapshot: !!invokeDef.onSnapshot
      }));
    }
    if (statesForDefaultEntry.has(stateNodeToEnter)) {
      const initialActions = stateNodeToEnter.initial.actions;
      actions.push(...initialActions);
    }
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef) => invokeDef.id));
    if (stateNodeToEnter.type === "final") {
      const parent = stateNodeToEnter.parent;
      let ancestorMarker = (parent == null ? void 0 : parent.type) === "parallel" ? parent : parent == null ? void 0 : parent.parent;
      let rootCompletionNode = ancestorMarker || stateNodeToEnter;
      if ((parent == null ? void 0 : parent.type) === "compound") {
        internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== void 0 ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : void 0));
      }
      while ((ancestorMarker == null ? void 0 : ancestorMarker.type) === "parallel" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)) {
        completedNodes.add(ancestorMarker);
        internalQueue.push(createDoneStateEvent(ancestorMarker.id));
        rootCompletionNode = ancestorMarker;
        ancestorMarker = ancestorMarker.parent;
      }
      if (ancestorMarker) {
        continue;
      }
      nextSnapshot = cloneMachineSnapshot(nextSnapshot, {
        status: "done",
        output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)
      });
    }
  }
  return nextSnapshot;
}
function computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {
  for (const t23 of transitions) {
    const domain = getTransitionDomain(t23, historyValue);
    for (const s25 of t23.target || []) {
      if (!isHistoryNode(s25) && // if the target is different than the source then it will *definitely* be entered
      (t23.source !== s25 || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      t23.source !== domain || // reentering transitions always enter the target, even if it's the source itself
      t23.reenter)) {
        statesToEnter.add(s25);
        statesForDefaultEntry.add(s25);
      }
      addDescendantStatesToEnter(s25, historyValue, statesForDefaultEntry, statesToEnter);
    }
    const targetStates = getEffectiveTargetStates(t23, historyValue);
    for (const s25 of targetStates) {
      const ancestors = getProperAncestors(s25, domain);
      if ((domain == null ? void 0 : domain.type) === "parallel") {
        ancestors.push(domain);
      }
      addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t23.source.parent && t23.reenter ? void 0 : domain);
    }
  }
}
function addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {
  var _a7;
  if (isHistoryNode(stateNode)) {
    if (historyValue[stateNode.id]) {
      const historyStateNodes = historyValue[stateNode.id];
      for (const s25 of historyStateNodes) {
        statesToEnter.add(s25);
        addDescendantStatesToEnter(s25, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s25 of historyStateNodes) {
        addProperAncestorStatesToEnter(s25, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    } else {
      const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);
      for (const s25 of historyDefaultTransition.target) {
        statesToEnter.add(s25);
        if (historyDefaultTransition === ((_a7 = stateNode.parent) == null ? void 0 : _a7.initial)) {
          statesForDefaultEntry.add(stateNode.parent);
        }
        addDescendantStatesToEnter(s25, historyValue, statesForDefaultEntry, statesToEnter);
      }
      for (const s25 of historyDefaultTransition.target) {
        addProperAncestorStatesToEnter(s25, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);
      }
    }
  } else {
    if (stateNode.type === "compound") {
      const [initialState] = stateNode.initial.target;
      if (!isHistoryNode(initialState)) {
        statesToEnter.add(initialState);
        statesForDefaultEntry.add(initialState);
      }
      addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);
      addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);
    } else {
      if (stateNode.type === "parallel") {
        for (const child of getChildren(stateNode).filter((sn) => !isHistoryNode(sn))) {
          if (![...statesToEnter].some((s25) => isDescendant(s25, child))) {
            if (!isHistoryNode(child)) {
              statesToEnter.add(child);
              statesForDefaultEntry.add(child);
            }
            addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
          }
        }
      }
    }
  }
}
function addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {
  for (const anc of ancestors) {
    if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {
      statesToEnter.add(anc);
    }
    if (anc.type === "parallel") {
      for (const child of getChildren(anc).filter((sn) => !isHistoryNode(sn))) {
        if (![...statesToEnter].some((s25) => isDescendant(s25, child))) {
          statesToEnter.add(child);
          addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);
        }
      }
    }
  }
}
function addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {
  addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));
}
function exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {
  let nextSnapshot = currentSnapshot;
  const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);
  statesToExit.sort((a24, b6) => b6.order - a24.order);
  let changedHistory;
  for (const exitStateNode of statesToExit) {
    for (const historyNode of getHistoryNodes(exitStateNode)) {
      let predicate;
      if (historyNode.history === "deep") {
        predicate = (sn) => isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);
      } else {
        predicate = (sn) => {
          return sn.parent === exitStateNode;
        };
      }
      changedHistory ?? (changedHistory = {
        ...historyValue
      });
      changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);
    }
  }
  for (const s25 of statesToExit) {
    nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [...s25.exit, ...s25.invoke.map((def) => stopChild(def.id))], internalQueue, void 0);
    mutStateNodeSet.delete(s25);
  }
  return [nextSnapshot, changedHistory || historyValue];
}
function getAction(machine, actionType) {
  return machine.implementations.actions[actionType];
}
function resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {
  const {
    machine
  } = currentSnapshot;
  let intermediateSnapshot = currentSnapshot;
  for (const action of actions) {
    const isInline = typeof action === "function";
    const resolvedAction = isInline ? action : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      getAction(machine, typeof action === "string" ? action : action.type)
    );
    const actionArgs = {
      context: intermediateSnapshot.context,
      event,
      self: actorScope.self,
      system: actorScope.system
    };
    const actionParams = isInline || typeof action === "string" ? void 0 : "params" in action ? typeof action.params === "function" ? action.params({
      context: intermediateSnapshot.context,
      event
    }) : action.params : void 0;
    if (!resolvedAction || !("resolve" in resolvedAction)) {
      actorScope.actionExecutor({
        type: typeof action === "string" ? action : typeof action === "object" ? action.type : action.name || "(anonymous)",
        info: actionArgs,
        params: actionParams,
        exec: resolvedAction
      });
      continue;
    }
    const builtinAction = resolvedAction;
    const [nextState, params, actions2] = builtinAction.resolve(
      actorScope,
      intermediateSnapshot,
      actionArgs,
      actionParams,
      resolvedAction,
      // this holds all params
      extra
    );
    intermediateSnapshot = nextState;
    if ("retryResolve" in builtinAction) {
      retries == null ? void 0 : retries.push([builtinAction, params]);
    }
    if ("execute" in builtinAction) {
      actorScope.actionExecutor({
        type: builtinAction.type,
        info: actionArgs,
        params,
        exec: builtinAction.execute.bind(null, actorScope, params)
      });
    }
    if (actions2) {
      intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions2, extra, retries);
    }
  }
  return intermediateSnapshot;
}
function resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {
  const retries = deferredActorIds ? [] : void 0;
  const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {
    internalQueue,
    deferredActorIds
  }, retries);
  retries == null ? void 0 : retries.forEach(([builtinAction, params]) => {
    builtinAction.retryResolve(actorScope, nextState, params);
  });
  return nextState;
}
function macrostep(snapshot, event, actorScope, internalQueue) {
  if (event.type === WILDCARD) {
    throw new Error(`An event cannot have the wildcard type ('${WILDCARD}')`);
  }
  let nextSnapshot = snapshot;
  const microstates = [];
  function addMicrostate(microstate, event2, transitions) {
    actorScope.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: actorScope.self,
      event: event2,
      snapshot: microstate,
      _transitions: transitions
    });
    microstates.push(microstate);
  }
  if (event.type === XSTATE_STOP) {
    nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {
      status: "stopped"
    });
    addMicrostate(nextSnapshot, event, []);
    return {
      snapshot: nextSnapshot,
      microstates
    };
  }
  let nextEvent = event;
  if (nextEvent.type !== XSTATE_INIT) {
    const currentEvent = nextEvent;
    const isErr = isErrorActorEvent(currentEvent);
    const transitions = selectTransitions(currentEvent, nextSnapshot);
    if (isErr && !transitions.length) {
      nextSnapshot = cloneMachineSnapshot(snapshot, {
        status: "error",
        error: currentEvent.error
      });
      addMicrostate(nextSnapshot, currentEvent, []);
      return {
        snapshot: nextSnapshot,
        microstates
      };
    }
    nextSnapshot = microstep(
      transitions,
      snapshot,
      actorScope,
      nextEvent,
      false,
      // isInitial
      internalQueue
    );
    addMicrostate(nextSnapshot, currentEvent, transitions);
  }
  let shouldSelectEventlessTransitions = true;
  while (nextSnapshot.status === "active") {
    let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];
    const previousState = enabledTransitions.length ? nextSnapshot : void 0;
    if (!enabledTransitions.length) {
      if (!internalQueue.length) {
        break;
      }
      nextEvent = internalQueue.shift();
      enabledTransitions = selectTransitions(nextEvent, nextSnapshot);
    }
    nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);
    shouldSelectEventlessTransitions = nextSnapshot !== previousState;
    addMicrostate(nextSnapshot, nextEvent, enabledTransitions);
  }
  if (nextSnapshot.status !== "active") {
    stopChildren(nextSnapshot, nextEvent, actorScope);
  }
  return {
    snapshot: nextSnapshot,
    microstates
  };
}
function stopChildren(nextState, event, actorScope) {
  return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child) => stopChild(child)), [], void 0);
}
function selectTransitions(event, nextState) {
  return nextState.machine.getTransitionData(nextState, event);
}
function selectEventlessTransitions(nextState, event) {
  const enabledTransitionSet = /* @__PURE__ */ new Set();
  const atomicStates = nextState._nodes.filter(isAtomicStateNode);
  for (const stateNode of atomicStates) {
    loop: for (const s25 of [stateNode].concat(getProperAncestors(stateNode, void 0))) {
      if (!s25.always) {
        continue;
      }
      for (const transition of s25.always) {
        if (transition.guard === void 0 || evaluateGuard(transition.guard, nextState.context, event, nextState)) {
          enabledTransitionSet.add(transition);
          break loop;
        }
      }
    }
  }
  return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);
}
function resolveStateValue(rootNode, stateValue) {
  const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));
  return getStateValue(rootNode, [...allStateNodes]);
}
function isMachineSnapshot(value) {
  return !!value && typeof value === "object" && "machine" in value && "value" in value;
}
var machineSnapshotMatches = function matches(testValue) {
  return matchesState(testValue, this.value);
};
var machineSnapshotHasTag = function hasTag(tag) {
  return this.tags.has(tag);
};
var machineSnapshotCan = function can(event) {
  if (!this.machine) {
    console.warn(`state.can(...) used outside of a machine-created State object; this will always return false.`);
  }
  const transitionData = this.machine.getTransitionData(this, event);
  return !!(transitionData == null ? void 0 : transitionData.length) && // Check that at least one transition is not forbidden
  transitionData.some((t23) => t23.target !== void 0 || t23.actions.length);
};
var machineSnapshotToJSON = function toJSON() {
  const {
    _nodes: nodes,
    tags,
    machine,
    getMeta: getMeta2,
    toJSON: toJSON3,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    ...jsonValues
  } = this;
  return {
    ...jsonValues,
    tags: Array.from(tags)
  };
};
var machineSnapshotGetMeta = function getMeta() {
  return this._nodes.reduce((acc, stateNode) => {
    if (stateNode.meta !== void 0) {
      acc[stateNode.id] = stateNode.meta;
    }
    return acc;
  }, {});
};
function createMachineSnapshot(config2, machine) {
  return {
    status: config2.status,
    output: config2.output,
    error: config2.error,
    machine,
    context: config2.context,
    _nodes: config2._nodes,
    value: getStateValue(machine.root, config2._nodes),
    tags: new Set(config2._nodes.flatMap((sn) => sn.tags)),
    children: config2.children,
    historyValue: config2.historyValue || {},
    matches: machineSnapshotMatches,
    hasTag: machineSnapshotHasTag,
    can: machineSnapshotCan,
    getMeta: machineSnapshotGetMeta,
    toJSON: machineSnapshotToJSON
  };
}
function cloneMachineSnapshot(snapshot, config2 = {}) {
  return createMachineSnapshot({
    ...snapshot,
    ...config2
  }, snapshot.machine);
}
function getPersistedSnapshot(snapshot, options) {
  const {
    _nodes: nodes,
    tags,
    machine,
    children,
    context: context2,
    can: can2,
    hasTag: hasTag2,
    matches: matches2,
    getMeta: getMeta2,
    toJSON: toJSON3,
    ...jsonValues
  } = snapshot;
  const childrenJson = {};
  for (const id in children) {
    const child = children[id];
    if (typeof child.src !== "string" && (!options || !("__unsafeAllowInlineActors" in options))) {
      throw new Error("An inline child actor cannot be persisted.");
    }
    childrenJson[id] = {
      snapshot: child.getPersistedSnapshot(options),
      src: child.src,
      systemId: child._systemId,
      syncSnapshot: child._syncSnapshot
    };
  }
  const persisted = {
    ...jsonValues,
    context: persistContext(context2),
    children: childrenJson
  };
  return persisted;
}
function persistContext(contextPart) {
  let copy;
  for (const key in contextPart) {
    const value = contextPart[key];
    if (value && typeof value === "object") {
      if ("sessionId" in value && "send" in value && "ref" in value) {
        copy ?? (copy = Array.isArray(contextPart) ? contextPart.slice() : {
          ...contextPart
        });
        copy[key] = {
          xstate$$type: $$ACTOR_TYPE,
          id: value.id
        };
      } else {
        const result = persistContext(value);
        if (result !== value) {
          copy ?? (copy = Array.isArray(contextPart) ? contextPart.slice() : {
            ...contextPart
          });
          copy[key] = result;
        }
      }
    }
  }
  return copy ?? contextPart;
}
function resolveRaise(_6, snapshot, args, actionParams, {
  event: eventOrExpr,
  id,
  delay: delay2
}, {
  internalQueue
}) {
  const delaysMap = snapshot.machine.implementations.delays;
  if (typeof eventOrExpr === "string") {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${eventOrExpr}" }) instead`
    );
  }
  const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  let resolvedDelay;
  if (typeof delay2 === "string") {
    const configDelay = delaysMap && delaysMap[delay2];
    resolvedDelay = typeof configDelay === "function" ? configDelay(args, actionParams) : configDelay;
  } else {
    resolvedDelay = typeof delay2 === "function" ? delay2(args, actionParams) : delay2;
  }
  if (typeof resolvedDelay !== "number") {
    internalQueue.push(resolvedEvent);
  }
  return [snapshot, {
    event: resolvedEvent,
    id,
    delay: resolvedDelay
  }, void 0];
}
function executeRaise(actorScope, params) {
  const {
    event,
    delay: delay2,
    id
  } = params;
  if (typeof delay2 === "number") {
    actorScope.defer(() => {
      const self2 = actorScope.self;
      actorScope.system.scheduler.schedule(self2, self2, event, delay2, id);
    });
    return;
  }
}
function raise(eventOrExpr, options) {
  if (executingCustomAction) {
    console.warn("Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");
  }
  function raise2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  raise2.type = "xstate.raise";
  raise2.event = eventOrExpr;
  raise2.id = options == null ? void 0 : options.id;
  raise2.delay = options == null ? void 0 : options.delay;
  raise2.resolve = resolveRaise;
  raise2.execute = executeRaise;
  return raise2;
}

// node_modules/xstate/actors/dist/xstate-actors.development.esm.js
function fromTransition(transition, initialContext) {
  return {
    config: transition,
    transition: (snapshot, event, actorScope) => {
      return {
        ...snapshot,
        context: transition(snapshot.context, event, actorScope)
      };
    },
    getInitialSnapshot: (_6, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        context: typeof initialContext === "function" ? initialContext({
          input
        }) : initialContext
      };
    },
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
}
var instanceStates = /* @__PURE__ */ new WeakMap();
function fromCallback(callback) {
  const logic = {
    config: callback,
    start: (state, actorScope) => {
      const {
        self: self2,
        system,
        emit: emit2
      } = actorScope;
      const callbackState = {
        receivers: void 0,
        dispose: void 0
      };
      instanceStates.set(self2, callbackState);
      callbackState.dispose = callback({
        input: state.input,
        system,
        self: self2,
        sendBack: (event) => {
          if (self2.getSnapshot().status === "stopped") {
            return;
          }
          if (self2._parent) {
            system._relay(self2, self2._parent, event);
          }
        },
        receive: (listener) => {
          callbackState.receivers ?? (callbackState.receivers = /* @__PURE__ */ new Set());
          callbackState.receivers.add(listener);
        },
        emit: emit2
      });
    },
    transition: (state, event, actorScope) => {
      var _a7, _b4;
      const callbackState = instanceStates.get(actorScope.self);
      if (event.type === XSTATE_STOP) {
        state = {
          ...state,
          status: "stopped",
          error: void 0
        };
        (_a7 = callbackState.dispose) == null ? void 0 : _a7.call(callbackState);
        return state;
      }
      (_b4 = callbackState.receivers) == null ? void 0 : _b4.forEach((receiver) => receiver(event));
      return state;
    },
    getInitialSnapshot: (_6, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        input
      };
    },
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
  return logic;
}
var XSTATE_OBSERVABLE_NEXT = "xstate.observable.next";
var XSTATE_OBSERVABLE_ERROR = "xstate.observable.error";
var XSTATE_OBSERVABLE_COMPLETE = "xstate.observable.complete";
function fromObservable(observableCreator) {
  const logic = {
    config: observableCreator,
    transition: (snapshot, event) => {
      if (snapshot.status !== "active") {
        return snapshot;
      }
      switch (event.type) {
        case XSTATE_OBSERVABLE_NEXT: {
          const newSnapshot = {
            ...snapshot,
            context: event.data
          };
          return newSnapshot;
        }
        case XSTATE_OBSERVABLE_ERROR:
          return {
            ...snapshot,
            status: "error",
            error: event.data,
            input: void 0,
            _subscription: void 0
          };
        case XSTATE_OBSERVABLE_COMPLETE:
          return {
            ...snapshot,
            status: "done",
            input: void 0,
            _subscription: void 0
          };
        case XSTATE_STOP:
          snapshot._subscription.unsubscribe();
          return {
            ...snapshot,
            status: "stopped",
            input: void 0,
            _subscription: void 0
          };
        default:
          return snapshot;
      }
    },
    getInitialSnapshot: (_6, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        context: void 0,
        input,
        _subscription: void 0
      };
    },
    start: (state, {
      self: self2,
      system,
      emit: emit2
    }) => {
      if (state.status === "done") {
        return;
      }
      state._subscription = observableCreator({
        input: state.input,
        system,
        self: self2,
        emit: emit2
      }).subscribe({
        next: (value) => {
          system._relay(self2, self2, {
            type: XSTATE_OBSERVABLE_NEXT,
            data: value
          });
        },
        error: (err) => {
          system._relay(self2, self2, {
            type: XSTATE_OBSERVABLE_ERROR,
            data: err
          });
        },
        complete: () => {
          system._relay(self2, self2, {
            type: XSTATE_OBSERVABLE_COMPLETE
          });
        }
      });
    },
    getPersistedSnapshot: ({
      _subscription,
      ...state
    }) => state,
    restoreSnapshot: (state) => ({
      ...state,
      _subscription: void 0
    })
  };
  return logic;
}
var XSTATE_PROMISE_RESOLVE = "xstate.promise.resolve";
var XSTATE_PROMISE_REJECT = "xstate.promise.reject";
var controllerMap = /* @__PURE__ */ new WeakMap();
function fromPromise(promiseCreator) {
  const logic = {
    config: promiseCreator,
    transition: (state, event, scope) => {
      var _a7;
      if (state.status !== "active") {
        return state;
      }
      switch (event.type) {
        case XSTATE_PROMISE_RESOLVE: {
          const resolvedValue = event.data;
          return {
            ...state,
            status: "done",
            output: resolvedValue,
            input: void 0
          };
        }
        case XSTATE_PROMISE_REJECT:
          return {
            ...state,
            status: "error",
            error: event.data,
            input: void 0
          };
        case XSTATE_STOP: {
          (_a7 = controllerMap.get(scope.self)) == null ? void 0 : _a7.abort();
          return {
            ...state,
            status: "stopped",
            input: void 0
          };
        }
        default:
          return state;
      }
    },
    start: (state, {
      self: self2,
      system,
      emit: emit2
    }) => {
      if (state.status !== "active") {
        return;
      }
      const controller = new AbortController();
      controllerMap.set(self2, controller);
      const resolvedPromise = Promise.resolve(promiseCreator({
        input: state.input,
        system,
        self: self2,
        signal: controller.signal,
        emit: emit2
      }));
      resolvedPromise.then((response) => {
        if (self2.getSnapshot().status !== "active") {
          return;
        }
        controllerMap.delete(self2);
        system._relay(self2, self2, {
          type: XSTATE_PROMISE_RESOLVE,
          data: response
        });
      }, (errorData) => {
        if (self2.getSnapshot().status !== "active") {
          return;
        }
        controllerMap.delete(self2);
        system._relay(self2, self2, {
          type: XSTATE_PROMISE_REJECT,
          data: errorData
        });
      });
    },
    getInitialSnapshot: (_6, input) => {
      return {
        status: "active",
        output: void 0,
        error: void 0,
        input
      };
    },
    getPersistedSnapshot: (snapshot) => snapshot,
    restoreSnapshot: (snapshot) => snapshot
  };
  return logic;
}
var emptyLogic = fromTransition((_6) => void 0, void 0);

// node_modules/xstate/dist/log-0acd9069.development.esm.js
function createSpawner(actorScope, {
  machine,
  context: context2
}, event, spawnedChildren) {
  const spawn = (src, options) => {
    if (typeof src === "string") {
      const logic = resolveReferencedActor(machine, src);
      if (!logic) {
        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);
      }
      const actorRef = createActor(logic, {
        id: options == null ? void 0 : options.id,
        parent: actorScope.self,
        syncSnapshot: options == null ? void 0 : options.syncSnapshot,
        input: typeof (options == null ? void 0 : options.input) === "function" ? options.input({
          context: context2,
          event,
          self: actorScope.self
        }) : options == null ? void 0 : options.input,
        src,
        systemId: options == null ? void 0 : options.systemId
      });
      spawnedChildren[actorRef.id] = actorRef;
      return actorRef;
    } else {
      const actorRef = createActor(src, {
        id: options == null ? void 0 : options.id,
        parent: actorScope.self,
        syncSnapshot: options == null ? void 0 : options.syncSnapshot,
        input: options == null ? void 0 : options.input,
        src,
        systemId: options == null ? void 0 : options.systemId
      });
      return actorRef;
    }
  };
  return (src, options) => {
    const actorRef = spawn(src, options);
    spawnedChildren[actorRef.id] = actorRef;
    actorScope.defer(() => {
      if (actorRef._processingStatus === ProcessingStatus.Stopped) {
        return;
      }
      actorRef.start();
    });
    return actorRef;
  };
}
function resolveAssign(actorScope, snapshot, actionArgs, actionParams, {
  assignment
}) {
  if (!snapshot.context) {
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  }
  const spawnedChildren = {};
  const assignArgs = {
    context: snapshot.context,
    event: actionArgs.event,
    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),
    self: actorScope.self,
    system: actorScope.system
  };
  let partialUpdate = {};
  if (typeof assignment === "function") {
    partialUpdate = assignment(assignArgs, actionParams);
  } else {
    for (const key of Object.keys(assignment)) {
      const propAssignment = assignment[key];
      partialUpdate[key] = typeof propAssignment === "function" ? propAssignment(assignArgs, actionParams) : propAssignment;
    }
  }
  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);
  return [cloneMachineSnapshot(snapshot, {
    context: updatedContext,
    children: Object.keys(spawnedChildren).length ? {
      ...snapshot.children,
      ...spawnedChildren
    } : snapshot.children
  }), void 0, void 0];
}
function assign(assignment) {
  if (executingCustomAction) {
    console.warn("Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");
  }
  function assign2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  assign2.type = "xstate.assign";
  assign2.assignment = assignment;
  assign2.resolve = resolveAssign;
  return assign2;
}
function resolveEmit(_6, snapshot, args, actionParams, {
  event: eventOrExpr
}) {
  const resolvedEvent = typeof eventOrExpr === "function" ? eventOrExpr(args, actionParams) : eventOrExpr;
  return [snapshot, {
    event: resolvedEvent
  }, void 0];
}
function executeEmit(actorScope, {
  event
}) {
  actorScope.defer(() => actorScope.emit(event));
}
function emit(eventOrExpr) {
  if (executingCustomAction) {
    console.warn("Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.");
  }
  function emit2(_args, _params) {
    {
      throw new Error(`This isn't supposed to be called`);
    }
  }
  emit2.type = "xstate.emit";
  emit2.event = eventOrExpr;
  emit2.resolve = resolveEmit;
  emit2.execute = executeEmit;
  return emit2;
}
var SpecialTargets = function(SpecialTargets2) {
  SpecialTargets2["Parent"] = "#_parent";
  SpecialTargets2["Internal"] = "#_internal";
  return SpecialTargets2;
}({});

// node_modules/xstate/dist/xstate.development.esm.js
var cache = /* @__PURE__ */ new WeakMap();
function memo(object, key, fn) {
  let memoizedData = cache.get(object);
  if (!memoizedData) {
    memoizedData = {
      [key]: fn()
    };
    cache.set(object, memoizedData);
  } else if (!(key in memoizedData)) {
    memoizedData[key] = fn();
  }
  return memoizedData[key];
}
var EMPTY_OBJECT = {};
var toSerializableAction = (action) => {
  if (typeof action === "string") {
    return {
      type: action
    };
  }
  if (typeof action === "function") {
    if ("resolve" in action) {
      return {
        type: action.type
      };
    }
    return {
      type: action.name
    };
  }
  return action;
};
var StateNode = class _StateNode {
  constructor(config2, options) {
    this.config = config2;
    this.key = void 0;
    this.id = void 0;
    this.type = void 0;
    this.path = void 0;
    this.states = void 0;
    this.history = void 0;
    this.entry = void 0;
    this.exit = void 0;
    this.parent = void 0;
    this.machine = void 0;
    this.meta = void 0;
    this.output = void 0;
    this.order = -1;
    this.description = void 0;
    this.tags = [];
    this.transitions = void 0;
    this.always = void 0;
    this.parent = options._parent;
    this.key = options._key;
    this.machine = options._machine;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);
    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic");
    this.description = this.config.description;
    this.order = this.machine.idMap.size;
    this.machine.idMap.set(this.id, this);
    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {
      const stateNode = new _StateNode(stateConfig, {
        _parent: this,
        _key: key,
        _machine: this.machine
      });
      return stateNode;
    }) : EMPTY_OBJECT;
    if (this.type === "compound" && !this.config.initial) {
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    }
    this.history = this.config.history === true ? "shallow" : this.config.history || false;
    this.entry = toArray(this.config.entry).slice();
    this.exit = toArray(this.config.exit).slice();
    this.meta = this.config.meta;
    this.output = this.type === "final" || !this.parent ? this.config.output : void 0;
    this.tags = toArray(config2.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = formatTransitions(this);
    if (this.config.always) {
      this.always = toTransitionConfigArray(this.config.always).map((t23) => formatTransition(this, NULL_EVENT, t23));
    }
    Object.keys(this.states).forEach((key) => {
      this.states[key]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(toSerializableAction),
        eventType: null,
        reenter: false,
        toJSON: () => ({
          target: this.initial.target.map((t23) => `#${t23.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(toSerializableAction),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: mapValues(this.states, (state) => {
        return state.definition;
      }),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((t23) => ({
        ...t23,
        actions: t23.actions.map(toSerializableAction)
      })),
      entry: this.entry.map(toSerializableAction),
      exit: this.exit.map(toSerializableAction),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return memo(this, "invoke", () => toArray(this.config.invoke).map((invokeConfig, i23) => {
      const {
        src,
        systemId
      } = invokeConfig;
      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i23);
      const sourceName = typeof src === "string" ? src : `xstate.invoke.${createInvokeId(this.id, i23)}`;
      return {
        ...invokeConfig,
        src: sourceName,
        id: resolvedId,
        systemId,
        toJSON() {
          const {
            onDone,
            onError,
            ...invokeDefValues
          } = invokeConfig;
          return {
            ...invokeDefValues,
            type: "xstate.invoke",
            src: sourceName,
            id: resolvedId
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return memo(this, "on", () => {
      const transitions = this.transitions;
      return [...transitions].flatMap(([descriptor, t23]) => t23.map((t24) => [descriptor, t24])).reduce((map2, [descriptor, transition]) => {
        map2[descriptor] = map2[descriptor] || [];
        map2[descriptor].push(transition);
        return map2;
      }, {});
    });
  }
  get after() {
    return memo(this, "delayedTransitions", () => getDelayedTransitions(this));
  }
  get initial() {
    return memo(this, "initial", () => formatInitialTransition(this, this.config.initial));
  }
  /** @internal */
  next(snapshot, event) {
    const eventType = event.type;
    const actions = [];
    let selectedTransition;
    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));
    for (const candidate of candidates) {
      const {
        guard
      } = candidate;
      const resolvedContext = snapshot.context;
      let guardPassed = false;
      try {
        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);
      } catch (err) {
        const guardType = typeof guard === "string" ? guard : typeof guard === "object" ? guard.type : void 0;
        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ""}in transition for event '${eventType}' in state node '${this.id}':
${err.message}`);
      }
      if (guardPassed) {
        actions.push(...candidate.actions);
        selectedTransition = candidate;
        break;
      }
    }
    return selectedTransition ? [selectedTransition] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return memo(this, "events", () => {
      const {
        states
      } = this;
      const events = new Set(this.ownEvents);
      if (states) {
        for (const stateId of Object.keys(states)) {
          const state = states[stateId];
          if (state.states) {
            for (const event of state.events) {
              events.add(`${event}`);
            }
          }
        }
      }
      return Array.from(events);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const events = new Set([...this.transitions.keys()].filter((descriptor) => {
      return this.transitions.get(descriptor).some((transition) => !(!transition.target && !transition.actions.length && !transition.reenter));
    }));
    return Array.from(events);
  }
};
var STATE_IDENTIFIER2 = "#";
var StateMachine = class _StateMachine {
  constructor(config2, implementations) {
    this.config = config2;
    this.version = void 0;
    this.schemas = void 0;
    this.implementations = void 0;
    this.__xstatenode = true;
    this.idMap = /* @__PURE__ */ new Map();
    this.root = void 0;
    this.id = void 0;
    this.states = void 0;
    this.events = void 0;
    this.id = config2.id || "(machine)";
    this.implementations = {
      actors: (implementations == null ? void 0 : implementations.actors) ?? {},
      actions: (implementations == null ? void 0 : implementations.actions) ?? {},
      delays: (implementations == null ? void 0 : implementations.delays) ?? {},
      guards: (implementations == null ? void 0 : implementations.guards) ?? {}
    };
    this.version = this.config.version;
    this.schemas = this.config.schemas;
    this.transition = this.transition.bind(this);
    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);
    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);
    this.restoreSnapshot = this.restoreSnapshot.bind(this);
    this.start = this.start.bind(this);
    this.root = new StateNode(config2, {
      _key: this.id,
      _machine: this
    });
    this.root._initialize();
    this.states = this.root.states;
    this.events = this.root.events;
    if (!("output" in this.root) && Object.values(this.states).some((state) => state.type === "final" && "output" in state)) {
      console.warn("Missing `machine.output` declaration (top-level final state with output detected)");
    }
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(implementations) {
    const {
      actions,
      guards,
      actors,
      delays
    } = this.implementations;
    return new _StateMachine(this.config, {
      actions: {
        ...actions,
        ...implementations.actions
      },
      guards: {
        ...guards,
        ...implementations.guards
      },
      actors: {
        ...actors,
        ...implementations.actors
      },
      delays: {
        ...delays,
        ...implementations.delays
      }
    });
  }
  resolveState(config2) {
    const resolvedStateValue = resolveStateValue(this.root, config2.value);
    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));
    return createMachineSnapshot({
      _nodes: [...nodeSet],
      context: config2.context || {},
      children: {},
      status: isInFinalState(nodeSet, this.root) ? "done" : config2.status || "active",
      output: config2.output,
      error: config2.error,
      historyValue: config2.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(snapshot, event, actorScope) {
    return macrostep(snapshot, event, actorScope, []).microstates;
  }
  getTransitionData(snapshot, event) {
    return transitionNode(this.root, snapshot.value, snapshot, event) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(actorScope, initEvent, internalQueue) {
    const {
      context: context2
    } = this.config;
    const preInitial = createMachineSnapshot({
      context: typeof context2 !== "function" && context2 ? context2 : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    if (typeof context2 === "function") {
      const assignment = ({
        spawn,
        event,
        self: self2
      }) => context2({
        spawn,
        input: event.input,
        self: self2
      });
      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue, void 0);
    }
    return preInitial;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(actorScope, input) {
    const initEvent = createInitEvent(input);
    const internalQueue = [];
    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);
    const nextState = microstep([{
      target: [...getInitialStateNodes(this.root)],
      source: this.root,
      reenter: true,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], preInitialState, actorScope, initEvent, true, internalQueue);
    const {
      snapshot: macroState
    } = macrostep(nextState, initEvent, actorScope, internalQueue);
    return macroState;
  }
  start(snapshot) {
    Object.values(snapshot.children).forEach((child) => {
      if (child.getSnapshot().status === "active") {
        child.start();
      }
    });
  }
  getStateNodeById(stateId) {
    const fullPath = toStatePath(stateId);
    const relativePath = fullPath.slice(1);
    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER2.length) : fullPath[0];
    const stateNode = this.idMap.get(resolvedStateId);
    if (!stateNode) {
      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);
    }
    return getStateNodeByPath(stateNode, relativePath);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(snapshot, options) {
    return getPersistedSnapshot(snapshot, options);
  }
  restoreSnapshot(snapshot, _actorScope) {
    const children = {};
    const snapshotChildren = snapshot.children;
    Object.keys(snapshotChildren).forEach((actorId) => {
      const actorData = snapshotChildren[actorId];
      const childState = actorData.snapshot;
      const src = actorData.src;
      const logic = typeof src === "string" ? resolveReferencedActor(this, src) : src;
      if (!logic) {
        return;
      }
      const actorRef = createActor(logic, {
        id: actorId,
        parent: _actorScope.self,
        syncSnapshot: actorData.syncSnapshot,
        snapshot: childState,
        src,
        systemId: actorData.systemId
      });
      children[actorId] = actorRef;
    });
    const restoredSnapshot = createMachineSnapshot({
      ...snapshot,
      children,
      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))
    }, this);
    const seen = /* @__PURE__ */ new Set();
    function reviveContext(contextPart, children2) {
      if (seen.has(contextPart)) {
        return;
      }
      seen.add(contextPart);
      for (const key in contextPart) {
        const value = contextPart[key];
        if (value && typeof value === "object") {
          if ("xstate$$type" in value && value.xstate$$type === $$ACTOR_TYPE) {
            contextPart[key] = children2[value.id];
            continue;
          }
          reviveContext(value, children2);
        }
      }
    }
    reviveContext(restoredSnapshot.context, children);
    return restoredSnapshot;
  }
};
function createMachine(config2, implementations) {
  return new StateMachine(config2, implementations);
}
function setup({
  schemas,
  actors,
  actions,
  guards,
  delays
}) {
  return {
    createMachine: (config2) => createMachine({
      ...config2,
      schemas
    }, {
      actors,
      actions,
      guards,
      delays
    })
  };
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/Errors.js
var n3 = class {
  constructor(r10) {
    __publicField(this, "_tag", "DeviceNotOnboardedError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Device not onboarded.");
  }
};
var e3 = class {
  constructor(r10) {
    __publicField(this, "_tag", "DeviceLockedError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Device locked.");
  }
};
var t4 = class {
  constructor(r10) {
    __publicField(this, "_tag", "UnsupportedFirmwareDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unknown error.");
  }
};
var i7 = class {
  constructor(r10) {
    __publicField(this, "_tag", "RefusedByUserDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unknown error.");
  }
};
var a5 = class {
  constructor(r10) {
    __publicField(this, "_tag", "AppAlreadyInstalledDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unknown error.");
  }
};
var l4 = class {
  constructor(r10) {
    __publicField(this, "_tag", "OutOfMemoryDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unknown error.");
  }
};
var s9 = class {
  constructor(r10) {
    __publicField(this, "_tag", "UnknownDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unknown error.");
  }
};
var E2 = class {
  constructor(r10) {
    __publicField(this, "_tag", "UnsupportedApplicationDAError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Application currently not supported.");
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/Const.js
var T = 6e4;

// node_modules/rxjs/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d18, b6) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d19, b7) {
    d19.__proto__ = b7;
  } || function(d19, b7) {
    for (var p30 in b7) if (Object.prototype.hasOwnProperty.call(b7, p30)) d19[p30] = b7[p30];
  };
  return extendStatics(d18, b6);
};
function __extends(d18, b6) {
  if (typeof b6 !== "function" && b6 !== null)
    throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
  extendStatics(d18, b6);
  function __() {
    this.constructor = d18;
  }
  d18.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
}
function __awaiter(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve) {
      resolve(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e18) {
        reject(e18);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e18) {
        reject(e18);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _6 = { label: 0, sent: function() {
    if (t23[0] & 1) throw t23[1];
    return t23[1];
  }, trys: [], ops: [] }, f9, y6, t23, g23 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g23.next = verb(0), g23["throw"] = verb(1), g23["return"] = verb(2), typeof Symbol === "function" && (g23[Symbol.iterator] = function() {
    return this;
  }), g23;
  function verb(n18) {
    return function(v22) {
      return step([n18, v22]);
    };
  }
  function step(op) {
    if (f9) throw new TypeError("Generator is already executing.");
    while (g23 && (g23 = 0, op[0] && (_6 = 0)), _6) try {
      if (f9 = 1, y6 && (t23 = op[0] & 2 ? y6["return"] : op[0] ? y6["throw"] || ((t23 = y6["return"]) && t23.call(y6), 0) : y6.next) && !(t23 = t23.call(y6, op[1])).done) return t23;
      if (y6 = 0, t23) op = [op[0] & 2, t23.value];
      switch (op[0]) {
        case 0:
        case 1:
          t23 = op;
          break;
        case 4:
          _6.label++;
          return { value: op[1], done: false };
        case 5:
          _6.label++;
          y6 = op[1];
          op = [0];
          continue;
        case 7:
          op = _6.ops.pop();
          _6.trys.pop();
          continue;
        default:
          if (!(t23 = _6.trys, t23 = t23.length > 0 && t23[t23.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _6 = 0;
            continue;
          }
          if (op[0] === 3 && (!t23 || op[1] > t23[0] && op[1] < t23[3])) {
            _6.label = op[1];
            break;
          }
          if (op[0] === 6 && _6.label < t23[1]) {
            _6.label = t23[1];
            t23 = op;
            break;
          }
          if (t23 && _6.label < t23[2]) {
            _6.label = t23[2];
            _6.ops.push(op);
            break;
          }
          if (t23[2]) _6.ops.pop();
          _6.trys.pop();
          continue;
      }
      op = body.call(thisArg, _6);
    } catch (e18) {
      op = [6, e18];
      y6 = 0;
    } finally {
      f9 = t23 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o12) {
  var s25 = typeof Symbol === "function" && Symbol.iterator, m15 = s25 && o12[s25], i23 = 0;
  if (m15) return m15.call(o12);
  if (o12 && typeof o12.length === "number") return {
    next: function() {
      if (o12 && i23 >= o12.length) o12 = void 0;
      return { value: o12 && o12[i23++], done: !o12 };
    }
  };
  throw new TypeError(s25 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o12, n18) {
  var m15 = typeof Symbol === "function" && o12[Symbol.iterator];
  if (!m15) return o12;
  var i23 = m15.call(o12), r10, ar = [], e18;
  try {
    while ((n18 === void 0 || n18-- > 0) && !(r10 = i23.next()).done) ar.push(r10.value);
  } catch (error) {
    e18 = { error };
  } finally {
    try {
      if (r10 && !r10.done && (m15 = i23["return"])) m15.call(i23);
    } finally {
      if (e18) throw e18.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i23 = 0, l19 = from2.length, ar; i23 < l19; i23++) {
    if (ar || !(i23 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i23);
      ar[i23] = from2[i23];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v22) {
  return this instanceof __await ? (this.v = v22, this) : new __await(v22);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g23 = generator.apply(thisArg, _arguments || []), i23, q3 = [];
  return i23 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i23[Symbol.asyncIterator] = function() {
    return this;
  }, i23;
  function awaitReturn(f9) {
    return function(v22) {
      return Promise.resolve(v22).then(f9, reject);
    };
  }
  function verb(n18, f9) {
    if (g23[n18]) {
      i23[n18] = function(v22) {
        return new Promise(function(a24, b6) {
          q3.push([n18, v22, a24, b6]) > 1 || resume(n18, v22);
        });
      };
      if (f9) i23[n18] = f9(i23[n18]);
    }
  }
  function resume(n18, v22) {
    try {
      step(g23[n18](v22));
    } catch (e18) {
      settle2(q3[0][3], e18);
    }
  }
  function step(r10) {
    r10.value instanceof __await ? Promise.resolve(r10.value.v).then(fulfill, reject) : settle2(q3[0][2], r10);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f9, v22) {
    if (f9(v22), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncValues(o12) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m15 = o12[Symbol.asyncIterator], i23;
  return m15 ? m15.call(o12) : (o12 = typeof __values === "function" ? __values(o12) : o12[Symbol.iterator](), i23 = {}, verb("next"), verb("throw"), verb("return"), i23[Symbol.asyncIterator] = function() {
    return this;
  }, i23);
  function verb(n18) {
    i23[n18] = o12[n18] && function(v22) {
      return new Promise(function(resolve, reject) {
        v22 = o12[n18](v22), settle2(resolve, reject, v22.done, v22.value);
      });
    };
  }
  function settle2(resolve, reject, d18, v22) {
    Promise.resolve(v22).then(function(v23) {
      resolve({ value: v23, done: d18 });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i23) {
      return i23 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a7, e_2, _b4;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a7 = _parentage_1.return)) _a7.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e18) {
          errors = e18 instanceof UnsubscriptionError ? e18.errors : [e18];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b4 = _finalizers_1.return)) _b4.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a7;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a7 = this._finalizers) !== null && _a7 !== void 0 ? _a7 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError2(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a7 = context, errorThrown = _a7.errorThrown, error = _a7.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError2(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity2(x8) {
  return x8;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity2;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a7 = _this, operator = _a7.operator, source = _a7.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a7;
    return (_a7 = this.source) === null || _a7 === void 0 ? void 0 : _a7.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      operations[_i2] = arguments[_i2];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x8) {
        return value = x8;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a7;
  return (_a7 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a7 !== void 0 ? _a7 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a7;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a7 = this.onFinalize) === null || _a7 === void 0 ? void 0 : _a7.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel2 = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel2 = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel2 = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel2 === null || cancel2 === void 0 ? void 0 : cancel2(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a7;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b4 = __values(_this.currentObservers), _c3 = _b4.next(); !_c3.done; _c3 = _b4.next()) {
            var observer = _c3.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c3 && !_c3.done && (_a7 = _b4.return)) _a7.call(_b4);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a7;
      return ((_a7 = this.observers) === null || _a7 === void 0 ? void 0 : _a7.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a7 = this, hasError = _a7.hasError, isStopped = _a7.isStopped, observers = _a7.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a7 = this, hasError = _a7.hasError, thrownError = _a7.thrownError, isStopped = _a7.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a7, _b4;
    (_b4 = (_a7 = this.destination) === null || _a7 === void 0 ? void 0 : _a7.next) === null || _b4 === void 0 ? void 0 : _b4.call(_a7, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a7, _b4;
    (_b4 = (_a7 = this.destination) === null || _a7 === void 0 ? void 0 : _a7.error) === null || _b4 === void 0 ? void 0 : _b4.call(_a7, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a7, _b4;
    (_b4 = (_a7 = this.destination) === null || _a7 === void 0 ? void 0 : _a7.complete) === null || _b4 === void 0 ? void 0 : _b4.call(_a7);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a7, _b4;
    return (_b4 = (_a7 = this.source) === null || _a7 === void 0 ? void 0 : _a7.subscribe(subscriber)) !== null && _b4 !== void 0 ? _b4 : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a7 = this, hasError = _a7.hasError, thrownError = _a7.thrownError, _value = _a7._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a7 = this, isStopped = _a7.isStopped, _buffer = _a7._buffer, _infiniteTimeWindow = _a7._infiniteTimeWindow, _timestampProvider = _a7._timestampProvider, _windowTime = _a7._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a7 = this, _infiniteTimeWindow = _a7._infiniteTimeWindow, _buffer = _a7._buffer;
    var copy = _buffer.slice();
    for (var i23 = 0; i23 < copy.length && !subscriber.closed; i23 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i23]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a7 = this, _bufferSize = _a7._bufferSize, _timestampProvider = _a7._timestampProvider, _buffer = _a7._buffer, _infiniteTimeWindow = _a7._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i23 = 1; i23 < _buffer.length && _buffer[i23] <= now; i23 += 2) {
        last3 = i23;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a7 = this, hasError = _a7.hasError, _hasValue = _a7._hasValue, _value = _a7._value, thrownError = _a7.thrownError, isStopped = _a7.isStopped, _isComplete = _a7._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a7 = this, _hasValue = _a7._hasValue, _value = _a7._value, _isComplete = _a7._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a7;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a7 = this.id) !== null && _a7 !== void 0 ? _a7 : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e18) {
      errored = true;
      errorValue = e18 ? e18 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a7 = this, id = _a7.id, scheduler = _a7.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate2 = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a7;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a7 = actions[actions.length - 1]) === null || _a7 === void 0 ? void 0 : _a7.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a7;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a7 = actions[actions.length - 1]) === null || _a7 === void 0 ? void 0 : _a7.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a7 = this, actions = _a7.actions, maxFrames = _a7.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a24, b6) {
    if (a24.delay === b6.delay) {
      if (a24.index === b6.index) {
        return 0;
      } else if (a24.index > b6.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a24.delay > b6.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x8) {
  return x8 && typeof x8.length === "number" && typeof x8 !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a7, value, done;
    return __generator(this, function(_b4) {
      switch (_b4.label) {
        case 0:
          reader = readableStream.getReader();
          _b4.label = 1;
        case 1:
          _b4.trys.push([1, , 9, 10]);
          _b4.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a7 = _b4.sent(), value = _a7.value, done = _a7.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b4.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b4.sent()];
        case 7:
          _b4.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise2(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i23 = 0; i23 < array.length && !subscriber.closed; i23++) {
      subscriber.next(array[i23]);
    }
    subscriber.complete();
  });
}
function fromPromise2(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError2);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a7;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a7 = iterable_1.return)) _a7.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a7;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b4) {
      switch (_b4.label) {
        case 0:
          _b4.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b4.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b4.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b4.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b4.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b4.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a7 = asyncIterable_1.return))) return [3, 8];
          return [4, _a7.call(asyncIterable_1)];
        case 7:
          _b4.sent();
          _b4.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i23 = 0;
    return scheduler.schedule(function() {
      if (i23 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i23++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator3;
    executeSchedule(subscriber, scheduler, function() {
      iterator3 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a7;
        var value;
        var done;
        try {
          _a7 = iterator3.next(), value = _a7.value, done = _a7.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator3 === null || iterator3 === void 0 ? void 0 : iterator3.return) && iterator3.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator3 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator3.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a7 = this, kind = _a7.kind, value = _a7.value, error = _a7.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a7;
    return isFunction((_a7 = nextOrObserver) === null || _a7 === void 0 ? void 0 : _a7.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a7 = this, kind = _a7.kind, value = _a7.value, error = _a7.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a7, _b4, _c3;
  var _d3 = notification, kind = _d3.kind, value = _d3.value, error = _d3.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a7 = observer.next) === null || _a7 === void 0 ? void 0 : _a7.call(observer, value) : kind === "E" ? (_b4 = observer.error) === null || _b4 === void 0 ? void 0 : _b4.call(observer, error) : (_c3 = observer.complete) === null || _c3 === void 0 ? void 0 : _c3.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});
function timeout(config2, schedulerArg) {
  var _a7 = isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a7.first, each = _a7.each, _b4 = _a7.with, _with = _b4 === void 0 ? timeoutErrorFactory : _b4, _c3 = _a7.scheduler, scheduler = _c3 === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c3, _d3 = _a7.meta, meta = _d3 === void 0 ? null : _d3;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay2) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay2);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray2 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray3 = Array.isArray;
var objectProto = Object.prototype;

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a24, i23) {
      return map(function(b6, ii) {
        return resultSelector(a24, b6, i23, ii);
      })(innerFrom(project(a24, i23)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity2, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n18 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n18++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer(period, period, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray4 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i23 = index++;
      state = hasState ? accumulator(state, value, i23) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a7 = options.connector, connector = _a7 === void 0 ? function() {
    return new Subject();
  } : _a7, _b4 = options.resetOnError, resetOnError = _b4 === void 0 ? true : _b4, _c3 = options.resetOnComplete, resetOnComplete = _c3 === void 0 ? true : _c3, _d3 = options.resetOnRefCountZero, resetOnRefCountZero = _d3 === void 0 ? true : _d3;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/xstate-utils/XStateDeviceAction.js
var E3 = class {
  constructor(e18) {
    __publicField(this, "input");
    __publicField(this, "inspect", false);
    this.input = e18.input, this.inspect = !!e18.inspect;
  }
  _execute(e18) {
    const n18 = this.makeStateMachine(e18);
    return this._subscribeToStateMachine(n18);
  }
  _subscribeToStateMachine(e18) {
    const n18 = createActor(e18, { input: this.input }), t23 = new ReplaySubject(), o12 = (r10) => {
      const { context: i23, status: p30, output: l19, error: m15 } = r10;
      switch (p30) {
        case "active":
          t23.next({ status: t3.Pending, intermediateValue: i23.intermediateValue });
          break;
        case "done":
          l19.caseOf({ Left: (c21) => {
            t23.next({ status: t3.Error, error: c21 });
          }, Right: (c21) => {
            t23.next({ status: t3.Completed, output: c21 });
          } }), t23.complete();
          break;
        case "error":
          t23.error(m15), t23.complete();
          break;
        case "stopped":
          t23.next({ status: t3.Stopped }), t23.complete();
          break;
        default:
          this._exhaustiveMatchingGuard(p30);
      }
    }, s25 = new Observable((r10) => {
      const i23 = t23.subscribe(r10);
      return () => {
        u14.unsubscribe(), i23.unsubscribe(), n18.stop();
      };
    }), u14 = n18.subscribe(o12);
    return n18.start(), { observable: s25.pipe(share()), cancel: () => {
      n18.stop(), u14.unsubscribe(), o12(n18.getSnapshot());
    } };
  }
  _exhaustiveMatchingGuard(e18) {
    throw console.log("_exhaustiveMatchingGuard status", e18), new Error(`Unhandled status: ${e18}`);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/DeviceSessionState.js
var a6 = ((e18) => (e18[e18.Connected = 0] = "Connected", e18[e18.ReadyWithoutSecureChannel = 1] = "ReadyWithoutSecureChannel", e18[e18.ReadyWithSecureChannel = 2] = "ReadyWithSecureChannel", e18))(a6 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction.js
var z = class extends E3 {
  makeStateMachine(n18) {
    const { getAppAndVersion: p30, getDeviceSessionState: c21, setDeviceSessionState: i23, waitForDeviceUnlock: o12, isDeviceOnboarded: d18 } = this.extractDependencies(n18), l19 = this.input.unlockTimeout ?? T;
    return setup({ types: { input: { unlockTimeout: l19 }, context: {}, output: {} }, actors: { getAppAndVersion: fromPromise(p30), waitForDeviceUnlock: fromObservable(o12) }, guards: { isDeviceOnboarded: () => d18(), isDeviceLocked: ({ context: e18 }) => e18._internalState.locked, hasError: ({ context: e18 }) => e18._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: new n3() }) }), assignErrorDeviceLocked: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: new e3() }), intermediateValue: { requiredUserInteraction: s8.UnlockDevice } }), assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }), assignNoUserActionNeeded: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), assignUserActionUnlockNeeded: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.UnlockDevice }) }) } }).createMachine({ id: "GetDeviceStatusDeviceAction", initial: "DeviceReady", context: (e18) => {
      const t23 = c21(), { sessionStateType: a24 } = t23;
      return { input: { unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { onboarded: false, locked: false, currentApp: a24 === a6.ReadyWithoutSecureChannel ? t23.currentApp.name : null, currentAppVersion: null, error: null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ guard: { type: "isDeviceOnboarded" }, target: "AppAndVersionCheck", actions: assign({ _internalState: (e18) => ({ ...e18.context._internalState, onboarded: true }) }) }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, UserActionUnlockDevice: { entry: "assignUserActionUnlockNeeded", exit: "assignNoUserActionNeeded", invoke: { id: "UserActionUnlockDevice", src: "waitForDeviceUnlock", input: (e18) => ({ unlockTimeout: l19 }), onDone: { target: "AppAndVersionCheck", actions: assign({ _internalState: (e18) => ({ ...e18.context._internalState, locked: false }) }) }, onError: { target: "Error", actions: "assignErrorDeviceLocked" } } }, AppAndVersionCheck: { invoke: { src: "getAppAndVersion", onDone: { target: "ApplicationAvailableResultCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const t23 = c21();
        return t23.sessionStateType !== a6.Connected ? i23({ ...t23, currentApp: e18.event.output.data }) : i23({ deviceModelId: t23.deviceModelId, sessionStateType: a6.ReadyWithoutSecureChannel, deviceStatus: E.CONNECTED, currentApp: e18.event.output.data, installedApps: [], isSecureConnectionAllowed: false }), { ...e18.context._internalState, locked: false, currentApp: e18.event.output.data.name, currentAppVersion: e18.event.output.data.version };
      }
      if ("errorCode" in e18.event.output.error) {
        if (e18.event.output.error.errorCode === "5515") return { ...e18.context._internalState, locked: true };
        if (e18.event.output.error.errorCode === "6e00") return { ...e18.context._internalState, locked: false, currentApp: "BOLOS", currentAppVersion: "0.0.0" };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ApplicationAvailableResultCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "UserActionUnlockDevice", guard: "isDeviceLocked" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => {
      const { context: t23 } = e18, { error: a24, currentApp: v22, currentAppVersion: A11 } = t23._internalState;
      return a24 ? left(a24) : right({ currentApp: v22, currentAppVersion: A11 });
    } });
  }
  extractDependencies(n18) {
    return { getAppAndVersion: () => n18.sendCommand(new R()), waitForDeviceUnlock: ({ input: i23 }) => interval(1e3).pipe(switchMap(() => from(n18.sendCommand(new R()))), mergeMap((o12) => !s5(o12) && "errorCode" in o12.error && o12.error.errorCode === "5515" ? EMPTY : of(void 0)), take(1), timeout(i23.unlockTimeout)), getDeviceSessionState: () => n18.getDeviceSessionState(), setDeviceSessionState: (i23) => n18.setDeviceSessionState(i23), isDeviceOnboarded: () => true };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/transport/model/Errors.js
var n4 = class {
  constructor(e18) {
    __publicField(this, "_tag", "GeneralDmkError");
    __publicField(this, "originalError");
    e18 instanceof Error ? this.originalError = e18 : e18 !== void 0 && (this.originalError = new Error(String(e18)));
  }
};
var t5 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DeviceAlreadyDiscoveredError");
    this.err = r10;
  }
};
var s10 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DeviceNotRecognizedError");
    this.err = r10;
  }
};
var d2 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "NoAccessibleDeviceError");
    this.err = r10;
  }
};
var c3 = class extends n4 {
  constructor(e18) {
    super(e18);
    __publicField(this, "_tag", "ConnectionOpeningError");
  }
};
var a7 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "UnknownDeviceError");
    this.err = r10;
  }
};
var i8 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "TransportNotSupportedError");
    this.err = r10;
  }
};
var l5 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "SendApduConcurrencyError");
    this.err = r10;
  }
};
var u3 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "SendApduTimeoutError");
    this.err = r10;
  }
};
var p3 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "SendApduEmptyResponseError");
    this.err = r10;
  }
};
var E4 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DisconnectError");
    this.err = r10;
  }
};
var y = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "ReconnectionFailedError");
    this.err = r10;
  }
};
var x2 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DeviceNotInitializedError");
    this.err = r10;
  }
};
var v = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "NoTransportsProvidedError");
    this.err = r10;
  }
};
var g3 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "TransportAlreadyExistsError");
    this.err = r10;
  }
};
var k2 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DeviceDisconnectedWhileSendingError");
    this.err = r10;
  }
};
var D = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "AlreadySendingApduError");
    this.err = r10;
  }
};
var w = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "DeviceDisconnectedBeforeSendingApdu");
    this.err = r10;
  }
};
var A3 = class extends n4 {
  constructor(r10) {
    super(r10);
    __publicField(this, "_tag", "NoTransportProvidedError");
    this.err = r10;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/utils/AppName.js
var s11 = ["BOLOS", "OLOS", "OLOS\0"];
var S2 = (O4) => s11.includes(O4);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction.js
var W = class extends E3 {
  makeStateMachine(r10) {
    const { closeApp: o12, openApp: s25, getDeviceSessionState: a24, isDeviceOnboarded: A11, setDeviceSessionState: d18 } = this.extractDependencies(r10), S13 = this.input.unlockTimeout ?? T, m15 = new z({ input: { unlockTimeout: S13 } }).makeStateMachine(r10);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { closeApp: fromPromise(o12), openApp: fromPromise(s25), getDeviceStatus: m15 }, guards: { isDeviceOnboarded: () => A11(), isRequestedAppOpen: ({ context: e18 }) => e18._internalState.currentlyRunningApp === null ? false : e18._internalState.currentlyRunningApp === e18.input.appName, isDashboardOpen: ({ context: e18 }) => {
      if (e18._internalState.currentlyRunningApp === null) throw new Error("context.currentlyRunningApp === null");
      return S2(e18._internalState.currentlyRunningApp);
    }, hasDisconnectedWhileSending: ({ context: e18 }) => e18._internalState.error !== null && e18._internalState.error instanceof k2, hasError: ({ context: e18 }) => e18._internalState.error !== null }, actions: { assignErrorDeviceNotOnboarded: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: new n3() }) }), assignUserActionNeededOpenApp: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.ConfirmOpenApp }) }), assignNoUserActionNeeded: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }), assignNoError: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: null }) }) } }).createMachine({ id: "OpenAppDeviceAction", initial: "DeviceReady", context: ({ input: e18 }) => {
      const n18 = a24(), { sessionStateType: p30 } = n18;
      return { input: e18, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, currentlyRunningApp: p30 === a6.ReadyWithoutSecureChannel ? n18.currentApp.name : null } };
    }, states: { DeviceReady: { always: { target: "OnboardingCheck" } }, OnboardingCheck: { always: [{ target: "GetDeviceStatus", guard: { type: "isDeviceOnboarded" } }, { target: "Error", actions: "assignErrorDeviceNotOnboarded" }] }, GetDeviceStatus: { invoke: { id: "deviceStatus", src: "getDeviceStatus", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { target: "CheckDeviceStatus", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (n18) => {
      const p30 = a24();
      return p30.sessionStateType !== a6.Connected && d18({ ...p30, currentApp: { name: n18.currentApp, version: n18.currentAppVersion } }), { ...e18.context._internalState, currentlyRunningApp: n18.currentApp };
    }, Left: (n18) => ({ ...e18.context._internalState, currentlyRunningApp: null, error: n18 }) }) }) }, onError: { target: "Error", actions: [assign({ _internalState: (e18) => ({ ...e18.context._internalState, currentlyRunningApp: null }) }), "assignErrorFromEvent"] } } }, CheckDeviceStatus: { always: [{ target: "ApplicationReady", guard: "isRequestedAppOpen", actions: "assignNoError" }, { target: "Error", guard: "hasError" }, { target: "DashboardCheck" }] }, DashboardCheck: { always: [{ target: "OpenApplication", guard: "isDashboardOpen" }, "CloseApplication"] }, OpenApplication: { entry: "assignUserActionNeededOpenApp", exit: "assignNoUserActionNeeded", invoke: { src: "openApp", input: ({ context: e18 }) => ({ appName: e18.input.appName }), onDone: { target: "OpenApplicationResultCheck", actions: assign({ _internalState: (e18) => s5(e18.event.output) ? { ...e18.context._internalState, currentlyRunningApp: e18.context.input.appName } : { ...e18.context._internalState, error: e18.event.output.error } }) }, onError: { target: "OpenApplicationResultCheck", actions: "assignErrorFromEvent" } } }, OpenApplicationResultCheck: { always: [{ target: "GetDeviceStatus", guard: "hasDisconnectedWhileSending" }, { target: "Error", guard: "hasError" }, { target: "GetDeviceStatus" }] }, CloseApplication: { invoke: { src: "closeApp", onDone: { target: "CloseApplicationResultCheck", actions: assign({ _internalState: (e18) => s5(e18.event.output) ? { ...e18.context._internalState, currentlyRunningApp: "BOLOS" } : { ...e18.context._internalState, error: e18.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CloseApplicationResultCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "OpenApplication" }] }, ApplicationReady: { always: "Success" }, Success: { type: "final", actions: "assignNoError" }, Error: { type: "final" } }, output: ({ context: e18 }) => e18._internalState.error ? left(e18._internalState.error) : right(void 0) });
  }
  extractDependencies(r10) {
    return { closeApp: async () => r10.sendCommand(new i4()), openApp: async (a24) => r10.sendCommand(new f2({ appName: a24.input.appName })), getDeviceSessionState: () => r10.getDeviceSessionState(), setDeviceSessionState: (a24) => r10.setDeviceSessionState(a24), isDeviceOnboarded: () => true };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/CallTaskInAppDeviceAction/CallTaskInAppDeviceAction.js
var R2 = class extends E3 {
  makeStateMachine(a24) {
    const { callTask: r10 } = this.extractDependencies(a24);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { callTask: fromPromise(r10), openAppStateMachine: new W({ input: { appName: this.input.appName } }).makeStateMachine(a24) }, guards: { skipOpenApp: () => this.input.skipOpenApp, noInternalError: ({ context: e18 }) => e18._internalState.error === null }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "CallTaskInAppDeviceAction", initial: "InitialState", context: ({ input: e18 }) => ({ input: e18, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { taskResponse: null, error: null } }), states: { InitialState: { always: [{ target: "CallTask", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: this.input.appName }, src: "openAppStateMachine", onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (n18) => ({ ...e18.context._internalState, error: n18 }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "CallTask", guard: "noInternalError" }, "Error"] }, CallTask: { entry: assign({ intermediateValue: { requiredUserInteraction: this.input.requiredUserInteraction } }), exit: assign({ intermediateValue: { requiredUserInteraction: s8.None } }), invoke: { id: "callTask", src: "callTask", input: (e18) => e18.context.input.task, onDone: { target: "CallTaskResultCheck", actions: [assign({ _internalState: ({ event: e18, context: n18 }) => s5(e18.output) ? { ...n18._internalState, taskResponse: e18.output.data } : { ...n18._internalState, error: e18.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CallTaskResultCheck: { always: [{ target: "Success", guard: "noInternalError" }, "Error"] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: e18 }) => e18._internalState.taskResponse ? right(e18._internalState.taskResponse) : left(e18._internalState.error || new s9("No error in final state")) });
  }
  extractDependencies(a24) {
    return { callTask: (r10) => r10.input(a24) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/GoToDashboard/GoToDashboardDeviceAction.js
var L = class extends E3 {
  makeStateMachine(r10) {
    const { getDeviceSessionState: o12, setDeviceSessionState: s25, closeApp: a24, getAppAndVersion: u14 } = this.extractDependencies(r10), i23 = this.input.unlockTimeout ?? T, d18 = new z({ input: { unlockTimeout: i23 } }).makeStateMachine(r10);
    return setup({ types: { input: { unlockTimeout: i23 }, context: {}, output: {} }, actors: { getAppAndVersion: fromPromise(u14), closeApp: fromPromise(a24), getDeviceStatus: d18 }, guards: { hasError: ({ context: e18 }) => e18._internalState.error !== null, isDashboardOpen: ({ context: e18 }) => e18._internalState.currentApp !== null && S2(e18._internalState.currentApp) }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "GoToDashboardDeviceAction", initial: "DeviceReady", context: (e18) => {
      const t23 = o12();
      return { input: { unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { currentApp: "currentApp" in t23 ? t23.currentApp.name : null, error: null } };
    }, states: { DeviceReady: { always: { target: "GetDeviceStatus" } }, GetDeviceStatus: { invoke: { id: "deviceStatus", src: "getDeviceStatus", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { target: "CheckDeviceStatus", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, currentApp: t23.currentApp }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) } } }, CheckDeviceStatus: { always: [{ target: "Error", guard: "hasError" }, { target: "DashboardCheck" }] }, DashboardCheck: { always: [{ target: "Success", guard: "isDashboardOpen" }, { target: "Error", guard: "hasError" }, { target: "Error", guard: (e18) => e18.context._internalState.currentApp === null, actions: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: new s9("currentApp === null") }) }) }, { target: "CloseApp" }] }, CloseApp: { invoke: { src: "closeApp", onDone: { target: "CloseAppCheck", actions: assign({ _internalState: (e18) => s5(e18.event.output) ? e18.context._internalState : { ...e18.context._internalState, error: e18.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, CloseAppCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetAppAndVersion", reenter: true }] }, GetAppAndVersion: { invoke: { src: "getAppAndVersion", onDone: { target: "DashboardCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const t23 = o12();
        return t23.sessionStateType !== a6.Connected && s25({ ...t23, currentApp: e18.event.output.data }), { ...e18.context._internalState, currentApp: e18.event.output.data.name };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) } } }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => e18.context._internalState.error ? left(e18.context._internalState.error) : right(void 0) });
  }
  extractDependencies(r10) {
    return { closeApp: async () => r10.sendCommand(new i4()), getAppAndVersion: async () => r10.sendCommand(new R()), getDeviceSessionState: () => r10.getDeviceSessionState(), setDeviceSessionState: (a24) => r10.setDeviceSessionState(a24) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/ListApps/ListAppsDeviceAction.js
var I = class extends E3 {
  makeStateMachine(n18) {
    const { listApps: s25 } = this.extractDependencies(n18), r10 = this.input.unlockTimeout ?? T, o12 = new L({ input: { unlockTimeout: r10 } }).makeStateMachine(n18);
    return setup({ types: { input: { unlockTimeout: r10 }, context: {}, output: {} }, actors: { listApps: fromPromise(s25), goToDashboard: o12 }, guards: { hasError: ({ context: t23 }) => t23._internalState.error !== null, hasMoreApps: (t23) => t23.context._internalState.shouldContinue }, actions: { assignAllowListApps: assign({ intermediateValue: (t23) => ({ requiredUserInteraction: s8.AllowListApps }) }), assignErrorFromEvent: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: t23.event.error }) }) } }).createMachine({ id: "ListAppsDeviceAction", initial: "DeviceReady", context: (t23) => ({ input: { unlockTimeout: t23.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, apps: [], shouldContinue: false } }), states: { DeviceReady: { always: { target: "GoToDashboard" } }, GoToDashboard: { invoke: { id: "dashboard", src: "goToDashboard", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => t23.event.snapshot.context.intermediateValue }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: () => t23.context._internalState, Left: (p30) => ({ ...t23.context._internalState, error: p30 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "ListApps" }] }, ListApps: { entry: "assignAllowListApps", invoke: { src: "listApps", input: (t23) => false, onDone: { target: "Continue", actions: assign({ _internalState: (t23) => s5(t23.event.output) ? { ...t23.context._internalState, apps: t23.context._internalState.apps.concat(t23.event.output.data), shouldContinue: t23.event.output.data.length >= 2 } : { ...t23.context._internalState, error: t23.event.output.error }, intermediateValue: (t23) => ({ ...t23.context.intermediateValue, requiredUserInteraction: s8.None }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListAppsCheck: { always: [{ target: "Error", guard: "hasError" }, "ListAppsContinue"] }, ListAppsContinue: { invoke: { src: "listApps", input: (t23) => true, onDone: { target: "Continue", actions: assign({ _internalState: (t23) => s5(t23.event.output) ? { ...t23.context._internalState, apps: t23.context._internalState.apps.concat(t23.event.output.data), shouldContinue: t23.event.output.data.length >= 2 } : { ...t23.context._internalState, error: t23.event.output.error } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Continue: { always: [{ target: "ListAppsContinue", guard: "hasMoreApps" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (t23) => t23.context._internalState.error ? left(t23.context._internalState.error) : right(t23.context._internalState.apps) });
  }
  extractDependencies(n18) {
    return { listApps: async ({ input: r10 }) => {
      const o12 = new S({ isContinue: r10 });
      return n18.sendCommand(o12);
    } };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/task/GetApplicationsMetadataTask.js
var import_semver2 = __toESM(require_semver2());

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/ListLanguagePackCommand.js
var i9 = { "662d": { message: "Invalid LIST_ARG, first command must be sent with P1_LIST_LANGUAGE_PACKS_FIRST." } };
var A4 = class extends s6 {
  constructor({ message: r10, errorCode: e18 }) {
    super({ message: r10, errorCode: e18, tag: "ListLanguagePackCommandError" });
  }
};
var _ = class {
  constructor(r10) {
    __publicField(this, "name", "listLanguagePack");
    this.args = r10;
  }
  getApdu() {
    const r10 = { cla: 224, ins: 52, p1: this.args.firstChunk ? 0 : 1, p2: 0 };
    return new A(r10).build();
  }
  parseResponse(r10) {
    const e18 = new i2(r10);
    if (!e2.isSuccessResponse(r10)) {
      const o12 = e18.encodeToHexaString(r10.statusCode);
      return o3(o12, i9) ? o2({ error: new A4({ ...i9[o12], errorCode: o12 }) }) : o2({ error: p.handle(r10) });
    }
    if (e18.extract8BitUInt() === void 0) return o2({ data: void 0 });
    e18.extract8BitUInt();
    const t23 = e18.extractFieldLVEncoded();
    if (t23 === void 0) return o2({ error: new a("Failed to get language pack id") });
    const n18 = e18.extractFieldLVEncoded();
    if (n18 === void 0) return o2({ error: new a("Failed to get language pack size") });
    const u14 = parseInt(o(t23), 16), g23 = parseInt(o(n18), 16);
    return o2({ data: { id: u14, size: g23 } });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/task/GetApplicationsMetadataTask.js
var w2 = "0000000000000000000000000000000000000000000000000000000000000000";
var M = class {
  constructor(e18, n18) {
    this.api = e18;
    this.args = n18;
  }
  async run() {
    const e18 = this.args.installedApps.filter((a24) => this.isApplication(a24)), n18 = this.api.getManagerApiService(), u14 = e18.map((a24) => a24.hash), l19 = await n18.getAppsByHash(u14).chain((a24) => n18.getAppList(this.args.firmwareVersion.metadata).map((t23) => ({ applications: a24, catalog: t23 })));
    if (l19.isLeft()) return o2({ error: new a("Cannot get the application catalog") });
    const { applications: c21, catalog: s25 } = l19.unsafeCoerce(), A11 = c21.reduce((a24, t23, i23) => {
      if (t23 !== null) return [...a24, t23];
      const o12 = e18[i23], d18 = s25.find((h5) => h5.versionName === o12.name);
      return d18 ? [...a24, d18] : a24;
    }, []), f9 = c21.filter((a24) => a24 !== null).reduce((a24, t23) => {
      const i23 = s25.find((o12) => o12.versionName === t23.versionName);
      return i23 && (0, import_semver2.gt)(i23.version, t23.version) ? [...a24, i23] : a24;
    }, []);
    let r10 = [];
    for (let a24 = 0; ; a24++) {
      const t23 = await this.api.sendCommand(new _({ firstChunk: a24 === 0 }));
      if (!s5(t23) || t23.data === void 0) break;
      r10 = [...r10, t23.data];
    }
    const g23 = await n18.getLanguagePackages(this.args.deviceVersion, this.args.firmware);
    return g23.isRight() ? o2({ data: { applications: A11, applicationsUpdates: f9, installedLanguages: r10, catalog: { applications: s25, languagePackages: g23.extract() } } }) : o2({ error: new a("Cannot get the languages catalog") });
  }
  isApplication(e18) {
    return e18.hashCode !== w2;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/os/GetCustomImageSizeCommand.js
var s12 = { "662e": { message: "Invalid state, no background image loaded." }, "662f": { message: "Invalid state, device is in recovery mode." } };
var l6 = class extends s6 {
  constructor({ message: e18, errorCode: r10 }) {
    super({ message: e18, errorCode: r10, tag: "GetCustomImageSizeCommandError" });
  }
};
var y2 = class {
  constructor() {
    __publicField(this, "name", "getCustomImageSize");
  }
  getApdu() {
    const e18 = { cla: 224, ins: 100, p1: 0, p2: 0 };
    return new A(e18).build();
  }
  parseResponse(e18) {
    const r10 = new i2(e18);
    if (!e2.isSuccessResponse(e18)) {
      const m15 = r10.encodeToHexaString(e18.statusCode);
      return o3(m15, s12) ? o2({ error: new l6({ ...s12[m15], errorCode: m15 }) }) : o2({ error: p.handle(e18) });
    }
    const t23 = r10.extract32BitUInt();
    return t23 === void 0 ? o2({ error: new a("Didn't receive any size") }) : o2({ data: t23 });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/task/GetFirmwareMetadataTask.js
var R3 = class {
  constructor(e18) {
    this.api = e18;
  }
  async run() {
    const e18 = await this.api.sendCommand(new P());
    if (!s5(e18)) return e18;
    const m15 = { mcu: e18.data.mcuSephVersion, bootloader: e18.data.mcuBootloaderVersion, os: e18.data.seVersion, metadata: e18.data }, r10 = this.api.getManagerApiService(), n18 = await r10.getDeviceVersion(e18.data).chain((a24) => r10.getFirmwareVersion(e18.data, a24).map((i23) => ({ deviceVersion: a24, currentFirmware: i23 })));
    if (n18.isLeft()) return o2({ error: new s4() });
    const { deviceVersion: s25, currentFirmware: o12 } = n18.unsafeCoerce(), w8 = (await r10.getLatestFirmwareVersion(o12, s25).chain((a24) => r10.getNextFirmwareVersion(a24).chain((i23) => r10.getMcuList().map((t23) => t23.find((l19) => l19.name === m15.mcu)).map((t23) => t23 === void 0 || !i23.mcuVersions.includes(t23.id)).map((t23) => ({ osuFirmware: a24, finalFirmware: i23, mcuUpdateRequired: t23 }))))).caseOf({ Right: (a24) => a24, Left: (a24) => {
    } }), f9 = { currentFirmware: o12, availableUpdate: w8 };
    let d18 = {};
    const p30 = await this.api.sendCommand(new y2());
    return s5(p30) && (d18 = { size: p30.data }), o2({ data: { deviceVersion: s25, firmware: o12, firmwareVersion: m15, firmwareUpdateContext: f9, customImage: d18 } });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/device-action/ListInstalledApps/types.js
function t6(r10) {
  return Array.isArray(r10) && r10.every((e18) => typeof e18 == "object" && e18 !== null && "flags" in e18 && "hash" in e18 && "hash_code_data" in e18 && "name" in e18 && typeof e18.flags == "number" && typeof e18.hash == "string" && typeof e18.hash_code_data == "string" && typeof e18.name == "string");
}

// node_modules/isomorphic-ws/browser.js
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof global !== "undefined") {
  ws = global.WebSocket || global.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser_default = ws;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/task/types.js
var t7 = ((r10) => (r10.GenuineCheck = "GenuineCheck", r10.ListInstalledApps = "ListInstalledApps", r10.UpdateMcu = "UpdateMcu", r10.UpdateFirmware = "UpdateFirmware", r10.InstallApp = "InstallApp", r10.UninstallApp = "UninstallApp", r10))(t7 || {});
var s13 = ((n18) => (n18.EXCHANGE = "exchange", n18.BULK = "bulk", n18.ERROR = "error", n18.WARNING = "warning", n18.SUCCESS = "success", n18))(s13 || {});
var p4 = ((a24) => (a24.SUCCESS = "success", a24.ERROR = "error", a24))(p4 || {});
var o5 = ((e18) => (e18.Opened = "opened", e18.Closed = "closed", e18.PermissionRequested = "permission-requested", e18.PermissionGranted = "permission-granted", e18.PreExchange = "pre-exchange", e18.Exchange = "exchange", e18.DeviceId = "device-id", e18.Progress = "progress", e18.Warning = "warning", e18.Error = "error", e18.Result = "result", e18))(o5 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/constants.js
var E5 = "0000";

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/utils.js
function c4(e18) {
  return e18[0] === 224 && e18[1] === 81;
}
function a8(e18) {
  return e18[0] === 224 && e18[1] === 82;
}
function p5(e18) {
  try {
    const r10 = new i2(e18);
    return r10.extractFieldLVEncoded() ? r10.extractFieldLVEncoded() ?? null : null;
  } catch {
    return null;
  }
}
function s14(e18) {
  return e18 === E5;
}

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n18, le2 = false) {
  if (le2)
    return { h: Number(n18 & U32_MASK64), l: Number(n18 >> _32n & U32_MASK64) };
  return { h: Number(n18 >> _32n & U32_MASK64) | 0, l: Number(n18 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i23 = 0; i23 < len; i23++) {
    const { h: h5, l: l19 } = fromBig(lst[i23], le2);
    [Ah[i23], Al[i23]] = [h5, l19];
  }
  return [Ah, Al];
}
var rotlSH = (h5, l19, s25) => h5 << s25 | l19 >>> 32 - s25;
var rotlSL = (h5, l19, s25) => l19 << s25 | h5 >>> 32 - s25;
var rotlBH = (h5, l19, s25) => l19 << s25 - 32 | h5 >>> 64 - s25;
var rotlBL = (h5, l19, s25) => h5 << s25 - 32 | l19 >>> 64 - s25;

// node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes(a24) {
  return a24 instanceof Uint8Array || ArrayBuffer.isView(a24) && a24.constructor.name === "Uint8Array";
}
function anumber(n18) {
  if (!Number.isSafeInteger(n18) || n18 < 0)
    throw new Error("positive integer expected, got " + n18);
}
function abytes(b6, ...lengths) {
  if (!isBytes(b6))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b6.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b6.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
  for (let i23 = 0; i23 < arrays.length; i23++) {
    arrays[i23].fill(0);
  }
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i23 = 0; i23 < arr.length; i23++) {
    arr[i23] = byteSwap(arr[i23]);
  }
  return arr;
}
var swap32IfBE = isLE ? (u14) => u14 : byteSwap32;
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_6, i23) => i23.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function createXOFer(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/@noble/hashes/esm/sha3.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R6 = _1n, x8 = 1, y6 = 0; round < 24; round++) {
  [x8, y6] = [y6, (2 * x8 + 3 * y6) % 5];
  SHA3_PI.push(2 * (5 * y6 + x8));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t23 = _0n;
  for (let j4 = 0; j4 < 7; j4++) {
    R6 = (R6 << _1n ^ (R6 >> _7n) * _0x71n) % _256n;
    if (R6 & _2n)
      t23 ^= _1n << (_1n << BigInt(j4)) - _1n;
  }
  _SHA3_IOTA.push(t23);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h5, l19, s25) => s25 > 32 ? rotlBH(h5, l19, s25) : rotlSH(h5, l19, s25);
var rotlL = (h5, l19, s25) => s25 > 32 ? rotlBL(h5, l19, s25) : rotlSL(h5, l19, s25);
function keccakP(s25, rounds = 24) {
  const B3 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x8 = 0; x8 < 10; x8++)
      B3[x8] = s25[x8] ^ s25[x8 + 10] ^ s25[x8 + 20] ^ s25[x8 + 30] ^ s25[x8 + 40];
    for (let x8 = 0; x8 < 10; x8 += 2) {
      const idx1 = (x8 + 8) % 10;
      const idx0 = (x8 + 2) % 10;
      const B0 = B3[idx0];
      const B1 = B3[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B3[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B3[idx1 + 1];
      for (let y6 = 0; y6 < 50; y6 += 10) {
        s25[x8 + y6] ^= Th;
        s25[x8 + y6 + 1] ^= Tl;
      }
    }
    let curH = s25[2];
    let curL = s25[3];
    for (let t23 = 0; t23 < 24; t23++) {
      const shift = SHA3_ROTL[t23];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t23];
      curH = s25[PI];
      curL = s25[PI + 1];
      s25[PI] = Th;
      s25[PI + 1] = Tl;
    }
    for (let y6 = 0; y6 < 50; y6 += 10) {
      for (let x8 = 0; x8 < 10; x8++)
        B3[x8] = s25[y6 + x8];
      for (let x8 = 0; x8 < 10; x8++)
        s25[y6 + x8] ^= ~B3[(x8 + 2) % 10] & B3[(x8 + 4) % 10];
    }
    s25[0] ^= SHA3_IOTA_H[round];
    s25[1] ^= SHA3_IOTA_L[round];
  }
  clean(B3);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    this.enableXOF = false;
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen);
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      for (let i23 = 0; i23 < take2; i23++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take2 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take2), pos);
      this.posOut += take2;
      pos += take2;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = (() => gen(6, 144, 224 / 8))();
var sha3_256 = (() => gen(6, 136, 256 / 8))();
var sha3_384 = (() => gen(6, 104, 384 / 8))();
var sha3_512 = (() => gen(6, 72, 512 / 8))();
var keccak_224 = (() => gen(1, 144, 224 / 8))();
var keccak_256 = (() => gen(1, 136, 256 / 8))();
var keccak_384 = (() => gen(1, 104, 384 / 8))();
var keccak_512 = (() => gen(1, 72, 512 / 8))();
var genShake = (suffix, blockLen, outputLen) => createXOFer((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = (() => genShake(31, 168, 128 / 8))();
var shake256 = (() => genShake(31, 136, 256 / 8))();

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/crypto/NobleCryptoService.js
var i10 = class {
  sha3_256(r10) {
    return sha3_256(r10);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/model/Errors.js
var a9 = ((r10) => (r10[r10.AppAlreadyInstalled = 0] = "AppAlreadyInstalled", r10[r10.DeviceLocked = 1] = "DeviceLocked", r10[r10.OutOfMemory = 2] = "OutOfMemory", r10[r10.RefusedByUser = 3] = "RefusedByUser", r10[r10.Unknown = 4] = "Unknown", r10))(a9 || {});
var i11 = class {
  constructor(e18) {
    __publicField(this, "_tag", "WebSocketConnectionError");
    __publicField(this, "originalError");
    this.error = e18;
    this.originalError = e18;
  }
};
var E6 = class {
  constructor(e18, c21 = 4) {
    __publicField(this, "_tag", "SecureChannelError");
    __publicField(this, "originalError");
    this.error = e18;
    this.errorType = c21;
    this.originalError = e18;
  }
  mapDAErrors() {
    switch (this.errorType) {
      case 1:
        return new e3();
      case 3:
        return new i7();
      default:
        return this;
    }
  }
  mapInstallDAErrors() {
    switch (this.errorType) {
      case 1:
        return new e3();
      case 3:
        return new i7();
      case 0:
        return new a5();
      case 2:
        return new l4();
      default:
        return this;
    }
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/task/ConnectToSecureChannelTask.js
var j = class {
  constructor(n18, c21) {
    __publicField(this, "_connection");
    __publicField(this, "_cryptoService");
    __publicField(this, "_deviceIdCaptured", false);
    this._api = n18;
    this._args = c21;
    if (this._args.connection.isRight()) this._connection = this._args.connection.extract();
    else throw new E6(`Invalid WebSocket connection: ${String(this._args.connection.extract())}`);
    this._cryptoService = this._args.cryptoService ?? new i10();
  }
  run() {
    const n18 = this._api.disableRefresher("connectToSecureChannel");
    return new Observable((t23) => {
      let g23 = false, l19 = false, v22 = false;
      const a24 = (f9) => {
        t23.next({ type: o5.Error, error: f9 }), t23.complete(), l19 = true;
      };
      return this._connection.onopen = () => {
        t23.next({ type: o5.Opened });
      }, this._connection.onerror = (f9) => {
        l19 || (t23.next({ type: o5.Error, error: new E6({ url: this._connection.url, errorMessage: f9.message }) }), t23.complete());
      }, this._connection.onclose = () => {
        l19 || (v22 ? t23.next({ type: o5.Closed }) : t23.next({ type: o5.Error, error: new E6({ url: this._connection.url, errorMessage: "Connection closed unexpectedly" }) }), t23.complete());
      }, this._connection.onmessage = async (f9) => {
        if (g23) return;
        let o12;
        try {
          const e18 = JSON.parse(String(f9.data));
          if (this.isInMessageType(e18)) o12 = e18;
          else throw new Error("Data does not match InMessageType");
        } catch {
          a24(new E6({ url: this._connection.url, errorMessage: `Invalid message received: ${String(f9.data)}` }));
          return;
        }
        switch (o12.query) {
          case s13.EXCHANGE: {
            const { nonce: e18, data: p30 } = o12;
            if (typeof p30 != "string") {
              a24(new E6(`${s13.EXCHANGE} data type should be an APDU`));
              return;
            }
            const s25 = f(p30);
            if (s25 === null || s25.length < 5) {
              a24(new E6(`Received invalid APDU data: ${p30}`));
              return;
            }
            t23.next({ type: o5.PreExchange, payload: { nonce: e18, apdu: s25 } });
            let u14 = false;
            c4(s25) && !this.isSecureConnectionAllowed() && (u14 = true, t23.next({ type: o5.PermissionRequested }));
            const m15 = await this._api.sendApdu(s25);
            if (g23) return;
            m15.caseOf({ Left: (d18) => {
              a24(new E6(d18));
            }, Right: (d18) => {
              let C5;
              const E14 = this.mapDeviceError(d18);
              if (E14 === null) {
                if (C5 = p4.SUCCESS, !this._deviceIdCaptured && a8(s25)) {
                  this._deviceIdCaptured = true;
                  const _6 = p5(d18);
                  if (_6) {
                    const k6 = this._cryptoService.sha3_256(_6);
                    t23.next({ type: o5.DeviceId, payload: { deviceId: k6 } });
                  }
                }
                t23.next({ type: o5.Exchange, payload: { nonce: e18, apdu: s25, data: d18.data, status: d18.statusCode } }), u14 && t23.next({ type: o5.PermissionGranted });
              } else C5 = p4.ERROR, a24(E14);
              const M5 = { nonce: e18, response: C5, data: o(d18.data, false) };
              this._connection.send(JSON.stringify(M5));
            } });
            break;
          }
          case s13.BULK: {
            if (l19 = true, this._connection.close(), !Array.isArray(o12.data) || o12.data.length === 0 || !o12.data.every((e18) => typeof e18 == "string")) {
              a24(new E6("Invalid bulk data received"));
              return;
            }
            for (let e18 = 0, p30 = o12.data.length; e18 < p30; e18++) {
              const s25 = f(o12.data[e18]);
              if (s25 === null || s25.length < 5) {
                a24(new E6(`Received invalid APDU bulk data: ${o12.data[e18]}`));
                return;
              }
              const u14 = await this._api.sendApdu(s25);
              if (g23) return;
              if (u14.isLeft()) {
                a24(new E6(u14.extract()));
                return;
              } else if (u14.isRight()) {
                const m15 = this.mapDeviceError(u14.extract());
                if (m15 === null) t23.next({ type: o5.Progress, payload: { progress: +Number((e18 + 1) / p30).toFixed(2), index: e18, total: p30 } });
                else {
                  a24(m15);
                  return;
                }
              }
            }
            v22 = true, t23.complete();
            break;
          }
          case s13.SUCCESS: {
            if (l19) break;
            const e18 = o12.result ?? o12.data;
            e18 && t23.next({ type: o5.Result, payload: e18 ?? "" }), v22 = true, t23.complete();
            break;
          }
          case s13.WARNING: {
            if (l19) break;
            t23.next({ type: o5.Warning, payload: { message: String(o12.data) } });
            break;
          }
          case s13.ERROR: {
            if (l19) break;
            a24(new E6({ url: this._connection.url, errorMessage: String(o12.data) }));
          }
        }
      }, () => {
        n18(), g23 = true, this._connection.readyState === browser_default.OPEN && this._connection.close();
      };
    });
  }
  isSecureConnectionAllowed() {
    const n18 = this._api.getDeviceSessionState();
    return "isSecureConnectionAllowed" in n18 && n18.isSecureConnectionAllowed;
  }
  isInMessageType(n18) {
    if (typeof n18 != "object" || !n18) return false;
    const c21 = n18;
    return typeof c21.uuid == "string" && typeof c21.session == "string" && typeof c21.query == "string" && Object.values(s13).includes(c21.query) && typeof c21.nonce == "number";
  }
  mapDeviceError(n18) {
    return e2.isSuccessResponse(n18) ? null : e2.isLockedDeviceResponse(n18) ? new E6({ url: this._connection.url, errorMessage: "Device is locked" }, a9.DeviceLocked) : e2.isRefusedByUser(n18) ? new E6({ url: this._connection.url, errorMessage: "User refused on the device" }, a9.RefusedByUser) : e2.isAppAlreadyInstalled(n18) ? new E6({ url: this._connection.url, errorMessage: "App already installed" }, a9.AppAlreadyInstalled) : e2.isOutOfMemory(n18) ? new E6({ url: this._connection.url, errorMessage: "Out of memory" }, a9.OutOfMemory) : new E6({ url: this._connection.url, errorMessage: `Invalid status code: ${o(n18.statusCode)}` });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/GetDeviceMetadata/GetDeviceMetadataDeviceAction.js
var Y = class extends E3 {
  makeStateMachine(n18) {
    const { getDeviceMetadata: u14, getFirmwareMetadata: d18, getApplicationsMetadata: m15, listAppsSecureChannel: g23 } = this.extractDependencies(n18), t23 = this.input.unlockTimeout ?? T, l19 = new L({ input: { unlockTimeout: t23 } }).makeStateMachine(n18), p30 = new I({ input: { unlockTimeout: t23 } }).makeStateMachine(n18);
    return setup({ types: { input: { unlockTimeout: t23 }, context: {}, output: {} }, actors: { goToDashboard: l19, getDeviceMetadata: fromPromise(u14), getFirmwareMetadata: fromPromise(d18), getApplicationsMetadata: fromPromise(m15), listApps: p30, listAppsSecureChannel: fromObservable(g23) }, guards: { hasError: ({ context: e18 }) => e18._internalState.error !== null, hasMetadata: ({ context: e18 }) => e18._internalState.firmwareVersion !== null && e18._internalState.firmwareUpdateContext !== null && e18._internalState.customImage !== null && e18._internalState.applications !== null && e18._internalState.applicationsUpdates !== null && e18._internalState.installedLanguages !== null && e18._internalState.catalog !== null, forceUpdate: ({ context: e18 }) => !!e18.input.forceUpdate, useSecureChannel: ({ context: e18 }) => !!e18.input.useSecureChannel }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "GetDeviceMetadataDeviceAction", initial: "DeviceReady", context: (e18) => ({ input: { useSecureChannel: e18.input.useSecureChannel, forceUpdate: e18.input.forceUpdate, unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, deviceVersion: null, firmware: null, firmwareVersion: null, firmwareUpdateContext: null, customImage: null, installedApps: null, applications: null, applicationsUpdates: null, installedLanguages: null, catalog: null } }), states: { DeviceReady: { always: [{ target: "GoToDashboard", guard: "forceUpdate" }, { target: "GetDeviceMetadataFromContext" }] }, GetDeviceMetadataFromContext: { invoke: { src: "getDeviceMetadata", onDone: { target: "GetDeviceMetadataFromContextResultCheck", actions: assign({ _internalState: (e18) => e18.event.output === null ? e18.context._internalState : { ...e18.context._internalState, firmwareVersion: e18.event.output.firmwareVersion, firmwareUpdateContext: e18.event.output.firmwareUpdateContext, customImage: e18.event.output.customImage, applications: e18.event.output.applications, applicationsUpdates: e18.event.output.applicationsUpdates, installedLanguages: e18.event.output.installedLanguages, catalog: e18.event.output.catalog } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceMetadataFromContextResultCheck: { always: [{ target: "Success", guard: "hasMetadata" }, { target: "GoToDashboard" }] }, GoToDashboard: { exit: assign({ intermediateValue: { requiredUserInteraction: s8.None } }), invoke: { id: "dashboard", src: "goToDashboard", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (a24) => ({ ...e18.context._internalState, error: a24 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetFirmwareMetadata" }] }, GetFirmwareMetadata: { invoke: { src: "getFirmwareMetadata", onDone: { target: "GetFirmwareMetadataResultCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const a24 = n18.getDeviceSessionState();
        return a24.sessionStateType !== a6.Connected && n18.setDeviceSessionState({ ...a24, firmwareVersion: e18.event.output.data.firmwareVersion, firmwareUpdateContext: e18.event.output.data.firmwareUpdateContext, customImage: e18.event.output.data.customImage }), { ...e18.context._internalState, deviceVersion: e18.event.output.data.deviceVersion, firmware: e18.event.output.data.firmware, firmwareVersion: e18.event.output.data.firmwareVersion, firmwareUpdateContext: e18.event.output.data.firmwareUpdateContext, customImage: e18.event.output.data.customImage };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetFirmwareMetadataResultCheck: { always: [{ guard: "hasError", target: "Error" }, { guard: "useSecureChannel", target: "ListAppsSecureChannel" }, { target: "ListApps" }] }, ListAppsSecureChannel: { exit: assign({ intermediateValue: { requiredUserInteraction: s8.None } }), invoke: { id: "listAppsSecureChannel", src: "listAppsSecureChannel", input: (e18) => ({ firmware: e18.context._internalState.firmware, firmwareVersion: e18.context._internalState.firmwareVersion }), onSnapshot: { actions: assign({ intermediateValue: (e18) => {
      var _a7;
      switch ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) {
        case o5.DeviceId:
          return { ...e18.context.intermediateValue, deviceId: e18.event.snapshot.context.payload.deviceId };
        case o5.PermissionRequested:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.AllowSecureConnection };
        case o5.PermissionGranted: {
          const a24 = n18.getDeviceSessionState();
          return a24.sessionStateType !== a6.Connected && n18.setDeviceSessionState({ ...a24, isSecureConnectionAllowed: true }), { ...e18.context.intermediateValue, requiredUserInteraction: s8.None };
        }
        default:
          return { ...e18.context.intermediateValue };
      }
    }, _internalState: (e18) => {
      var _a7, _b4;
      if (((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error) return { ...e18.context._internalState, error: e18.event.snapshot.context.error.mapDAErrors() };
      if (((_b4 = e18.event.snapshot.context) == null ? void 0 : _b4.type) === o5.Result) {
        if (t6(e18.event.snapshot.context.payload)) return { ...e18.context._internalState, installedApps: e18.event.snapshot.context.payload.map((a24) => ({ name: a24.name, hash: a24.hash, hashCode: a24.hash_code_data })) };
        throw new Error(`Invalid result ${JSON.stringify(e18.event.snapshot.context.payload)}`);
      }
      return { ...e18.context._internalState };
    } }) }, onDone: { target: "ListAppsCheck" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListApps: { exit: assign({ intermediateValue: { requiredUserInteraction: s8.None } }), invoke: { id: "listApps", src: "listApps", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { target: "ListAppsCheck", actions: assign({ _internalState: (e18) => e18.event.output.isLeft() ? { ...e18.context._internalState, error: e18.event.output.extract() } : { ...e18.context._internalState, installedApps: e18.event.output.unsafeCoerce().map((a24) => ({ name: a24.appName, hash: a24.appFullHash, hashCode: a24.appCodeHash })) } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetApplicationsMetadata" }] }, GetApplicationsMetadata: { invoke: { src: "getApplicationsMetadata", input: (e18) => ({ deviceVersion: e18.context._internalState.deviceVersion, firmware: e18.context._internalState.firmware, firmwareVersion: e18.context._internalState.firmwareVersion, installedApps: e18.context._internalState.installedApps }), onDone: { target: "GetApplicationsMetadataResultCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const a24 = n18.getDeviceSessionState();
        return a24.sessionStateType !== a6.Connected && n18.setDeviceSessionState({ ...a24, installedApps: e18.event.output.data.applications, appsUpdates: e18.event.output.data.applicationsUpdates, installedLanguages: e18.event.output.data.installedLanguages, catalog: e18.event.output.data.catalog }), { ...e18.context._internalState, applications: e18.event.output.data.applications, applicationsUpdates: e18.event.output.data.applicationsUpdates, installedLanguages: e18.event.output.data.installedLanguages, catalog: e18.event.output.data.catalog };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetApplicationsMetadataResultCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => {
      const { context: a24 } = e18, { error: v22, firmwareVersion: S13, firmwareUpdateContext: w8, customImage: h5, applications: D5, applicationsUpdates: M5, installedLanguages: y6, catalog: A11 } = a24._internalState;
      return v22 ? left(v22) : right({ firmwareVersion: S13, firmwareUpdateContext: w8, customImage: h5, applications: D5, applicationsUpdates: M5, installedLanguages: y6, catalog: A11 });
    } });
  }
  extractDependencies(n18) {
    return { getDeviceMetadata: () => {
      var _a7;
      const t23 = n18.getDeviceSessionState();
      return t23.sessionStateType === a6.Connected || ((_a7 = t23.firmwareVersion) == null ? void 0 : _a7.metadata) === void 0 || t23.firmwareUpdateContext === void 0 || t23.customImage === void 0 || t23.installedApps.length === 0 || t23.appsUpdates === void 0 || t23.installedLanguages === void 0 || t23.catalog === void 0 ? Promise.resolve(null) : Promise.resolve({ firmwareVersion: t23.firmwareVersion, firmwareUpdateContext: t23.firmwareUpdateContext, customImage: t23.customImage, applications: t23.installedApps, applicationsUpdates: t23.appsUpdates, installedLanguages: t23.installedLanguages, catalog: t23.catalog });
    }, getFirmwareMetadata: async () => new R3(n18).run(), getApplicationsMetadata: async (t23) => new M(n18, { deviceVersion: t23.input.deviceVersion, firmware: t23.input.firmware, firmwareVersion: t23.input.firmwareVersion, installedApps: t23.input.installedApps }).run(), listAppsSecureChannel: (t23) => {
      const { firmware: l19, firmwareVersion: p30 } = t23.input, e18 = n18.getSecureChannelService().listInstalledApps(p30.metadata, l19);
      return new j(n18, { connection: e18 }).run();
    } };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/task/BuildAppsInstallPlanTask.js
var import_semver3 = __toESM(require_semver2());
var w3 = class {
  constructor(n18, i23) {
    __publicField(this, "deviceModelId");
    this.api = n18;
    this.args = i23;
    const r10 = n18.getDeviceModel();
    this.deviceModelId = r10.id;
  }
  run() {
    var _a7, _b4;
    const n18 = this.api.getDeviceSessionState();
    if (n18.sessionStateType === a6.Connected) return { error: new s9("Invalid device state") };
    if (n18.catalog === void 0) return { error: new s9("Device apps metadata not fetched") };
    let i23 = [], r10 = [], t23 = [];
    for (const e18 of this.args.applications) {
      const a24 = n18.catalog.applications.find((l19) => l19.versionName === e18.name), o12 = n18.installedApps.find((l19) => l19.versionName === e18.name);
      if (o12 !== void 0 && this.validateConstraint(o12, a24, e18.constraints)) {
        r10 = [...r10, e18.name];
        continue;
      }
      if (a24 !== void 0 && this.validateConstraint(a24, void 0, e18.constraints)) i23 = [...i23, a24];
      else if (this.args.allowMissingApplication) t23 = [...t23, e18.name];
      else return ((_a7 = n18.firmwareUpdateContext) == null ? void 0 : _a7.availableUpdate) !== void 0 && a24 !== void 0 ? { error: new t4(`Application ${e18.name} needs latest firmware`) } : ((_b4 = n18.firmwareUpdateContext) == null ? void 0 : _b4.availableUpdate) !== void 0 ? { error: new t4(`Application ${e18.name} needs latest firmware`) } : { error: new E2(`Application ${e18.name} not supported for this device`) };
    }
    return i23 = [...i23.reduce((e18, a24) => {
      const o12 = a24.parentName;
      if (o12) {
        const l19 = n18.catalog.applications.find((s25) => s25.versionName === o12), f9 = n18.installedApps.find((s25) => s25.versionName === o12);
        if (l19 && !f9) return [...e18, l19];
      }
      return e18;
    }, []), ...i23], { installPlan: i23.filter((e18, a24) => i23.findIndex((o12) => o12.versionName === e18.versionName) === a24), missingApplications: t23, alreadyInstalled: r10 };
  }
  validateConstraint(n18, i23, r10) {
    if (r10 === void 0) return true;
    for (const t23 of r10) if (!(t23.exemptModels !== void 0 && t23.exemptModels.includes(this.deviceModelId)) && !(t23.applicableModels !== void 0 && !t23.applicableModels.includes(this.deviceModelId))) return t23.minVersion === "latest" ? !i23 || (0, import_semver3.gte)(n18.version, i23.version) : (0, import_semver3.gte)(n18.version, t23.minVersion);
    return true;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/task/PredictOutOfMemoryTask.js
var M2 = class {
  constructor(e18, t23) {
    __publicField(this, "deviceModel");
    this.api = e18;
    this.args = t23;
    this.deviceModel = e18.getDeviceModel();
  }
  run() {
    const e18 = this.api.getDeviceSessionState();
    if (e18.sessionStateType === a6.Connected) return { error: new s9("Invalid device state") };
    const { firmwareUpdateContext: t23, customImage: r10, firmwareVersion: o12, installedLanguages: n18, installedApps: a24 } = e18;
    if (t23 === void 0 || r10 === void 0 || o12 === void 0 || n18 === void 0) return { error: new s9("Device metadata not fetched") };
    const { blockSize: i23, totalMemoryBlocks: l19 } = this.getMemoryConstants(o12), c21 = this.getCurrentMemoryBlocksUsage({ firmwareUpdateContext: t23, customImage: r10, installedApps: a24, installedLanguages: n18, blockSize: i23 }), m15 = this.getInstallPlanMemoryBlocksUsage(this.args.installPlan, i23);
    return { outOfMemory: c21 + m15 > l19 };
  }
  getMemoryConstants(e18) {
    const t23 = this.deviceModel.getBlockSize({ firmwareVersion: e18.os }), r10 = Math.floor(this.deviceModel.memorySize / t23);
    return { blockSize: t23, totalMemoryBlocks: r10 };
  }
  getCurrentMemoryBlocksUsage({ firmwareUpdateContext: e18, customImage: t23, installedApps: r10, installedLanguages: o12, blockSize: n18 }) {
    const a24 = (s25) => Math.ceil(s25 / n18), i23 = a24(e18.currentFirmware.bytes || 0), l19 = a24(t23.size || 0), c21 = r10.reduce((s25, p30) => s25 + a24(p30.bytes || 0), 0), m15 = o12.reduce((s25, p30) => s25 + a24(p30.size), 0);
    return i23 + l19 + c21 + m15;
  }
  getInstallPlanMemoryBlocksUsage(e18, t23) {
    const r10 = (o12) => Math.ceil(o12 / t23);
    return e18.reduce((o12, n18) => o12 + r10(n18.bytes || 0), 0);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/InstallOrUpdateApps/InstallOrUpdateAppsDeviceAction.js
var K = class extends E3 {
  makeStateMachine(t23) {
    const { buildInstallPlan: c21, predictOutOfMemory: u14, installApp: d18 } = this.extractDependencies(t23), r10 = this.input.unlockTimeout ?? T, l19 = new Y({ input: { unlockTimeout: r10, useSecureChannel: true, forceUpdate: false } }).makeStateMachine(t23), s25 = new L({ input: { unlockTimeout: r10 } }).makeStateMachine(t23);
    return setup({ types: { input: { unlockTimeout: r10 }, context: {}, output: {} }, actors: { updateMetadata: l19, buildInstallPlan: fromPromise(c21), predictOutOfMemory: fromPromise(u14), goToDashboard: s25, installApp: fromObservable(d18) }, guards: { hasError: ({ context: e18 }) => e18._internalState.error !== null, hasInstallPlan: (e18) => e18.context.intermediateValue.installPlan !== null, hasMoreApps: (e18) => e18.context._internalState.currentIndex < e18.context.intermediateValue.installPlan.installPlan.length }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }), nextAppIndex: assign({ _internalState: (e18) => ({ ...e18.context._internalState, currentIndex: e18.context._internalState.currentIndex + 1 }) }), cleanupDeviceState: () => {
      const e18 = t23.getDeviceSessionState();
      e18.sessionStateType !== a6.Connected && t23.setDeviceSessionState({ ...e18, installedApps: [], appsUpdates: void 0 });
    } } }).createMachine({ id: "InstallOrUpdateAppsDeviceAction", initial: "DeviceReady", context: (e18) => ({ input: { applications: e18.input.applications, allowMissingApplication: e18.input.allowMissingApplication, unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None, installPlan: null }, _internalState: { error: null, osVersion: null, currentIndex: 0 } }), states: { DeviceReady: { always: [{ target: "UpdateDeviceMetadata" }] }, UpdateDeviceMetadata: { exit: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), invoke: { id: "updateMetadata", src: "updateMetadata", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout, useSecureChannel: true, forceUpdate: false }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction, deviceId: e18.event.snapshot.context.intermediateValue.deviceId ?? e18.context.intermediateValue.deviceId }) }) }, onDone: { target: "UpdateDeviceMetadataCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (n18) => ({ ...e18.context._internalState, osVersion: n18.firmwareVersion.metadata }), Left: (n18) => ({ ...e18.context._internalState, error: n18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, UpdateDeviceMetadataCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success", guard: "hasInstallPlan" }, { target: "BuildInstallPlan" }] }, BuildInstallPlan: { invoke: { src: "buildInstallPlan", input: (e18) => ({ applications: e18.context.input.applications, allowMissingApplication: e18.context.input.allowMissingApplication }), onDone: { target: "BuildInstallPlanCheck", actions: assign({ _internalState: (e18) => "error" in e18.event.output ? { ...e18.context._internalState, error: e18.event.output.error } : e18.context._internalState, intermediateValue: (e18) => "error" in e18.event.output ? e18.context.intermediateValue : { ...e18.context.intermediateValue, installPlan: { installPlan: e18.event.output.installPlan, alreadyInstalled: e18.event.output.alreadyInstalled, missingApplications: e18.event.output.missingApplications, currentIndex: 0, currentProgress: 0 } } }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, BuildInstallPlanCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "PredictOutOfMemory", guard: "hasMoreApps" }, { target: "Success" }] }, PredictOutOfMemory: { invoke: { src: "predictOutOfMemory", input: (e18) => ({ installPlan: e18.context.intermediateValue.installPlan.installPlan }), onDone: { target: "PredictOutOfMemoryCheck", actions: assign({ _internalState: (e18) => "error" in e18.event.output ? { ...e18.context._internalState, error: e18.event.output.error } : e18.event.output.outOfMemory ? { ...e18.context._internalState, error: new l4("Not enough memory for those applications") } : e18.context._internalState }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, PredictOutOfMemoryCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "GoToDashboard" }] }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (n18) => ({ ...e18.context._internalState, error: n18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallApp", actions: "cleanupDeviceState" }] }, InstallApp: { exit: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), invoke: { id: "installApp", src: "installApp", input: (e18) => ({ osVersion: e18.context._internalState.osVersion, application: e18.context.intermediateValue.installPlan.installPlan[e18.context._internalState.currentIndex] }), onSnapshot: { actions: assign({ intermediateValue: (e18) => {
      var _a7;
      switch ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) {
        case o5.DeviceId:
          return { ...e18.context.intermediateValue, deviceId: e18.event.snapshot.context.payload.deviceId };
        case o5.PermissionRequested:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.AllowSecureConnection };
        case o5.PermissionGranted: {
          const n18 = t23.getDeviceSessionState();
          return n18.sessionStateType !== a6.Connected && t23.setDeviceSessionState({ ...n18, isSecureConnectionAllowed: true }), { ...e18.context.intermediateValue, requiredUserInteraction: s8.None };
        }
        case o5.Progress:
          return { ...e18.context.intermediateValue, installPlan: { ...e18.context.intermediateValue.installPlan, currentIndex: e18.context._internalState.currentIndex, currentProgress: e18.event.snapshot.context.payload.progress } };
        default:
          return e18.context.intermediateValue;
      }
    }, _internalState: (e18) => {
      var _a7;
      return ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error ? { ...e18.context._internalState, error: e18.event.snapshot.context.error.mapInstallDAErrors() } : e18.context._internalState;
    } }) }, onDone: { target: "InstallAppCheck", actions: "nextAppIndex" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, InstallAppCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallApp", guard: "hasMoreApps" }, { target: "UpdateDeviceMetadata" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => {
      const { context: n18 } = e18, { error: m15 } = n18._internalState, { installPlan: p30 } = n18.intermediateValue;
      return m15 ? left(m15) : right({ successfullyInstalled: p30.installPlan, alreadyInstalled: p30.alreadyInstalled, missingApplications: p30.missingApplications });
    } });
  }
  extractDependencies(t23) {
    return { buildInstallPlan: (r10) => Promise.resolve(new w3(t23, { applications: r10.input.applications, allowMissingApplication: r10.input.allowMissingApplication }).run()), predictOutOfMemory: (r10) => Promise.resolve(new M2(t23, { installPlan: r10.input.installPlan }).run()), installApp: (r10) => {
      const { osVersion: l19, application: s25 } = r10.input, e18 = t23.getSecureChannelService().installApp(l19, s25);
      return new j(t23, { connection: e18 }).run();
    } };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/ListAppsWithMetadata/ListAppsWithMetadataDeviceAction.js
var O = class extends E3 {
  makeStateMachine(a24) {
    const { getAppsByHash: c21, setDeviceSessionState: i23, getDeviceSessionState: r10 } = this.extractDependencies(a24), s25 = this.input.unlockTimeout ?? T, p30 = new I({ input: { unlockTimeout: s25 } }).makeStateMachine(a24);
    return setup({ types: { input: { unlockTimeout: s25 }, context: {}, output: {} }, actors: { listApps: p30, getAppsByHash: fromPromise(c21), updateDeviceSessionState: fromCallback(({ input: t23, sendBack: e18 }) => {
      const { appsWithMetadata: A11 } = t23, h5 = A11.filter((o12) => o12 !== null), l19 = { ...r10(), installedApps: h5 };
      try {
        i23(l19), e18({ type: "done" });
      } catch (o12) {
        e18({ type: "error", error: o12 });
      }
    }) }, guards: { hasError: ({ context: t23 }) => t23._internalState.error !== null, hasNoAppsInstalled: ({ context: t23 }) => t23._internalState.apps.length === 0 }, actions: { assignErrorFromEvent: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: t23.event.error }) }) } }).createMachine({ id: "ListAppsWithMetadataDeviceAction", initial: "DeviceReady", context: (t23) => ({ input: t23.input, _internalState: { error: null, apps: [], appsWithMetadata: [] }, intermediateValue: { requiredUserInteraction: s8.None } }), states: { DeviceReady: { always: { target: "ListApps" } }, ListApps: { invoke: { id: "listApps", src: "listApps", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => t23.event.snapshot.context.intermediateValue }) }, onDone: { target: "ListAppsCheck", actions: assign({ intermediateValue: (t23) => ({ requiredUserInteraction: s8.None }), _internalState: (t23) => t23.event.output.caseOf({ Right: (e18) => ({ ...t23.context._internalState, apps: e18 }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) } } }, ListAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success", guard: "hasNoAppsInstalled", actions: assign({ _internalState: (t23) => ({ ...t23.context._internalState, appsWithMetadata: [] }) }) }, { target: "FetchMetadata" }] }, FetchMetadata: { invoke: { id: "getAppsByHash", src: "getAppsByHash", input: (t23) => t23.context._internalState.apps, onDone: { target: "FetchMetadataCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: (e18) => ({ ...t23.context._internalState, appsWithMetadata: e18 }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, FetchMetadataCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "SaveSession" }] }, SaveSession: { invoke: { src: "updateDeviceSessionState", input: (t23) => ({ appsWithMetadata: t23.context._internalState.appsWithMetadata }) }, on: { done: { target: "Success" }, error: { target: "Error", actions: "assignErrorFromEvent" } } }, Success: { type: "final" }, Error: { type: "final" } }, output: (t23) => t23.context._internalState.error ? left(t23.context._internalState.error) : right(t23.context._internalState.appsWithMetadata) });
  }
  extractDependencies(a24) {
    return { getAppsByHash: ({ input: i23 }) => {
      const r10 = i23.reduce((s25, p30) => p30.appFullHash ? s25.concat(p30.appFullHash) : s25, []);
      return a24.getManagerApiService().getAppsByHash(r10);
    }, getDeviceSessionState: () => a24.getDeviceSessionState(), setDeviceSessionState: (i23) => a24.setDeviceSessionState(i23) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/OpenAppWithDependencies/OpenAppWithDependenciesDeviceAction.js
var w4 = class extends E3 {
  makeStateMachine(r10) {
    const a24 = this.input.unlockTimeout ?? T, o12 = new Y({ input: { unlockTimeout: a24, useSecureChannel: true, forceUpdate: false } }).makeStateMachine(r10), c21 = new K({ input: { unlockTimeout: a24, applications: [...this.input.dependencies, this.input.application], allowMissingApplication: false } }).makeStateMachine(r10), s25 = new W({ input: { unlockTimeout: a24, appName: this.input.application.name } }).makeStateMachine(r10);
    return setup({ types: { input: { unlockTimeout: a24 }, context: {}, output: {} }, actors: { getMetadata: o12, installApps: c21, openApp: s25 }, guards: { hasError: ({ context: e18 }) => e18._internalState.error !== null }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "OpenAppWithDependenciesDeviceAction", initial: "DeviceReady", context: (e18) => ({ input: { application: e18.input.application, dependencies: e18.input.dependencies, requireLatestFirmware: e18.input.requireLatestFirmware, unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None, installPlan: null }, _internalState: { error: null, deviceMetadata: null, installResult: null } }), states: { DeviceReady: { always: [{ target: "GetDeviceMetadata" }] }, GetDeviceMetadata: { exit: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), invoke: { id: "getMetadata", src: "getMetadata", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout, useSecureChannel: true, forceUpdate: false }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction, deviceId: e18.event.snapshot.context.intermediateValue.deviceId ?? e18.context.intermediateValue.deviceId }) }) }, onDone: { target: "GetDeviceMetadataCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => e18.context.input.requireLatestFirmware && t23.firmwareUpdateContext.availableUpdate !== void 0 ? { ...e18.context._internalState, error: new t4("Firmware is not the latest version") } : { ...e18.context._internalState, deviceMetadata: t23 }, Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceMetadataCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "InstallDependencies" }] }, InstallDependencies: { exit: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), invoke: { src: "installApps", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout, applications: [...e18.context.input.dependencies, e18.context.input.application], allowMissingApplication: false }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction, installPlan: e18.event.snapshot.context.intermediateValue.installPlan, deviceId: e18.event.snapshot.context.intermediateValue.deviceId ?? e18.context.intermediateValue.deviceId }) }) }, onDone: { target: "InstallDependenciesCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, installResult: t23 }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, InstallDependenciesCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "OpenApp" }] }, OpenApp: { exit: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: s8.None }) }), invoke: { src: "openApp", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout, appName: e18.context.input.application.name }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction, installPlan: null }) }) }, onDone: { target: "OpenAppCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, OpenAppCheck: { always: [{ guard: "hasError", target: "Error" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => {
      const { context: t23 } = e18, { error: p30, deviceMetadata: l19, installResult: u14 } = t23._internalState;
      return p30 ? left(p30) : right({ deviceMetadata: l19, installResult: u14 });
    } });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/os/SendCommandInAppDeviceAction/SendCommandInAppDeviceAction.js
var h = class extends E3 {
  makeStateMachine(t23) {
    const { sendCommand: o12 } = this.extractDependencies(t23);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { sendCommand: fromPromise(o12), openAppStateMachine: new W({ input: { appName: this.input.appName } }).makeStateMachine(t23) }, guards: { skipOpenApp: () => this.input.skipOpenApp, noInternalError: ({ context: e18 }) => e18._internalState.error === null }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "SendCommandInAppDeviceAction", initial: "InitialState", context: ({ input: e18 }) => ({ input: e18, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { commandResponse: null, error: null } }), states: { InitialState: { always: [{ target: "SendCommand", guard: "skipOpenApp" }, "OpenAppDeviceAction"] }, OpenAppDeviceAction: { invoke: { id: "openAppStateMachine", input: { appName: this.input.appName }, src: "openAppStateMachine", onSnapshot: { actions: assign({ intermediateValue: (e18) => e18.event.snapshot.context.intermediateValue }) }, onDone: { actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (r10) => ({ ...e18.context._internalState, error: r10 }) }) }), target: "CheckOpenAppDeviceActionResult" } } }, CheckOpenAppDeviceActionResult: { always: [{ target: "SendCommand", guard: "noInternalError" }, "Error"] }, SendCommand: { entry: assign({ intermediateValue: { requiredUserInteraction: this.input.requiredUserInteraction } }), exit: assign({ intermediateValue: { requiredUserInteraction: s8.None } }), invoke: { id: "sendCommand", src: "sendCommand", input: ({ context: e18 }) => e18.input.command, onDone: { target: "SendCommandResultCheck", actions: [assign({ _internalState: ({ event: e18, context: r10 }) => s5(e18.output) ? { ...r10._internalState, commandResponse: e18.output.data } : { ...r10._internalState, error: e18.output.error } })] }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, SendCommandResultCheck: { always: [{ target: "Success", guard: "noInternalError" }, "Error"] }, Success: { type: "final" }, Error: { type: "final" } }, output: ({ context: e18 }) => e18._internalState.commandResponse ? right(e18._internalState.commandResponse) : left(e18._internalState.error || new s9("No error in final state")) });
  }
  extractDependencies(t23) {
    return { sendCommand: (o12) => t23.sendCommand(o12.input) };
  }
};

// node_modules/@inversifyjs/common/lib/esm/index.js
function e4(e18) {
  return ("object" == typeof e18 && null !== e18 || "function" == typeof e18) && "function" == typeof e18.then;
}
function t8(e18) {
  switch (typeof e18) {
    case "string":
    case "symbol":
      return e18.toString();
    case "function":
      return e18.name;
    default:
      throw new Error(`Unexpected ${typeof e18} service id type`);
  }
}
var n5 = Symbol.for("@inversifyjs/common/islazyServiceIdentifier");
var _a3, _e;
_a3 = n5;
var r3 = class {
  constructor(e18) {
    __publicField(this, _a3);
    __privateAdd(this, _e);
    __privateSet(this, _e, e18), this[n5] = true;
  }
  static is(e18) {
    return "object" == typeof e18 && null !== e18 && true === e18[n5];
  }
  unwrap() {
    return __privateGet(this, _e).call(this);
  }
};
_e = new WeakMap();

// node_modules/@inversifyjs/reflect-metadata-utils/lib/esm/index.js
function t9(t23, e18) {
  return Reflect.getOwnMetadata(e18, t23);
}
function n6(t23, e18, n18) {
  Reflect.defineMetadata(e18, n18, t23);
}
function a10(e18, n18, a24, f9) {
  const c21 = f9(t9(e18, n18) ?? a24());
  Reflect.defineMetadata(n18, c21, e18);
}

// node_modules/@inversifyjs/core/lib/esm/index.js
var s15 = "@inversifyjs/container/bindingId";
function c5() {
  const i23 = t9(Object, s15) ?? 0;
  return i23 === Number.MAX_SAFE_INTEGER ? n6(Object, s15, Number.MIN_SAFE_INTEGER) : a10(Object, s15, () => i23, (e18) => e18 + 1), i23;
}
var u4 = { Request: "Request", Singleton: "Singleton", Transient: "Transient" };
var d3 = { ConstantValue: "ConstantValue", DynamicValue: "DynamicValue", Factory: "Factory", Instance: "Instance", Provider: "Provider", ResolvedValue: "ResolvedValue", ServiceRedirection: "ServiceRedirection" };
function* l7(...e18) {
  for (const t23 of e18) yield* t23;
}
var _e2, _t, _n, _p_instances, i_fn, o_fn, r_fn, a_fn, s_fn;
var _p = class _p {
  constructor(e18) {
    __privateAdd(this, _p_instances);
    __privateAdd(this, _e2);
    __privateAdd(this, _t);
    __privateAdd(this, _n);
    __privateSet(this, _e2, /* @__PURE__ */ new Map()), __privateSet(this, _t, {});
    for (const t23 of Reflect.ownKeys(e18)) __privateGet(this, _t)[t23] = /* @__PURE__ */ new Map();
    __privateSet(this, _n, e18);
  }
  add(e18, t23) {
    __privateMethod(this, _p_instances, i_fn).call(this, e18).push(t23);
    for (const n18 of Reflect.ownKeys(t23)) __privateMethod(this, _p_instances, o_fn).call(this, n18, t23[n18]).push(e18);
  }
  clone() {
    const e18 = Reflect.ownKeys(__privateGet(this, _n)), t23 = new _p(__privateGet(this, _n));
    __privateMethod(this, _p_instances, r_fn).call(this, __privateGet(this, _e2), __privateGet(t23, _e2));
    for (const n18 of e18) __privateMethod(this, _p_instances, r_fn).call(this, __privateGet(this, _t)[n18], __privateGet(t23, _t)[n18]);
    return t23;
  }
  get(e18, t23) {
    return __privateGet(this, _t)[e18].get(t23);
  }
  getAllKeys(e18) {
    return __privateGet(this, _t)[e18].keys();
  }
  removeByRelation(e18, t23) {
    const n18 = this.get(e18, t23);
    if (void 0 === n18) return;
    const i23 = new Set(n18);
    for (const n19 of i23) {
      const i24 = __privateGet(this, _e2).get(n19);
      if (void 0 === i24) throw new Error("Expecting model relation, none found");
      for (const o12 of i24) o12[e18] === t23 && __privateMethod(this, _p_instances, a_fn).call(this, n19, o12);
      __privateGet(this, _e2).delete(n19);
    }
  }
};
_e2 = new WeakMap();
_t = new WeakMap();
_n = new WeakMap();
_p_instances = new WeakSet();
i_fn = function(e18) {
  let t23 = __privateGet(this, _e2).get(e18);
  return void 0 === t23 && (t23 = [], __privateGet(this, _e2).set(e18, t23)), t23;
};
o_fn = function(e18, t23) {
  let n18 = __privateGet(this, _t)[e18].get(t23);
  return void 0 === n18 && (n18 = [], __privateGet(this, _t)[e18].set(t23, n18)), n18;
};
r_fn = function(e18, t23) {
  for (const [n18, i23] of e18) t23.set(n18, [...i23]);
};
a_fn = function(e18, t23) {
  for (const n18 of Reflect.ownKeys(t23)) __privateMethod(this, _p_instances, s_fn).call(this, e18, n18, t23[n18]);
};
s_fn = function(e18, t23, n18) {
  const i23 = __privateGet(this, _t)[t23].get(n18);
  if (void 0 !== i23) {
    const o12 = i23.indexOf(e18);
    -1 !== o12 && i23.splice(o12, 1), 0 === i23.length && __privateGet(this, _t)[t23].delete(n18);
  }
};
var p7 = _p;
var f3;
var g4;
var m;
!function(e18) {
  e18.moduleId = "moduleId", e18.serviceId = "serviceId";
}(f3 || (f3 = {}));
var _c, _u;
var _h = class _h {
  constructor(e18, t23) {
    __privateAdd(this, _c);
    __privateAdd(this, _u);
    __privateSet(this, _c, t23 ?? new p7({ moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _u, e18);
  }
  static build(e18) {
    return new _h(e18);
  }
  add(e18, t23) {
    __privateGet(this, _c).add(e18, t23);
  }
  clone() {
    return new _h(__privateGet(this, _u), __privateGet(this, _c).clone());
  }
  get(e18) {
    var _a7;
    const t23 = [], n18 = __privateGet(this, _c).get(f3.serviceId, e18);
    void 0 !== n18 && t23.push(n18);
    const i23 = (_a7 = __privateGet(this, _u)) == null ? void 0 : _a7.get(e18);
    if (void 0 !== i23 && t23.push(i23), 0 !== t23.length) return l7(...t23);
  }
  removeAllByModuleId(e18) {
    __privateGet(this, _c).removeByRelation(f3.moduleId, e18);
  }
  removeAllByServiceId(e18) {
    __privateGet(this, _c).removeByRelation(f3.serviceId, e18);
  }
};
_c = new WeakMap();
_u = new WeakMap();
var h2 = _h;
!function(e18) {
  e18.id = "id", e18.moduleId = "moduleId", e18.serviceId = "serviceId";
}(g4 || (g4 = {}));
var _d, _u2;
var _v = class _v {
  constructor(e18, t23) {
    __privateAdd(this, _d);
    __privateAdd(this, _u2);
    __privateSet(this, _d, t23 ?? new p7({ id: { isOptional: false }, moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _u2, e18);
  }
  static build(e18) {
    return new _v(e18);
  }
  clone() {
    return new _v(__privateGet(this, _u2), __privateGet(this, _d).clone());
  }
  get(e18) {
    var _a7;
    return this.getNonParentBindings(e18) ?? ((_a7 = __privateGet(this, _u2)) == null ? void 0 : _a7.get(e18));
  }
  getById(e18) {
    var _a7;
    return __privateGet(this, _d).get(g4.id, e18) ?? ((_a7 = __privateGet(this, _u2)) == null ? void 0 : _a7.getById(e18));
  }
  getByModuleId(e18) {
    var _a7;
    return __privateGet(this, _d).get(g4.moduleId, e18) ?? ((_a7 = __privateGet(this, _u2)) == null ? void 0 : _a7.getByModuleId(e18));
  }
  getNonParentBindings(e18) {
    return __privateGet(this, _d).get(g4.serviceId, e18);
  }
  getNonParentBoundServices() {
    return __privateGet(this, _d).getAllKeys(g4.serviceId);
  }
  removeById(e18) {
    __privateGet(this, _d).removeByRelation(g4.id, e18);
  }
  removeAllByModuleId(e18) {
    __privateGet(this, _d).removeByRelation(g4.moduleId, e18);
  }
  removeAllByServiceId(e18) {
    __privateGet(this, _d).removeByRelation(g4.serviceId, e18);
  }
  set(e18) {
    const t23 = { [g4.id]: e18.id, [g4.serviceId]: e18.serviceIdentifier };
    void 0 !== e18.moduleId && (t23[g4.moduleId] = e18.moduleId), __privateGet(this, _d).add(e18, t23);
  }
};
_d = new WeakMap();
_u2 = new WeakMap();
var v3 = _v;
!function(e18) {
  e18.moduleId = "moduleId", e18.serviceId = "serviceId";
}(m || (m = {}));
var _l, _u3;
var _y = class _y {
  constructor(e18, t23) {
    __privateAdd(this, _l);
    __privateAdd(this, _u3);
    __privateSet(this, _l, t23 ?? new p7({ moduleId: { isOptional: true }, serviceId: { isOptional: false } })), __privateSet(this, _u3, e18);
  }
  static build(e18) {
    return new _y(e18);
  }
  add(e18, t23) {
    __privateGet(this, _l).add(e18, t23);
  }
  clone() {
    return new _y(__privateGet(this, _u3), __privateGet(this, _l).clone());
  }
  get(e18) {
    var _a7;
    const t23 = [], n18 = __privateGet(this, _l).get(m.serviceId, e18);
    void 0 !== n18 && t23.push(n18);
    const i23 = (_a7 = __privateGet(this, _u3)) == null ? void 0 : _a7.get(e18);
    if (void 0 !== i23 && t23.push(i23), 0 !== t23.length) return l7(...t23);
  }
  removeAllByModuleId(e18) {
    __privateGet(this, _l).removeByRelation(m.moduleId, e18);
  }
  removeAllByServiceId(e18) {
    __privateGet(this, _l).removeByRelation(m.serviceId, e18);
  }
};
_l = new WeakMap();
_u3 = new WeakMap();
var y3 = _y;
var I2 = "@inversifyjs/core/classMetadataReflectKey";
function w5() {
  return { constructorArguments: [], lifecycle: { postConstructMethodName: void 0, preDestroyMethodName: void 0 }, properties: /* @__PURE__ */ new Map(), scope: void 0 };
}
var b2 = "@inversifyjs/core/pendingClassMetadataCountReflectKey";
var j2 = Symbol.for("@inversifyjs/core/InversifyCoreError");
var _a4, _b;
var T2 = class _T extends (_b = Error, _a4 = j2, _b) {
  constructor(e18, t23, n18) {
    super(t23, n18);
    __publicField(this, _a4);
    __publicField(this, "kind");
    this[j2] = true, this.kind = e18;
  }
  static is(e18) {
    return "object" == typeof e18 && null !== e18 && true === e18[j2];
  }
  static isErrorOfKind(e18, t23) {
    return _T.is(e18) && e18.kind === t23;
  }
};
var S3;
var A5;
var C;
function $(t23) {
  const n18 = t9(t23, I2) ?? w5();
  if (!function(t24) {
    const n19 = t9(t24, b2);
    return void 0 !== n19 && 0 !== n19;
  }(t23)) return function(e18, t24) {
    const n19 = [];
    if (t24.length < e18.length) throw new T2(S3.missingInjectionDecorator, `Found unexpected missing metadata on type "${e18.name}". "${e18.name}" constructor requires at least ${e18.length.toString()} arguments, found ${t24.length.toString()} instead.
Are you using @inject, @multiInject or @unmanaged decorators in every non optional constructor argument?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
    for (let e19 = 0; e19 < t24.length; ++e19) void 0 === t24[e19] && n19.push(e19);
    if (n19.length > 0) throw new T2(S3.missingInjectionDecorator, `Found unexpected missing metadata on type "${e18.name}" at constructor indexes "${n19.join('", "')}".

Are you using @inject, @multiInject or @unmanaged decorators at those indexes?

If you're using typescript and want to rely on auto injection, set "emitDecoratorMetadata" compiler option to true`);
  }(t23, n18.constructorArguments), n18;
  !function(e18, t24) {
    const n19 = [];
    for (let i23 = 0; i23 < t24.constructorArguments.length; ++i23) {
      const o12 = t24.constructorArguments[i23];
      void 0 !== o12 && o12.kind !== A5.unknown || n19.push(`  - Missing or incomplete metadata for type "${e18.name}" at constructor argument with index ${i23.toString()}.
Every constructor parameter must be decorated either with @inject, @multiInject or @unmanaged decorator.`);
    }
    for (const [i23, o12] of t24.properties) o12.kind === A5.unknown && n19.push(`  - Missing or incomplete metadata for type "${e18.name}" at property "${i23.toString()}".
This property must be decorated either with @inject or @multiInject decorator.`);
    if (0 === n19.length) throw new T2(S3.unknown, `Unexpected class metadata for type "${e18.name}" with uncompletion traces.
This might be caused by one of the following reasons:

1. A third party library is targeting inversify reflection metadata.
2. A bug is causing the issue. Consider submiting an issue to fix it.`);
    throw new T2(S3.missingInjectionDecorator, `Invalid class metadata at type ${e18.name}:

${n19.join("\n\n")}`);
  }(t23, n18);
}
function x3() {
  return 0;
}
function R4(e18) {
  return (t23) => {
    void 0 !== t23 && t23.kind === A5.unknown && a10(e18, b2, x3, (e19) => e19 - 1);
  };
}
function B(e18, t23) {
  return (...n18) => (i23) => {
    if (void 0 === i23) return e18(...n18);
    if (i23.kind === C.unmanaged) throw new T2(S3.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
    return t23(i23, ...n18);
  };
}
function k3(e18) {
  if (e18.kind !== A5.unknown && true !== e18.isFromTypescriptParamType) throw new T2(S3.injectionDecoratorConflict, "Unexpected injection found. Multiple @inject, @multiInject or @unmanaged decorators found");
}
!function(e18) {
  e18[e18.injectionDecoratorConflict = 0] = "injectionDecoratorConflict", e18[e18.missingInjectionDecorator = 1] = "missingInjectionDecorator", e18[e18.planning = 2] = "planning", e18[e18.resolution = 3] = "resolution", e18[e18.unknown = 4] = "unknown";
}(S3 || (S3 = {})), function(e18) {
  e18[e18.unknown = 32] = "unknown";
}(A5 || (A5 = {})), function(e18) {
  e18[e18.multipleInjection = 0] = "multipleInjection", e18[e18.singleInjection = 1] = "singleInjection", e18[e18.unmanaged = 2] = "unmanaged";
}(C || (C = {}));
var P2 = B(function(e18, t23) {
  return { kind: e18, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: t23 };
}, function(e18, t23, n18) {
  return k3(e18), { ...e18, kind: t23, value: n18 };
});
function D2(e18, t23) {
  return (n18) => {
    const i23 = n18.properties.get(t23);
    return n18.properties.set(t23, e18(i23)), n18;
  };
}
var F;
function O2(e18, t23, n18, i23) {
  if (T2.isErrorOfKind(i23, S3.injectionDecoratorConflict)) {
    const o12 = function(e19, t24, n19) {
      if (void 0 === n19) {
        if (void 0 === t24) throw new T2(S3.unknown, "Unexpected undefined property and index values");
        return { kind: F.property, property: t24, targetClass: e19.constructor };
      }
      return "number" == typeof n19 ? { index: n19, kind: F.parameter, targetClass: e19 } : { kind: F.method, method: t24, targetClass: e19 };
    }(e18, t23, n18);
    throw new T2(S3.injectionDecoratorConflict, `Unexpected injection error.

Cause:

${i23.message}

Details

${function(e19) {
      switch (e19.kind) {
        case F.method:
          return `[class: "${e19.targetClass.name}", method: "${e19.method.toString()}"]`;
        case F.parameter:
          return `[class: "${e19.targetClass.name}", index: "${e19.index.toString()}"]`;
        case F.property:
          return `[class: "${e19.targetClass.name}", property: "${e19.property.toString()}"]`;
      }
    }(o12)}`, { cause: i23 });
  }
  throw i23;
}
function V(e18, t23) {
  return (i23, o12, r10) => {
    try {
      void 0 === r10 ? function(e19, t24) {
        const i24 = E7(e19, t24);
        return (e20, t25) => {
          a10(e20.constructor, I2, w5, D2(i24(e20), t25));
        };
      }(e18, t23)(i23, o12) : "number" == typeof r10 ? function(e19, t24) {
        const i24 = E7(e19, t24);
        return (e20, t25, o13) => {
          if (!/* @__PURE__ */ function(e21, t26) {
            return "function" == typeof e21 && void 0 === t26;
          }(e20, t25)) throw new T2(S3.injectionDecoratorConflict, `Found an @inject decorator in a non constructor parameter.
Found @inject decorator at method "${(t25 == null ? void 0 : t25.toString()) ?? ""}" at class "${e20.constructor.name}"`);
          a10(e20, I2, w5, /* @__PURE__ */ function(e21, t26) {
            return (n18) => {
              const i25 = n18.constructorArguments[t26];
              return n18.constructorArguments[t26] = e21(i25), n18;
            };
          }(i24(e20), o13));
        };
      }(e18, t23)(i23, o12, r10) : function(e19, t24) {
        const i24 = E7(e19, t24);
        return (e20, t25, o13) => {
          if (!function(e21) {
            return void 0 !== e21.set;
          }(o13)) throw new T2(S3.injectionDecoratorConflict, `Found an @inject decorator in a non setter property method.
Found @inject decorator at method "${t25.toString()}" at class "${e20.constructor.name}"`);
          a10(e20.constructor, I2, w5, D2(i24(e20), t25));
        };
      }(e18, t23)(i23, o12, r10);
    } catch (e19) {
      O2(i23, o12, r10, e19);
    }
  };
}
function E7(e18, t23) {
  return (n18) => {
    const i23 = t23(n18);
    return (t24) => (i23(t24), e18(t24));
  };
}
function N(e18) {
  return V(P2(C.singleInjection, e18), R4);
}
!function(e18) {
  e18[e18.method = 0] = "method", e18[e18.parameter = 1] = "parameter", e18[e18.property = 2] = "property";
}(F || (F = {}));
var U = "@inversifyjs/core/classIsInjectableFlagReflectKey";
var K2 = [Array, BigInt, Boolean, Function, Number, Object, String];
function q(t23) {
  const i23 = t9(t23, "design:paramtypes");
  void 0 !== i23 && a10(t23, I2, w5, /* @__PURE__ */ function(e18) {
    return (t24) => (e18.forEach((e19, n18) => {
      var i24;
      void 0 !== t24.constructorArguments[n18] || (i24 = e19, K2.includes(i24)) || (t24.constructorArguments[n18] = function(e20) {
        return { isFromTypescriptParamType: true, kind: C.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: e20 };
      }(e19));
    }), t24);
  }(i23));
}
function z2(i23) {
  return (o12) => {
    !function(n18) {
      if (void 0 !== t9(n18, U)) throw new T2(S3.injectionDecoratorConflict, `Cannot apply @injectable decorator multiple times at class "${n18.name}"`);
      n6(n18, U, true);
    }(o12), q(o12), void 0 !== i23 && a10(o12, I2, w5, (e18) => ({ ...e18, scope: i23 }));
  };
}
function ie() {
  return { kind: C.unmanaged };
}
var oe = B(ie, function(e18) {
  if (k3(e18), function(e19) {
    return void 0 !== e19.name || e19.optional || e19.tags.size > 0;
  }(e18)) throw new T2(S3.injectionDecoratorConflict, "Unexpected injection found. Found @unmanaged injection with additional @named, @optional, @tagged or @targetName injections");
  return ie();
});
var ae;
!function(e18) {
  e18[e18.multipleInjection = 0] = "multipleInjection", e18[e18.singleInjection = 1] = "singleInjection";
}(ae || (ae = {}));
var _p2;
var _se = class _se {
  constructor(e18) {
    __privateAdd(this, _p2);
    __privateSet(this, _p2, e18);
  }
  get name() {
    return __privateGet(this, _p2).elem.name;
  }
  get serviceIdentifier() {
    return __privateGet(this, _p2).elem.serviceIdentifier;
  }
  get tags() {
    return __privateGet(this, _p2).elem.tags;
  }
  getAncestor() {
    if (void 0 !== __privateGet(this, _p2).previous) return new _se(__privateGet(this, _p2).previous);
  }
};
_p2 = new WeakMap();
var se = _se;
var ce = class _ce {
  constructor(e18) {
    __publicField(this, "last");
    this.last = e18;
  }
  concat(e18) {
    return new _ce({ elem: e18, previous: this.last });
  }
  [Symbol.iterator]() {
    let e18 = this.last;
    return { next: () => {
      if (void 0 === e18) return { done: true, value: void 0 };
      const t23 = e18.elem;
      return e18 = e18.previous, { done: false, value: t23 };
    } };
  }
};
function ue(e18, t23, n18) {
  const i23 = (n18 == null ? void 0 : n18.customServiceIdentifier) ?? t23.serviceIdentifier, o12 = [...e18.getBindings(i23) ?? []].filter((e19) => e19.isSatisfiedBy(t23));
  if (0 === o12.length && void 0 !== e18.autobindOptions && "function" == typeof i23) {
    const t24 = function(e19, t25) {
      const n19 = $(t25), i24 = n19.scope ?? e19.scope;
      return { cache: { isRight: false, value: void 0 }, id: c5(), implementationType: t25, isSatisfiedBy: () => true, moduleId: void 0, onActivation: void 0, onDeactivation: void 0, scope: i24, serviceIdentifier: t25, type: d3.Instance };
    }(e18.autobindOptions, i23);
    e18.setBinding(t24), o12.push(t24);
  }
  return o12;
}
function de(e18) {
  return void 0 !== e18.redirections;
}
function le(e18, t23, n18, i23) {
  var _a7;
  let r10, a24;
  de(n18) ? (r10 = n18.binding.targetServiceIdentifier, a24 = n18.binding.serviceIdentifier) : (r10 = n18.serviceIdentifier, a24 = (_a7 = n18.parent) == null ? void 0 : _a7.binding.serviceIdentifier), Array.isArray(e18) ? function(e19, t24, n19, i24, r11) {
    if (0 !== e19.length) {
      const t25 = `Ambiguous bindings found for service: "${t8(n19)}".

Registered bindings:

${e19.map((e20) => function(e21) {
        switch (e21.type) {
          case d3.Instance:
            return `[ type: "${e21.type}", serviceIdentifier: "${t8(e21.serviceIdentifier)}", scope: "${e21.scope}", implementationType: "${e21.implementationType.name}" ]`;
          case d3.ServiceRedirection:
            return `[ type: "${e21.type}", serviceIdentifier: "${t8(e21.serviceIdentifier)}", redirection: "${t8(e21.targetServiceIdentifier)}" ]`;
          default:
            return `[ type: "${e21.type}", serviceIdentifier: "${t8(e21.serviceIdentifier)}", scope: "${e21.scope}" ]`;
        }
      }(e20.binding)).join("\n")}

Trying to resolve bindings for "${fe(n19, i24)}".

${ge(r11)}`;
      throw new T2(S3.planning, t25);
    }
    t24 || pe(n19, i24, r11);
  }(e18, t23, r10, a24, i23) : function(e19, t24, n19, i24, o12) {
    if (void 0 !== e19 || t24) return;
    pe(n19, i24, o12);
  }(e18, t23, r10, a24, i23);
}
function pe(e18, t23, n18) {
  const i23 = `No bindings found for service: "${t8(e18)}".

Trying to resolve bindings for "${fe(e18, t23)}".

${ge(n18)}`;
  throw new T2(S3.planning, i23);
}
function fe(e18, t23) {
  return void 0 === t23 ? `${t8(e18)} (Root service)` : t8(t23);
}
function ge(e18) {
  var _a7;
  const t23 = 0 === e18.tags.size ? "" : `
- tags:
  - ${[...e18.tags.keys()].map((e19) => e19.toString()).join("\n  - ")}`;
  return `Binding constraints:
- service identifier: ${t8(e18.serviceIdentifier)}
- name: ${((_a7 = e18.name) == null ? void 0 : _a7.toString()) ?? "-"}${t23}`;
}
function me(e18, t23, n18) {
  if (1 !== e18.redirections.length) le(e18.redirections, t23, e18, n18);
  else {
    const [i23] = e18.redirections;
    de(i23) && me(i23, t23, n18);
  }
}
function he(e18, t23, n18) {
  if (Array.isArray(e18.bindings) && 1 === e18.bindings.length) {
    const [i23] = e18.bindings;
    de(i23) && me(i23, t23, n18);
  } else le(e18.bindings, t23, e18, n18);
}
function ve(e18, t23) {
  if (function(e19) {
    return e19 instanceof Error && (e19 instanceof RangeError && /stack space|call stack|too much recursion/i.test(e19.message) || "InternalError" === e19.name && /too much recursion/.test(e19.message));
  }(t23)) {
    const n18 = function(e19) {
      const t24 = [...e19];
      if (0 === t24.length) return "(No dependency trace)";
      return t24.map(t8).join(" -> ");
    }(function(e19) {
      const t24 = /* @__PURE__ */ new Set();
      for (const n19 of e19.servicesBranch) {
        if (t24.has(n19)) return [...t24, n19];
        t24.add(n19);
      }
      return [...t24];
    }(e18));
    throw new T2(S3.planning, `Circular dependency found: ${n18}`, { cause: t23 });
  }
  throw t23;
}
function ye(e18) {
  try {
    const t23 = /* @__PURE__ */ new Map();
    void 0 !== e18.rootConstraints.tag && t23.set(e18.rootConstraints.tag.key, e18.rootConstraints.tag.value);
    const n18 = new ce({ elem: { name: e18.rootConstraints.name, serviceIdentifier: e18.rootConstraints.serviceIdentifier, tags: t23 }, previous: void 0 }), i23 = new se(n18.last), o12 = ue(e18, i23), r10 = [], a24 = { bindings: r10, parent: void 0, serviceIdentifier: e18.rootConstraints.serviceIdentifier };
    if (r10.push(...je(e18, n18, o12, a24)), !e18.rootConstraints.isMultiple) {
      he(a24, e18.rootConstraints.isOptional ?? false, i23);
      const [t24] = r10;
      a24.bindings = t24;
    }
    return { tree: { root: a24 } };
  } catch (t23) {
    ve(e18, t23);
  }
}
function Me(e18, t23, n18, i23) {
  const o12 = { binding: t23, classMetadata: e18.getClassMetadata(t23.implementationType), constructorParams: [], parent: i23, propertyParams: /* @__PURE__ */ new Map() };
  return Se({ autobindOptions: e18.autobindOptions, getBindings: e18.getBindings, getClassMetadata: e18.getClassMetadata, node: o12, servicesBranch: e18.servicesBranch, setBinding: e18.setBinding }, n18);
}
function Ie(e18, t23, n18) {
  if (n18.kind === C.unmanaged) return;
  const i23 = r3.is(n18.value) ? n18.value.unwrap() : n18.value, o12 = t23.concat({ name: n18.name, serviceIdentifier: i23, tags: n18.tags }), a24 = new se(o12.last), s25 = ue(e18, a24), c21 = [], u14 = { bindings: c21, parent: e18.node, serviceIdentifier: i23 };
  if (c21.push(...je(e18, o12, s25, u14)), n18.kind === C.singleInjection) {
    he(u14, n18.optional, a24);
    const [e19] = c21;
    u14.bindings = e19;
  }
  return u14;
}
function we(e18, t23, n18) {
  const i23 = r3.is(n18.value) ? n18.value.unwrap() : n18.value, o12 = t23.concat({ name: n18.name, serviceIdentifier: i23, tags: n18.tags }), a24 = new se(o12.last), s25 = ue(e18, a24), c21 = [], u14 = { bindings: c21, parent: e18.node, serviceIdentifier: i23 };
  if (c21.push(...je(e18, o12, s25, u14)), n18.kind === ae.singleInjection) {
    he(u14, n18.optional, a24);
    const [e19] = c21;
    u14.bindings = e19;
  }
  return u14;
}
function be(e18, t23, n18, i23) {
  const o12 = { binding: t23, params: [], parent: i23 };
  return Se({ autobindOptions: e18.autobindOptions, getBindings: e18.getBindings, getClassMetadata: e18.getClassMetadata, node: o12, servicesBranch: e18.servicesBranch, setBinding: e18.setBinding }, n18);
}
function je(e18, t23, n18, i23) {
  const o12 = de(i23) ? i23.binding.targetServiceIdentifier : i23.serviceIdentifier;
  e18.servicesBranch.push(o12);
  const r10 = [];
  for (const o13 of n18) switch (o13.type) {
    case d3.Instance:
      r10.push(Me(e18, o13, t23, i23));
      break;
    case d3.ResolvedValue:
      r10.push(be(e18, o13, t23, i23));
      break;
    case d3.ServiceRedirection: {
      const n19 = Te(e18, t23, o13, i23);
      r10.push(n19);
      break;
    }
    default:
      r10.push({ binding: o13, parent: i23 });
  }
  return e18.servicesBranch.pop(), r10;
}
function Te(e18, t23, n18, i23) {
  const o12 = { binding: n18, parent: i23, redirections: [] }, r10 = ue(e18, new se(t23.last), { customServiceIdentifier: n18.targetServiceIdentifier });
  return o12.redirections.push(...je(e18, t23, r10, o12)), o12;
}
function Se(e18, t23) {
  return e18.node.binding.type === d3.Instance ? function(e19, t24, n18) {
    const i23 = t24.classMetadata;
    for (const [o12, r10] of i23.constructorArguments.entries()) t24.constructorParams[o12] = Ie(e19, n18, r10);
    for (const [o12, r10] of i23.properties) {
      const i24 = Ie(e19, n18, r10);
      void 0 !== i24 && t24.propertyParams.set(o12, i24);
    }
    return e19.node;
  }(e18, e18.node, t23) : function(e19, t24, n18) {
    const i23 = t24.binding.metadata;
    for (const [o12, r10] of i23.arguments.entries()) t24.params[o12] = we(e19, n18, r10);
    return e19.node;
  }(e18, e18.node, t23);
}
var Ae;
!function(e18) {
  e18[e18.singleMandatory = 0] = "singleMandatory", e18[e18.singleOptional = 1] = "singleOptional", e18[e18.multipleMandatory = 2] = "multipleMandatory", e18[e18.multipleOptional = 3] = "multipleOptional", e18[e18.length = 4] = "length";
}(Ae || (Ae = {}));
var _f, _g, _m, _h2, _v2, _Ce_instances, y_fn, w_fn, I_fn, M_fn, b_fn;
var Ce = class {
  constructor() {
    __privateAdd(this, _Ce_instances);
    __privateAdd(this, _f);
    __privateAdd(this, _g);
    __privateAdd(this, _m);
    __privateAdd(this, _h2);
    __privateAdd(this, _v2);
    __privateSet(this, _f, __privateMethod(this, _Ce_instances, y_fn).call(this)), __privateSet(this, _g, __privateMethod(this, _Ce_instances, y_fn).call(this)), __privateSet(this, _h2, __privateMethod(this, _Ce_instances, y_fn).call(this)), __privateSet(this, _m, __privateMethod(this, _Ce_instances, y_fn).call(this)), __privateSet(this, _v2, []);
  }
  clearCache() {
    for (const e18 of __privateMethod(this, _Ce_instances, M_fn).call(this)) e18.clear();
    for (const e18 of __privateGet(this, _v2)) e18.clearCache();
  }
  get(e18) {
    var _a7, _b4, _c3, _d3, _e5, _f3;
    return void 0 === e18.name ? void 0 === e18.tag ? __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _f), e18).get(e18.serviceIdentifier) : (_b4 = (_a7 = __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _m), e18).get(e18.serviceIdentifier)) == null ? void 0 : _a7.get(e18.tag.key)) == null ? void 0 : _b4.get(e18.tag.value) : void 0 === e18.tag ? (_c3 = __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _g), e18).get(e18.serviceIdentifier)) == null ? void 0 : _c3.get(e18.name) : (_f3 = (_e5 = (_d3 = __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _h2), e18).get(e18.serviceIdentifier)) == null ? void 0 : _d3.get(e18.name)) == null ? void 0 : _e5.get(e18.tag.key)) == null ? void 0 : _f3.get(e18.tag.value);
  }
  set(e18, t23) {
    void 0 === e18.name ? void 0 === e18.tag ? __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _f), e18).set(e18.serviceIdentifier, t23) : __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _m), e18), e18.serviceIdentifier), e18.tag.key).set(e18.tag.value, t23) : void 0 === e18.tag ? __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _g), e18), e18.serviceIdentifier).set(e18.name, t23) : __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, w_fn).call(this, __privateMethod(this, _Ce_instances, I_fn).call(this, __privateGet(this, _h2), e18), e18.serviceIdentifier), e18.name), e18.tag.key).set(e18.tag.value, t23);
  }
  subscribe(e18) {
    __privateGet(this, _v2).push(e18);
  }
};
_f = new WeakMap();
_g = new WeakMap();
_m = new WeakMap();
_h2 = new WeakMap();
_v2 = new WeakMap();
_Ce_instances = new WeakSet();
y_fn = function() {
  const e18 = new Array(Ae.length);
  for (let t23 = 0; t23 < e18.length; ++t23) e18[t23] = /* @__PURE__ */ new Map();
  return e18;
};
w_fn = function(e18, t23) {
  let n18 = e18.get(t23);
  return void 0 === n18 && (n18 = /* @__PURE__ */ new Map(), e18.set(t23, n18)), n18;
};
I_fn = function(e18, t23) {
  return e18[__privateMethod(this, _Ce_instances, b_fn).call(this, t23)];
};
M_fn = function() {
  return [...__privateGet(this, _f), ...__privateGet(this, _g), ...__privateGet(this, _h2), ...__privateGet(this, _m)];
};
b_fn = function(e18) {
  return e18.isMultiple ? true === e18.optional ? Ae.multipleOptional : Ae.multipleMandatory : true === e18.optional ? Ae.singleOptional : Ae.singleMandatory;
};
function $e(e18, t23) {
  return e4(t23) ? (e18.cache = { isRight: true, value: t23 }, t23.then((t24) => xe(e18, t24))) : xe(e18, t23);
}
function xe(e18, t23) {
  return e18.cache = { isRight: true, value: t23 }, t23;
}
function Re(e18, t23, n18) {
  const i23 = e18.getActivations(t23);
  return void 0 === i23 ? n18 : e4(n18) ? Be(e18, n18, i23[Symbol.iterator]()) : function(e19, t24, n19) {
    let i24 = t24, o12 = n19.next();
    for (; true !== o12.done; ) {
      const t25 = o12.value(e19.context, i24);
      if (e4(t25)) return Be(e19, t25, n19);
      i24 = t25, o12 = n19.next();
    }
    return i24;
  }(e18, n18, i23[Symbol.iterator]());
}
async function Be(e18, t23, n18) {
  let i23 = await t23, o12 = n18.next();
  for (; true !== o12.done; ) i23 = await o12.value(e18.context, i23), o12 = n18.next();
  return i23;
}
function ke(e18, t23, n18) {
  let i23 = n18;
  if (void 0 !== t23.onActivation) {
    const n19 = t23.onActivation;
    i23 = e4(i23) ? i23.then((t24) => n19(e18.context, t24)) : n19(e18.context, i23);
  }
  return Re(e18, t23.serviceIdentifier, i23);
}
function Pe(e18) {
  return (t23, n18) => {
    if (n18.cache.isRight) return n18.cache.value;
    return $e(n18, ke(t23, n18, e18(t23, n18)));
  };
}
var De = Pe(function(e18, t23) {
  return t23.value;
});
function Fe(e18) {
  return e18;
}
function Oe(e18, t23) {
  return (n18, i23) => {
    const o12 = e18(i23);
    switch (o12.scope) {
      case u4.Singleton:
        if (o12.cache.isRight) return o12.cache.value;
        return $e(o12, ke(n18, o12, t23(n18, i23)));
      case u4.Request: {
        if (n18.requestScopeCache.has(o12.id)) return n18.requestScopeCache.get(o12.id);
        const e19 = ke(n18, o12, t23(n18, i23));
        return n18.requestScopeCache.set(o12.id, e19), e19;
      }
      case u4.Transient:
        return ke(n18, o12, t23(n18, i23));
    }
  };
}
var Ve = ((e18) => Oe(Fe, e18))(function(e18, t23) {
  return t23.value(e18.context);
});
var Ee = Pe(function(e18, t23) {
  return t23.factory(e18.context);
});
function Ne(e18, t23, n18) {
  const i23 = function(e19, t24, n19) {
    if (void 0 === n19) return;
    if (!(n19 in e19)) throw new T2(S3.resolution, `Expecting a "${n19.toString()}" property when resolving "${t24.implementationType.name}" class @postConstruct decorated method, none found.`);
    if ("function" != typeof e19[n19]) throw new T2(S3.resolution, `Expecting a "${n19.toString()}" method when resolving "${t24.implementationType.name}" class @postConstruct decorated method, a non function property was found instead.`);
    {
      let i24;
      try {
        i24 = e19[n19]();
      } catch (e20) {
        throw new T2(S3.resolution, `Unexpected error found when calling "${n19.toString()}" @postConstruct decorated method on class "${t24.implementationType.name}"`, { cause: e20 });
      }
      if (e4(i24)) return async function(e20, t25, n20) {
        try {
          await n20;
        } catch (n21) {
          throw new T2(S3.resolution, `Unexpected error found when calling "${t25.toString()}" @postConstruct decorated method on class "${e20.implementationType.name}"`, { cause: n21 });
        }
      }(t24, n19, i24);
    }
  }(e18, t23, n18);
  return e4(i23) ? i23.then(() => e18) : e18;
}
function Ue(e18) {
  return (t23, n18, i23) => {
    const o12 = new i23.binding.implementationType(...t23), r10 = e18(n18, o12, i23);
    return e4(r10) ? r10.then(() => Ne(o12, i23.binding, i23.classMetadata.lifecycle.postConstructMethodName)) : Ne(o12, i23.binding, i23.classMetadata.lifecycle.postConstructMethodName);
  };
}
var Ke = Pe(function(e18, t23) {
  return t23.provider(e18.context);
});
function qe(e18) {
  return e18.binding;
}
function ze(e18) {
  return e18.binding;
}
var Ge = /* @__PURE__ */ function(e18) {
  return (t23, n18, i23) => {
    const o12 = [];
    for (const [r10, s25] of i23.propertyParams) {
      const c21 = i23.classMetadata.properties.get(r10);
      if (void 0 === c21) throw new T2(S3.resolution, `Expecting metadata at property "${r10.toString()}", none found`);
      c21.kind !== C.unmanaged && void 0 !== s25.bindings && (n18[r10] = e18(t23, s25), e4(n18[r10]) && o12.push((async () => {
        n18[r10] = await n18[r10];
      })()));
    }
    if (o12.length > 0) return Promise.all(o12).then(() => {
    });
  };
}(Ye);
var _e3 = /* @__PURE__ */ function(e18) {
  return function t23(n18, i23) {
    const o12 = [];
    for (const r10 of i23.redirections) de(r10) ? o12.push(...t23(n18, r10)) : o12.push(e18(n18, r10));
    return o12;
  };
}(We);
var Xe = /* @__PURE__ */ function(e18, t23, n18) {
  return (i23, o12) => {
    const r10 = e18(i23, o12);
    return e4(r10) ? t23(r10, i23, o12) : n18(r10, i23, o12);
  };
}(/* @__PURE__ */ function(e18) {
  return (t23, n18) => {
    const i23 = [];
    for (const o12 of n18.constructorParams) void 0 === o12 ? i23.push(void 0) : i23.push(e18(t23, o12));
    return i23.some(e4) ? Promise.all(i23) : i23;
  };
}(Ye), /* @__PURE__ */ function(e18) {
  return async (t23, n18, i23) => {
    const o12 = await t23;
    return e18(o12, n18, i23);
  };
}(Ue(Ge)), Ue(Ge));
var He = /* @__PURE__ */ function(e18) {
  return (t23, n18) => {
    const i23 = e18(t23, n18);
    return e4(i23) ? i23.then((e19) => n18.binding.factory(...e19)) : n18.binding.factory(...i23);
  };
}(/* @__PURE__ */ function(e18) {
  return (t23, n18) => {
    const i23 = [];
    for (const o12 of n18.params) i23.push(e18(t23, o12));
    return i23.some(e4) ? Promise.all(i23) : i23;
  };
}(Ye));
var Je = ((e18) => Oe(qe, e18))(Xe);
var Le = ((e18) => Oe(ze, e18))(He);
function Qe(e18) {
  return Ye(e18, e18.planResult.tree.root);
}
function We(e18, t23) {
  switch (t23.binding.type) {
    case d3.ConstantValue:
      return De(e18, t23.binding);
    case d3.DynamicValue:
      return Ve(e18, t23.binding);
    case d3.Factory:
      return Ee(e18, t23.binding);
    case d3.Instance:
      return Je(e18, t23);
    case d3.Provider:
      return Ke(e18, t23.binding);
    case d3.ResolvedValue:
      return Le(e18, t23);
  }
}
function Ye(e18, t23) {
  if (void 0 !== t23.bindings) return Array.isArray(t23.bindings) ? function(e19, t24) {
    const n18 = [];
    for (const i23 of t24) de(i23) ? n18.push(..._e3(e19, i23)) : n18.push(We(e19, i23));
    if (n18.some(e4)) return Promise.all(n18);
    return n18;
  }(e18, t23.bindings) : function(e19, t24) {
    if (de(t24)) {
      const n18 = _e3(e19, t24);
      if (1 === n18.length) return n18[0];
      throw new T2(S3.resolution, "Unexpected multiple resolved values on single injection");
    }
    return We(e19, t24);
  }(e18, t23.bindings);
}
function Ze(e18) {
  return void 0 !== e18.scope;
}
function et(e18, t23) {
  if (void 0 !== e18.lifecycle.preDestroyMethodName && "function" == typeof t23[e18.lifecycle.preDestroyMethodName]) return t23[e18.lifecycle.preDestroyMethodName]();
}
function tt(e18, t23, n18) {
  const i23 = e18.getDeactivations(t23);
  if (void 0 !== i23) return e4(n18) ? nt(n18, i23[Symbol.iterator]()) : function(e19, t24) {
    let n19 = t24.next();
    for (; true !== n19.done; ) {
      const i24 = n19.value(e19);
      if (e4(i24)) return nt(e19, t24);
      n19 = t24.next();
    }
  }(n18, i23[Symbol.iterator]());
}
async function nt(e18, t23) {
  const n18 = await e18;
  let i23 = t23.next();
  for (; true !== i23.done; ) await i23.value(n18), i23 = t23.next();
}
function it(e18, t23) {
  const n18 = function(e19, t24) {
    if (t24.type === d3.Instance) {
      const n19 = e19.getClassMetadata(t24.implementationType), i23 = t24.cache.value;
      return e4(i23) ? i23.then((e20) => et(n19, e20)) : et(n19, i23);
    }
  }(e18, t23);
  return void 0 === n18 ? ot(e18, t23) : n18.then(() => ot(e18, t23));
}
function ot(e18, t23) {
  const n18 = t23.cache;
  return e4(n18.value) ? n18.value.then((n19) => rt(e18, t23, n19)) : rt(e18, t23, n18.value);
}
function rt(e18, t23, n18) {
  let i23;
  if (void 0 !== t23.onDeactivation) {
    i23 = (0, t23.onDeactivation)(n18);
  }
  return void 0 === i23 ? tt(e18, t23.serviceIdentifier, n18) : i23.then(() => tt(e18, t23.serviceIdentifier, n18));
}
function at(e18, t23) {
  if (void 0 === t23) return;
  const n18 = function(e19) {
    const t24 = [];
    for (const n19 of e19) Ze(n19) && n19.scope === u4.Singleton && n19.cache.isRight && t24.push(n19);
    return t24;
  }(t23), i23 = [];
  for (const t24 of n18) {
    const n19 = it(e18, t24);
    void 0 !== n19 && i23.push(n19);
  }
  return i23.length > 0 ? Promise.all(i23).then(() => {
  }) : void 0;
}
function st(e18, t23) {
  const n18 = e18.getBindingsFromModule(t23);
  return at(e18, n18);
}
function ct(e18, t23) {
  const n18 = e18.getBindings(t23);
  return at(e18, n18);
}

// node_modules/@inversifyjs/container/lib/esm/index.js
var m2 = "@inversifyjs/container/bindingId";
var _i, _e4;
var w6 = class {
  constructor(t23) {
    __privateAdd(this, _i);
    __privateAdd(this, _e4);
    __privateSet(this, _i, function() {
      const t24 = t9(Object, m2) ?? 0;
      return t24 === Number.MAX_SAFE_INTEGER ? n6(Object, m2, Number.MIN_SAFE_INTEGER) : a10(Object, m2, () => t24, (i23) => i23 + 1), t24;
    }()), __privateSet(this, _e4, t23);
  }
  get id() {
    return __privateGet(this, _i);
  }
  load(i23) {
    return __privateGet(this, _e4).call(this, i23);
  }
};
_i = new WeakMap();
_e4 = new WeakMap();
var I3 = Symbol.for("@inversifyjs/container/bindingIdentifier");
function A6(i23) {
  return "object" == typeof i23 && null !== i23 && true === i23[I3];
}
var P3 = class {
};
__publicField(P3, "always", (i23) => true);
function B2(i23) {
  return { [I3]: true, id: i23.id };
}
function C2(i23) {
  return (e18) => {
    for (let n18 = e18.getAncestor(); void 0 !== n18; n18 = n18.getAncestor()) if (i23(n18)) return true;
    return false;
  };
}
function R5(i23) {
  return (e18) => e18.name === i23;
}
function M3(i23) {
  return (e18) => e18.serviceIdentifier === i23;
}
function x4(i23, e18) {
  return (n18) => n18.tags.has(i23) && n18.tags.get(i23) === e18;
}
function O3(i23) {
  return void 0 === i23.name && 0 === i23.tags.size;
}
function N2(i23) {
  const e18 = C2(i23);
  return (i24) => !e18(i24);
}
function U2(i23) {
  return (e18) => {
    const n18 = e18.getAncestor();
    return void 0 === n18 || !i23(n18);
  };
}
function F2(i23) {
  return (e18) => {
    const n18 = e18.getAncestor();
    return void 0 !== n18 && i23(n18);
  };
}
var _n2;
var k4 = class {
  constructor(i23) {
    __privateAdd(this, _n2);
    __privateSet(this, _n2, i23);
  }
  getIdentifier() {
    return B2(__privateGet(this, _n2));
  }
  inRequestScope() {
    return __privateGet(this, _n2).scope = u4.Request, new V2(__privateGet(this, _n2));
  }
  inSingletonScope() {
    return __privateGet(this, _n2).scope = u4.Singleton, new V2(__privateGet(this, _n2));
  }
  inTransientScope() {
    return __privateGet(this, _n2).scope = u4.Transient, new V2(__privateGet(this, _n2));
  }
};
_n2 = new WeakMap();
var _t2, _s, _r, _a5, _D_instances, o_fn2;
var D3 = class {
  constructor(i23, e18, n18, t23) {
    __privateAdd(this, _D_instances);
    __privateAdd(this, _t2);
    __privateAdd(this, _s);
    __privateAdd(this, _r);
    __privateAdd(this, _a5);
    __privateSet(this, _t2, i23), __privateSet(this, _s, e18), __privateSet(this, _r, n18), __privateSet(this, _a5, t23);
  }
  to(i23) {
    const e18 = $(i23), n18 = { cache: { isRight: false, value: void 0 }, id: c5(), implementationType: i23, isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, scope: e18.scope ?? __privateGet(this, _r), serviceIdentifier: __privateGet(this, _a5), type: d3.Instance };
    return __privateGet(this, _t2).call(this, n18), new E8(n18);
  }
  toSelf() {
    if ("function" != typeof __privateGet(this, _a5)) throw new Error('"toSelf" function can only be applied when a newable function is used as service identifier');
    return this.to(__privateGet(this, _a5));
  }
  toConstantValue(i23) {
    const e18 = { cache: { isRight: false, value: void 0 }, id: c5(), isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, scope: u4.Singleton, serviceIdentifier: __privateGet(this, _a5), type: d3.ConstantValue, value: i23 };
    return __privateGet(this, _t2).call(this, e18), new V2(e18);
  }
  toDynamicValue(i23) {
    const e18 = { cache: { isRight: false, value: void 0 }, id: c5(), isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, scope: __privateGet(this, _r), serviceIdentifier: __privateGet(this, _a5), type: d3.DynamicValue, value: i23 };
    return __privateGet(this, _t2).call(this, e18), new E8(e18);
  }
  toResolvedValue(i23, e18) {
    const n18 = { cache: { isRight: false, value: void 0 }, factory: i23, id: c5(), isSatisfiedBy: P3.always, metadata: __privateMethod(this, _D_instances, o_fn2).call(this, e18), moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, scope: __privateGet(this, _r), serviceIdentifier: __privateGet(this, _a5), type: d3.ResolvedValue };
    return __privateGet(this, _t2).call(this, n18), new E8(n18);
  }
  toFactory(i23) {
    const e18 = { cache: { isRight: false, value: void 0 }, factory: i23, id: c5(), isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, scope: u4.Singleton, serviceIdentifier: __privateGet(this, _a5), type: d3.Factory };
    return __privateGet(this, _t2).call(this, e18), new V2(e18);
  }
  toProvider(i23) {
    const e18 = { cache: { isRight: false, value: void 0 }, id: c5(), isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), onActivation: void 0, onDeactivation: void 0, provider: i23, scope: u4.Singleton, serviceIdentifier: __privateGet(this, _a5), type: d3.Provider };
    return __privateGet(this, _t2).call(this, e18), new V2(e18);
  }
  toService(i23) {
    const e18 = { id: c5(), isSatisfiedBy: P3.always, moduleId: __privateGet(this, _s), serviceIdentifier: __privateGet(this, _a5), targetServiceIdentifier: i23, type: d3.ServiceRedirection };
    __privateGet(this, _t2).call(this, e18);
  }
};
_t2 = new WeakMap();
_s = new WeakMap();
_r = new WeakMap();
_a5 = new WeakMap();
_D_instances = new WeakSet();
o_fn2 = function(i23) {
  return { arguments: (i23 ?? []).map((i24) => function(i25) {
    return "object" == typeof i25 && !r3.is(i25);
  }(i24) ? { kind: true === i24.isMultiple ? ae.multipleInjection : ae.singleInjection, name: i24.name, optional: i24.optional ?? false, tags: new Map((i24.tags ?? []).map((i25) => [i25.key, i25.value])), value: i24.serviceIdentifier } : { kind: ae.singleInjection, name: void 0, optional: false, tags: /* @__PURE__ */ new Map(), value: i24 }) };
};
var _n3;
var j3 = class {
  constructor(i23) {
    __privateAdd(this, _n3);
    __privateSet(this, _n3, i23);
  }
  getIdentifier() {
    return B2(__privateGet(this, _n3));
  }
  onActivation(i23) {
    return __privateGet(this, _n3).onActivation = i23, new T3(__privateGet(this, _n3));
  }
  onDeactivation(i23) {
    return __privateGet(this, _n3).onDeactivation = i23, new T3(__privateGet(this, _n3));
  }
};
_n3 = new WeakMap();
var _n4;
var T3 = class {
  constructor(i23) {
    __privateAdd(this, _n4);
    __privateSet(this, _n4, i23);
  }
  getIdentifier() {
    return B2(__privateGet(this, _n4));
  }
  when(i23) {
    return __privateGet(this, _n4).isSatisfiedBy = i23, new j3(__privateGet(this, _n4));
  }
  whenAnyAncestor(i23) {
    return this.when(C2(i23));
  }
  whenAnyAncestorIs(i23) {
    return this.when(C2(M3(i23)));
  }
  whenAnyAncestorNamed(i23) {
    return this.when(function(i24) {
      return C2(R5(i24));
    }(i23));
  }
  whenAnyAncestorTagged(i23, e18) {
    return this.when(function(i24, e19) {
      return C2(x4(i24, e19));
    }(i23, e18));
  }
  whenDefault() {
    return this.when(O3);
  }
  whenNamed(i23) {
    return this.when(R5(i23));
  }
  whenNoParent(i23) {
    return this.when(U2(i23));
  }
  whenNoParentIs(i23) {
    return this.when(U2(M3(i23)));
  }
  whenNoParentNamed(i23) {
    return this.when(function(i24) {
      return U2(R5(i24));
    }(i23));
  }
  whenNoParentTagged(i23, e18) {
    return this.when(function(i24, e19) {
      return U2(x4(i24, e19));
    }(i23, e18));
  }
  whenParent(i23) {
    return this.when(F2(i23));
  }
  whenParentIs(i23) {
    return this.when(F2(M3(i23)));
  }
  whenParentNamed(i23) {
    return this.when(function(i24) {
      return F2(R5(i24));
    }(i23));
  }
  whenParentTagged(i23, e18) {
    return this.when(function(i24, e19) {
      return F2(x4(i24, e19));
    }(i23, e18));
  }
  whenTagged(i23, e18) {
    return this.when(x4(i23, e18));
  }
  whenNoAncestor(i23) {
    return this.when(N2(i23));
  }
  whenNoAncestorIs(i23) {
    return this.when(N2(M3(i23)));
  }
  whenNoAncestorNamed(i23) {
    return this.when(function(i24) {
      return N2(R5(i24));
    }(i23));
  }
  whenNoAncestorTagged(i23, e18) {
    return this.when(function(i24, e19) {
      return N2(x4(i24, e19));
    }(i23, e18));
  }
};
_n4 = new WeakMap();
var _d2;
var V2 = class extends T3 {
  constructor(i23) {
    super(i23);
    __privateAdd(this, _d2);
    __privateSet(this, _d2, new j3(i23));
  }
  onActivation(i23) {
    return __privateGet(this, _d2).onActivation(i23);
  }
  onDeactivation(i23) {
    return __privateGet(this, _d2).onDeactivation(i23);
  }
};
_d2 = new WeakMap();
var _c2;
var E8 = class extends V2 {
  constructor(i23) {
    super(i23);
    __privateAdd(this, _c2);
    __privateSet(this, _c2, new k4(i23));
  }
  inRequestScope() {
    return __privateGet(this, _c2).inRequestScope();
  }
  inSingletonScope() {
    return __privateGet(this, _c2).inSingletonScope();
  }
  inTransientScope() {
    return __privateGet(this, _c2).inTransientScope();
  }
};
_c2 = new WeakMap();
var q2 = Symbol.for("@inversifyjs/container/InversifyContainerError");
var _a6, _b2;
var G = class _G extends (_b2 = Error, _a6 = q2, _b2) {
  constructor(i23, e18, n18) {
    super(e18, n18);
    __publicField(this, _a6);
    __publicField(this, "kind");
    this[q2] = true, this.kind = i23;
  }
  static is(i23) {
    return "object" == typeof i23 && null !== i23 && true === i23[q2];
  }
  static isErrorOfKind(i23, e18) {
    return _G.is(i23) && i23.kind === e18;
  }
};
var $2;
!function(i23) {
  i23[i23.invalidOperation = 0] = "invalidOperation";
}($2 || ($2 = {}));
var _2 = u4.Transient;
var _l2, _u4, _h3, _v3, _g2, _b3, _f2, _S, _p3, _y2, _m2, _L_instances, U_fn, w_fn2, F_fn, k_fn, P_fn, I_fn2, B_fn, D_fn, C_fn, e_fn, O_fn, R_fn, A_fn, x_fn, M_fn2, j_fn, V_fn, N_fn, T_fn, E_fn;
var L2 = class {
  constructor(i23) {
    __privateAdd(this, _L_instances);
    __privateAdd(this, _l2);
    __privateAdd(this, _u4);
    __privateAdd(this, _h3);
    __privateAdd(this, _v3);
    __privateAdd(this, _g2);
    __privateAdd(this, _b3);
    __privateAdd(this, _f2);
    __privateAdd(this, _S);
    __privateAdd(this, _p3);
    __privateAdd(this, _y2);
    __privateAdd(this, _m2);
    __privateSet(this, _h3, __privateMethod(this, _L_instances, w_fn2).call(this)), __privateSet(this, _g2, (i24) => __privateGet(this, _l2).get(i24)), __privateSet(this, _S, new Ce()), __privateSet(this, _p3, __privateMethod(this, _L_instances, I_fn2).call(this)), void 0 === (i23 == null ? void 0 : i23.parent) ? (__privateSet(this, _l2, h2.build(void 0)), __privateSet(this, _u4, v3.build(void 0)), __privateSet(this, _v3, y3.build(void 0))) : (__privateSet(this, _l2, h2.build(__privateGet(i23.parent, _l2))), __privateSet(this, _u4, v3.build(__privateGet(i23.parent, _u4))), __privateSet(this, _v3, y3.build(__privateGet(i23.parent, _v3))), __privateGet(i23.parent, _S).subscribe(__privateGet(this, _S))), __privateSet(this, _b3, __privateGet(this, _u4).get.bind(__privateGet(this, _u4))), __privateSet(this, _y2, __privateMethod(this, _L_instances, A_fn).bind(this)), __privateSet(this, _f2, { autobind: (i23 == null ? void 0 : i23.autobind) ?? false, defaultScope: (i23 == null ? void 0 : i23.defaultScope) ?? _2 }), __privateSet(this, _m2, []);
  }
  bind(i23) {
    return new D3((i24) => {
      __privateMethod(this, _L_instances, A_fn).call(this, i24);
    }, void 0, __privateGet(this, _f2).defaultScope, i23);
  }
  get(i23, e18) {
    const n18 = __privateMethod(this, _L_instances, P_fn).call(this, false, i23, e18), t23 = __privateMethod(this, _L_instances, B_fn).call(this, n18);
    if (e4(t23)) throw new G($2.invalidOperation, `Unexpected asyncronous service when resolving service "${t8(i23)}"`);
    return t23;
  }
  getAll(i23, e18) {
    const n18 = __privateMethod(this, _L_instances, P_fn).call(this, true, i23, e18), t23 = __privateMethod(this, _L_instances, B_fn).call(this, n18);
    if (e4(t23)) throw new G($2.invalidOperation, `Unexpected asyncronous service when resolving service "${t8(i23)}"`);
    return t23;
  }
  async getAllAsync(i23, e18) {
    const n18 = __privateMethod(this, _L_instances, P_fn).call(this, true, i23, e18);
    return __privateMethod(this, _L_instances, B_fn).call(this, n18);
  }
  async getAsync(i23, e18) {
    const n18 = __privateMethod(this, _L_instances, P_fn).call(this, false, i23, e18);
    return __privateMethod(this, _L_instances, B_fn).call(this, n18);
  }
  isBound(i23, e18) {
    const n18 = __privateGet(this, _u4).get(i23);
    return __privateMethod(this, _L_instances, C_fn).call(this, i23, n18, e18);
  }
  isCurrentBound(i23, e18) {
    const n18 = __privateGet(this, _u4).getNonParentBindings(i23);
    return __privateMethod(this, _L_instances, C_fn).call(this, i23, n18, e18);
  }
  async load(...i23) {
    await Promise.all(__privateMethod(this, _L_instances, e_fn).call(this, ...i23));
  }
  loadSync(...i23) {
    const e18 = __privateMethod(this, _L_instances, e_fn).call(this, ...i23);
    for (const i24 of e18) if (void 0 !== i24) throw new G($2.invalidOperation, "Unexpected asyncronous module load. Consider using Container.load() instead.");
  }
  onActivation(i23, e18) {
    __privateGet(this, _l2).add(e18, { serviceId: i23 });
  }
  onDeactivation(i23, e18) {
    __privateGet(this, _v3).add(e18, { serviceId: i23 });
  }
  restore() {
    const i23 = __privateGet(this, _m2).pop();
    if (void 0 === i23) throw new G($2.invalidOperation, "No snapshot available to restore");
    __privateSet(this, _l2, i23.activationService), __privateSet(this, _u4, i23.bindingService), __privateSet(this, _v3, i23.deactivationService), __privateMethod(this, _L_instances, R_fn).call(this);
  }
  async rebind(i23) {
    return await this.unbind(i23), this.bind(i23);
  }
  rebindSync(i23) {
    return this.unbindSync(i23), this.bind(i23);
  }
  snapshot() {
    __privateGet(this, _m2).push({ activationService: __privateGet(this, _l2).clone(), bindingService: __privateGet(this, _u4).clone(), deactivationService: __privateGet(this, _v3).clone() });
  }
  async unbind(i23) {
    await __privateMethod(this, _L_instances, M_fn2).call(this, i23);
  }
  async unbindAll() {
    const i23 = [...__privateGet(this, _u4).getNonParentBoundServices()];
    await Promise.all(i23.map(async (i24) => ct(__privateGet(this, _h3), i24)));
    for (const e18 of i23) __privateGet(this, _l2).removeAllByServiceId(e18), __privateGet(this, _u4).removeAllByServiceId(e18), __privateGet(this, _v3).removeAllByServiceId(e18);
    __privateGet(this, _S).clearCache();
  }
  unbindSync(i23) {
    void 0 !== __privateMethod(this, _L_instances, M_fn2).call(this, i23) && __privateMethod(this, _L_instances, x_fn).call(this, i23);
  }
  async unload(...i23) {
    await Promise.all(__privateMethod(this, _L_instances, O_fn).call(this, ...i23)), __privateMethod(this, _L_instances, N_fn).call(this, i23);
  }
  unloadSync(...i23) {
    const e18 = __privateMethod(this, _L_instances, O_fn).call(this, ...i23);
    for (const i24 of e18) if (void 0 !== i24) throw new G($2.invalidOperation, "Unexpected asyncronous module unload. Consider using Container.unload() instead.");
    __privateMethod(this, _L_instances, N_fn).call(this, i23);
  }
};
_l2 = new WeakMap();
_u4 = new WeakMap();
_h3 = new WeakMap();
_v3 = new WeakMap();
_g2 = new WeakMap();
_b3 = new WeakMap();
_f2 = new WeakMap();
_S = new WeakMap();
_p3 = new WeakMap();
_y2 = new WeakMap();
_m2 = new WeakMap();
_L_instances = new WeakSet();
U_fn = function(i23) {
  return { bind: (e18) => new D3((i24) => {
    __privateMethod(this, _L_instances, A_fn).call(this, i24);
  }, i23, __privateGet(this, _f2).defaultScope, e18), isBound: this.isBound.bind(this), onActivation: (e18, n18) => {
    __privateGet(this, _l2).add(n18, { moduleId: i23, serviceId: e18 });
  }, onDeactivation: (e18, n18) => {
    __privateGet(this, _v3).add(n18, { moduleId: i23, serviceId: e18 });
  }, rebind: this.rebind.bind(this), rebindSync: this.rebindSync.bind(this), unbind: this.unbind.bind(this), unbindSync: this.unbindSync.bind(this) };
};
w_fn2 = function() {
  return { getBindings: (i23) => __privateGet(this, _u4).get(i23), getBindingsFromModule: (i23) => __privateGet(this, _u4).getByModuleId(i23), getClassMetadata: $, getDeactivations: (i23) => __privateGet(this, _v3).get(i23) };
};
F_fn = function(i23, e18, n18) {
  return { isMultiple: i23, name: n18 == null ? void 0 : n18.name, optional: n18 == null ? void 0 : n18.optional, serviceIdentifier: e18, tag: n18 == null ? void 0 : n18.tag };
};
k_fn = function(i23, e18, n18) {
  const t23 = { autobindOptions: (n18 == null ? void 0 : n18.autobind) ?? __privateGet(this, _f2).autobind ? { scope: __privateGet(this, _f2).defaultScope } : void 0, getBindings: __privateGet(this, _b3), getClassMetadata: $, rootConstraints: { isMultiple: e18, serviceIdentifier: i23 }, servicesBranch: [], setBinding: __privateGet(this, _y2) };
  return __privateMethod(this, _L_instances, D_fn).call(this, t23, n18), t23;
};
P_fn = function(i23, e18, n18) {
  const t23 = __privateMethod(this, _L_instances, F_fn).call(this, i23, e18, n18), s25 = __privateGet(this, _S).get(t23);
  if (void 0 !== s25) return s25;
  const r10 = ye(__privateMethod(this, _L_instances, k_fn).call(this, e18, i23, n18));
  return __privateGet(this, _S).set(t23, r10), r10;
};
I_fn2 = function() {
  return { get: this.get.bind(this), getAll: this.getAll.bind(this), getAllAsync: this.getAllAsync.bind(this), getAsync: this.getAsync.bind(this) };
};
B_fn = function(i23) {
  return Qe({ context: __privateGet(this, _p3), getActivations: __privateGet(this, _g2), planResult: i23, requestScopeCache: /* @__PURE__ */ new Map() });
};
D_fn = function(i23, e18) {
  void 0 !== e18 && (void 0 !== e18.name && (i23.rootConstraints.name = e18.name), true === e18.optional && (i23.rootConstraints.isOptional = true), void 0 !== e18.tag && (i23.rootConstraints.tag = { key: e18.tag.key, value: e18.tag.value }));
};
C_fn = function(i23, e18, n18) {
  if (void 0 === e18) return false;
  const t23 = { getAncestor: () => {
  }, name: n18 == null ? void 0 : n18.name, serviceIdentifier: i23, tags: /* @__PURE__ */ new Map() };
  void 0 !== (n18 == null ? void 0 : n18.tag) && t23.tags.set(n18.tag.key, n18.tag.value);
  for (const i24 of e18) if (i24.isSatisfiedBy(t23)) return true;
  return false;
};
e_fn = function(...i23) {
  return i23.map((i24) => i24.load(__privateMethod(this, _L_instances, U_fn).call(this, i24.id)));
};
O_fn = function(...i23) {
  return i23.map((i24) => st(__privateGet(this, _h3), i24.id));
};
R_fn = function() {
  __privateGet(this, _S).clearCache(), __privateSet(this, _g2, (i23) => __privateGet(this, _l2).get(i23)), __privateSet(this, _b3, __privateGet(this, _u4).get.bind(__privateGet(this, _u4))), __privateSet(this, _p3, __privateMethod(this, _L_instances, I_fn2).call(this)), __privateSet(this, _y2, __privateMethod(this, _L_instances, A_fn).bind(this));
};
A_fn = function(i23) {
  __privateGet(this, _u4).set(i23), __privateGet(this, _S).clearCache();
};
x_fn = function(i23) {
  var _a7;
  let e18;
  if (A6(i23)) {
    const t23 = __privateGet(this, _u4).getById(i23.id), s25 = (_a7 = (n18 = t23, function(i24) {
      if (void 0 === i24) return;
      const e19 = i24.next();
      return true !== e19.done ? e19.value : void 0;
    }(n18 == null ? void 0 : n18[Symbol.iterator]()))) == null ? void 0 : _a7.serviceIdentifier;
    e18 = void 0 === s25 ? "Unexpected asyncronous deactivation when unbinding binding identifier. Consider using Container.unbind() instead." : `Unexpected asyncronous deactivation when unbinding "${t8(s25)}" binding. Consider using Container.unbind() instead.`;
  } else e18 = `Unexpected asyncronous deactivation when unbinding "${t8(i23)}" service. Consider using Container.unbind() instead.`;
  var n18;
  throw new G($2.invalidOperation, e18);
};
M_fn2 = function(i23) {
  return A6(i23) ? __privateMethod(this, _L_instances, j_fn).call(this, i23) : __privateMethod(this, _L_instances, T_fn).call(this, i23);
};
j_fn = function(i23) {
  const e18 = __privateGet(this, _u4).getById(i23.id), n18 = at(__privateGet(this, _h3), e18);
  if (void 0 !== n18) return n18.then(() => {
    __privateMethod(this, _L_instances, V_fn).call(this, i23);
  });
  __privateMethod(this, _L_instances, V_fn).call(this, i23);
};
V_fn = function(i23) {
  __privateGet(this, _u4).removeById(i23.id), __privateGet(this, _S).clearCache();
};
N_fn = function(i23) {
  for (const e18 of i23) __privateGet(this, _l2).removeAllByModuleId(e18.id), __privateGet(this, _u4).removeAllByModuleId(e18.id), __privateGet(this, _v3).removeAllByModuleId(e18.id);
  __privateGet(this, _S).clearCache();
};
T_fn = function(i23) {
  const e18 = ct(__privateGet(this, _h3), i23);
  if (void 0 !== e18) return e18.then(() => {
    __privateMethod(this, _L_instances, E_fn).call(this, i23);
  });
  __privateMethod(this, _L_instances, E_fn).call(this, i23);
};
E_fn = function(i23) {
  __privateGet(this, _l2).removeAllByServiceId(i23), __privateGet(this, _u4).removeAllByServiceId(i23), __privateGet(this, _v3).removeAllByServiceId(i23), __privateGet(this, _S).clearCache();
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-model/data/StaticDeviceModelDataSource.js
var import_semver4 = __toESM(require_semver2());

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-model/model/BleDeviceInfos.js
var s16 = class {
  constructor(e18, r10, t23, c21, o12) {
    this.deviceModel = e18;
    this.serviceUuid = r10;
    this.writeUuid = t23;
    this.writeCmdUuid = c21;
    this.notifyUuid = o12;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-model/model/DeviceModel.js
var i12 = class {
  constructor(e18) {
    __publicField(this, "id");
    __publicField(this, "productName");
    __publicField(this, "usbProductId");
    __publicField(this, "bootloaderUsbProductId");
    __publicField(this, "usbOnly");
    __publicField(this, "memorySize");
    __publicField(this, "getBlockSize");
    __publicField(this, "masks");
    __publicField(this, "bluetoothSpec");
    this.id = e18.id, this.productName = e18.productName, this.usbProductId = e18.usbProductId, this.bootloaderUsbProductId = e18.bootloaderUsbProductId, this.usbOnly = e18.usbOnly, this.memorySize = e18.memorySize, this.getBlockSize = e18.getBlockSize, this.masks = e18.masks, this.bluetoothSpec = e18.bluetoothSpec;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-model/data/StaticDeviceModelDataSource.js
var n7 = Object.defineProperty;
var f4 = Object.getOwnPropertyDescriptor;
var U3 = (c21, e18, d18) => e18 in c21 ? n7(c21, e18, { enumerable: true, configurable: true, writable: true, value: d18 }) : c21[e18] = d18;
var m3 = (c21, e18, d18, t23) => {
  for (var o12 = t23 > 1 ? void 0 : t23 ? f4(e18, d18) : e18, s25 = c21.length - 1, l19; s25 >= 0; s25--) (l19 = c21[s25]) && (o12 = (t23 ? l19(e18, d18, o12) : l19(o12)) || o12);
  return t23 && o12 && n7(e18, d18, o12), o12;
};
var b3 = (c21, e18, d18) => U3(c21, typeof e18 != "symbol" ? e18 + "" : e18, d18);
var i13 = class {
  getAllDeviceModels() {
    return Object.values(i13.deviceModelByIds);
  }
  getDeviceModel(e18) {
    return i13.deviceModelByIds[e18.id];
  }
  filterDeviceModels(e18) {
    return this.getAllDeviceModels().filter((d18) => Object.entries(e18).every(([t23, o12]) => d18[t23] === o12));
  }
  getBluetoothServicesInfos() {
    return Object.values(i13.deviceModelByIds).reduce((e18, d18) => {
      const { bluetoothSpec: t23 } = d18;
      return t23 ? { ...e18, ...t23.reduce((o12, s25) => ({ ...o12, [s25.serviceUuid]: new s16(d18, s25.serviceUuid, s25.writeUuid, s25.writeCmdUuid, s25.notifyUuid) }), {}) } : e18;
    }, {});
  }
  getBluetoothServices() {
    return Object.values(i13.deviceModelByIds).map((e18) => (e18.bluetoothSpec || []).map((d18) => d18.serviceUuid)).flat().filter((e18) => !!e18);
  }
};
b3(i13, "deviceModelByIds", { [t2.NANO_S]: new i12({ id: t2.NANO_S, productName: "Ledger Nano S", usbProductId: 16, bootloaderUsbProductId: 1, usbOnly: true, memorySize: 320 * 1024, getBlockSize: (e18) => import_semver4.default.lt(import_semver4.default.coerce(e18.firmwareVersion) ?? "", "2.0.0") ? 4 * 1024 : 2 * 1024, masks: [823132160] }), [t2.NANO_SP]: new i12({ id: t2.NANO_SP, productName: "Ledger Nano S Plus", usbProductId: 80, bootloaderUsbProductId: 5, usbOnly: true, memorySize: 1533 * 1024, getBlockSize: () => 32, masks: [856686592] }), [t2.NANO_X]: new i12({ id: t2.NANO_X, productName: "Ledger Nano X", usbProductId: 64, bootloaderUsbProductId: 4, usbOnly: false, memorySize: 2 * 1024 * 1024, getBlockSize: () => 4 * 1024, masks: [855638016], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-0004-0000-4c6564676572", notifyUuid: "13d63400-2c97-0004-0001-4c6564676572", writeUuid: "13d63400-2c97-0004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572" }] }), [t2.STAX]: new i12({ id: t2.STAX, productName: "Ledger Stax", usbProductId: 96, bootloaderUsbProductId: 6, usbOnly: false, memorySize: 1533 * 1024, getBlockSize: () => 32, masks: [857735168], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-6004-0000-4c6564676572", notifyUuid: "13d63400-2c97-6004-0001-4c6564676572", writeUuid: "13d63400-2c97-6004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572" }] }), [t2.FLEX]: new i12({ id: t2.FLEX, productName: "Ledger Flex", usbProductId: 112, bootloaderUsbProductId: 7, usbOnly: false, memorySize: 1533 * 1024, getBlockSize: () => 32, masks: [858783744], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-3004-0000-4c6564676572", notifyUuid: "13d63400-2c97-3004-0001-4c6564676572", writeUuid: "13d63400-2c97-3004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-3004-0003-4c6564676572" }] }), [t2.APEX]: new i12({ id: t2.APEX, productName: "Ledger Apex", usbProductId: 128, bootloaderUsbProductId: 8, usbOnly: false, memorySize: 1533 * 1024, getBlockSize: () => 32, masks: [859832320], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-8004-0000-4c6564676572", notifyUuid: "13d63400-2c97-8004-0001-4c6564676572", writeUuid: "13d63400-2c97-8004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-8004-0003-4c6564676572" }] }) }), i13 = m3([z2()], i13);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/ApduResponse.js
var a11 = class {
  constructor({ statusCode: t23, data: r10 }) {
    __publicField(this, "statusCode");
    __publicField(this, "data");
    this.statusCode = t23, this.data = r10;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/data/FramerConst.js
var o6 = 5;
var t11 = 1;
var E9 = 2;
var A7 = 2;
var H2 = 2;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/device-action/GenuineCheck/GenuineCheckDeviceAction.js
var P4 = class extends E3 {
  makeStateMachine(n18) {
    const { getOsVersion: h5, getDeviceVersion: l19, getFirmwareVersion: m15, genuineCheck: S13, getDeviceSessionState: r10, setDeviceSessionState: i23 } = this.extractDependencies(n18), a24 = this.input.unlockTimeout ?? T, c21 = new L({ input: { unlockTimeout: a24 } }).makeStateMachine(n18);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { goToDashboard: c21, getOsVersion: fromPromise(h5), getDeviceVersion: fromPromise(l19), getFirmwareVersion: fromPromise(m15), genuineCheck: fromObservable(S13) }, guards: { hasError: (e18) => e18.context._internalState.error !== null }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "GenuineCheckDeviceAction", initial: "DeviceReady", context: (e18) => ({ input: { unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, result: { isGenuine: false }, getOsVersionResponse: null, deviceVersion: null, firmwareVersion: null } }), states: { DeviceReady: { always: { target: "GoToDashboard" } }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetOsVersion" }] }, GetOsVersion: { invoke: { id: "getOsVersion", src: "getOsVersion", input: (e18) => {
    }, onDone: { target: "GetOsVersionCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const t23 = r10(), d18 = e18.event.output.data.secureElementFlags.isSecureConnectionAllowed;
        return t23.sessionStateType !== a6.Connected && i23({ ...t23, isSecureConnectionAllowed: d18 }), { ...e18.context._internalState, getOsVersionResponse: e18.event.output.data };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) } } }, GetOsVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetDeviceVersion" }] }, GetDeviceVersion: { invoke: { id: "getDeviceVersion", src: "getDeviceVersion", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse }), onDone: { target: "GetDeviceVersionCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, deviceVersion: t23 }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetFirmwareVersion" }] }, GetFirmwareVersion: { invoke: { id: "getFirmwareVersion", src: "getFirmwareVersion", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse, deviceVersion: e18.context._internalState.deviceVersion }), onDone: { target: "GetFirmwareVersionCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, firmwareVersion: t23 }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetFirmwareVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GenuineCheck" }] }, GenuineCheck: { invoke: { id: "genuineCheck", src: "genuineCheck", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse, finalFirmware: e18.context._internalState.firmwareVersion }), onSnapshot: { actions: assign({ intermediateValue: (e18) => {
      var _a7;
      switch ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) {
        case o5.DeviceId:
          return { ...e18.context.intermediateValue, deviceId: e18.event.snapshot.context.payload.deviceId };
        case o5.PermissionRequested:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.AllowSecureConnection };
        case o5.PermissionGranted:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.None };
        default:
          return { ...e18.context.intermediateValue };
      }
    }, _internalState: (e18) => {
      var _a7, _b4;
      return ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error ? { ...e18.context._internalState, error: e18.event.snapshot.context.error.mapDAErrors() } : ((_b4 = e18.event.snapshot.context) == null ? void 0 : _b4.type) === o5.Result ? { ...e18.context._internalState, result: { isGenuine: s14(e18.event.snapshot.context.payload) } } : e18.context._internalState;
    } }) }, onDone: { target: "GenuineCheckCheck" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GenuineCheckCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => e18.context._internalState.error ? left(e18.context._internalState.error) : right(e18.context._internalState.result) });
  }
  extractDependencies(n18) {
    return { getOsVersion: () => n18.sendCommand(new P()), getDeviceVersion: ({ input: r10 }) => {
      const { deviceInfo: i23 } = r10;
      return n18.getManagerApiService().getDeviceVersion(i23);
    }, getFirmwareVersion: ({ input: r10 }) => {
      const { deviceInfo: i23, deviceVersion: a24 } = r10;
      return n18.getManagerApiService().getFirmwareVersion(i23, a24);
    }, genuineCheck: ({ input: r10 }) => {
      const { deviceInfo: i23, finalFirmware: a24 } = r10, c21 = n18.getSecureChannelService().genuineCheck(i23, a24);
      return new j(n18, { connection: c21 }).run();
    }, getDeviceSessionState: () => n18.getDeviceSessionState(), setDeviceSessionState: (r10) => n18.setDeviceSessionState(r10) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/device-action/ListInstalledApps/ListInstalledAppsDeviceAction.js
var _3 = class extends E3 {
  makeStateMachine(n18) {
    const { getOsVersion: u14, getDeviceVersion: d18, getFirmwareVersion: m15, listInstalledApps: S13, getDeviceSessionState: r10, setDeviceSessionState: s25 } = this.extractDependencies(n18), o12 = this.input.unlockTimeout ?? T, c21 = new L({ input: { unlockTimeout: o12 } }).makeStateMachine(n18);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { goToDashboard: c21, getOsVersion: fromPromise(u14), getDeviceVersion: fromPromise(d18), getFirmwareVersion: fromPromise(m15), listInstalledApps: fromObservable(S13) }, guards: { hasError: (e18) => e18.context._internalState.error !== null }, actions: { assignErrorFromEvent: assign({ _internalState: (e18) => ({ ...e18.context._internalState, error: e18.event.error }) }) } }).createMachine({ id: "ListInstalledAppsDeviceAction", initial: "DeviceReady", context: (e18) => ({ input: { unlockTimeout: e18.input.unlockTimeout }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, getOsVersionResponse: null, deviceVersion: null, firmwareVersion: null, result: { installedApps: [] } } }), states: { DeviceReady: { always: { target: "GoToDashboard" } }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (e18) => ({ unlockTimeout: e18.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (e18) => ({ ...e18.context.intermediateValue, requiredUserInteraction: e18.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: () => e18.context._internalState, Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetOsVersion" }] }, GetOsVersion: { invoke: { id: "getOsVersion", src: "getOsVersion", input: (e18) => {
    }, onDone: { target: "GetOsVersionCheck", actions: assign({ _internalState: (e18) => {
      if (s5(e18.event.output)) {
        const t23 = r10(), v22 = e18.event.output.data.secureElementFlags.isSecureConnectionAllowed;
        return t23.sessionStateType !== a6.Connected && s25({ ...t23, isSecureConnectionAllowed: v22 }), { ...e18.context._internalState, getOsVersionResponse: e18.event.output.data };
      }
      return { ...e18.context._internalState, error: e18.event.output.error };
    } }) } } }, GetOsVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetDeviceVersion" }] }, GetDeviceVersion: { invoke: { id: "getDeviceVersion", src: "getDeviceVersion", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse }), onDone: { target: "GetDeviceVersionCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, deviceVersion: t23 }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetDeviceVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetFirmwareVersion" }] }, GetFirmwareVersion: { invoke: { id: "getFirmwareVersion", src: "getFirmwareVersion", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse, deviceVersion: e18.context._internalState.deviceVersion }), onDone: { target: "GetFirmwareVersionCheck", actions: assign({ _internalState: (e18) => e18.event.output.caseOf({ Right: (t23) => ({ ...e18.context._internalState, firmwareVersion: t23 }), Left: (t23) => ({ ...e18.context._internalState, error: t23 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetFirmwareVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "ListInstalledApps" }] }, ListInstalledApps: { invoke: { id: "listInstalledApps", src: "listInstalledApps", input: (e18) => ({ deviceInfo: e18.context._internalState.getOsVersionResponse, finalFirmware: e18.context._internalState.firmwareVersion }), onSnapshot: { actions: assign({ intermediateValue: (e18) => {
      var _a7;
      switch ((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) {
        case o5.DeviceId:
          return { ...e18.context.intermediateValue, deviceId: e18.event.snapshot.context.payload.deviceId };
        case o5.PermissionRequested:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.AllowSecureConnection };
        case o5.PermissionGranted:
          return { ...e18.context.intermediateValue, requiredUserInteraction: s8.None };
        default:
          return { ...e18.context.intermediateValue };
      }
    }, _internalState: (e18) => {
      var _a7, _b4;
      if (((_a7 = e18.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error) return { ...e18.context._internalState, error: e18.event.snapshot.context.error.mapDAErrors() };
      if (((_b4 = e18.event.snapshot.context) == null ? void 0 : _b4.type) === o5.Result) {
        if (t6(e18.event.snapshot.context.payload)) return { ...e18.context._internalState, result: { installedApps: e18.event.snapshot.context.payload } };
        throw new Error(`Invalid result ${JSON.stringify(e18.event.snapshot.context.payload)}`);
      }
      return { ...e18.context._internalState };
    } }) }, onDone: { target: "Success" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListInstalledAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success" }] }, Success: { type: "final" }, Error: { type: "final" } }, output: (e18) => e18.context._internalState.error ? left(e18.context._internalState.error) : right(e18.context._internalState.result) });
  }
  extractDependencies(n18) {
    return { getOsVersion: () => n18.sendCommand(new P()), getDeviceVersion: ({ input: r10 }) => {
      const { deviceInfo: s25 } = r10;
      return n18.getManagerApiService().getDeviceVersion(s25);
    }, getFirmwareVersion: ({ input: r10 }) => {
      const { deviceInfo: s25, deviceVersion: o12 } = r10;
      return n18.getManagerApiService().getFirmwareVersion(s25, o12);
    }, listInstalledApps: ({ input: r10 }) => {
      const { deviceInfo: s25, finalFirmware: o12 } = r10, c21 = n18.getSecureChannelService().listInstalledApps(s25, o12);
      return new j(n18, { connection: c21 }).run();
    }, getDeviceSessionState: () => n18.getDeviceSessionState(), setDeviceSessionState: (r10) => n18.setDeviceSessionState(r10) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/device-action/InstallApp/InstallAppDeviceAction.js
var X = class extends E3 {
  makeStateMachine(n18) {
    const { getOsVersion: c21, getAppList: u14, installApp: d18, getDeviceSessionState: r10, setDeviceSessionState: o12 } = this.extractDependencies(n18), i23 = this.input.unlockTimeout ?? T, p30 = new _3({ input: { unlockTimeout: i23 } }).makeStateMachine(n18), I5 = new L({ input: { unlockTimeout: i23 } }).makeStateMachine(n18);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { listInstalledApps: p30, goToDashboard: I5, getOsVersion: fromPromise(c21), getAppList: fromPromise(u14), installApp: fromObservable(d18) }, guards: { hasError: (t23) => t23.context._internalState.error !== null, appInstalled: (t23) => t23.context._internalState.installedApps.some((e18) => e18.name === t23.context.input.appName), appNotFound: (t23) => t23.context._internalState.appList.findIndex(({ versionName: e18 }) => e18 === t23.context.input.appName) === -1, depAppNotInstalled: (t23) => {
      const e18 = t23.context._internalState.appList.find(({ versionName: s25 }) => s25 === t23.context.input.appName);
      return (e18 == null ? void 0 : e18.parentName) ? t23.context._internalState.installedApps.findIndex(({ name: s25 }) => s25 === e18.parentName) === -1 : false;
    } }, actions: { assignErrorFromEvent: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: t23.event.error }) }), assignAppNotFound: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: new s9("App to install not found in manager API") }) }), assignDepAppNotInstalled: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: new s9("Dep app is not installed on the device") }) }), cleanupDeviceState: () => {
      const t23 = r10();
      t23.sessionStateType !== a6.Connected && o12({ ...t23, installedApps: [], appsUpdates: void 0 });
    } } }).createMachine({ id: "InstallAppDeviceAction", initial: "DeviceReady", context: (t23) => ({ input: { unlockTimeout: t23.input.unlockTimeout, appName: t23.input.appName }, intermediateValue: { requiredUserInteraction: s8.None, progress: 0 }, _internalState: { error: null, installedApps: [], getOsVersionResponse: null, appList: [] } }), states: { DeviceReady: { always: { target: "ListInstalledApps" } }, ListInstalledApps: { value: "ListInstalledApps", invoke: { id: "listInstalledApps", src: "listInstalledApps", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => ({ ...t23.context.intermediateValue, requiredUserInteraction: t23.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "ListInstalledAppsCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: ({ installedApps: e18 }) => ({ ...t23.context._internalState, installedApps: e18 }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) } } }, ListInstalledAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success", guard: "appInstalled" }, { target: "GoToDashboard" }] }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => ({ ...t23.context.intermediateValue, requiredUserInteraction: t23.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: () => t23.context._internalState, Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetOsVersion" }] }, GetOsVersion: { invoke: { id: "getOsVersion", src: "getOsVersion", input: (t23) => {
    }, onDone: { target: "GetOsVersionCheck", actions: assign({ _internalState: (t23) => {
      if (s5(t23.event.output)) {
        const e18 = r10(), s25 = t23.event.output.data.secureElementFlags.isSecureConnectionAllowed;
        return e18.sessionStateType !== a6.Connected && o12({ ...e18, isSecureConnectionAllowed: s25 }), { ...t23.context._internalState, getOsVersionResponse: t23.event.output.data };
      }
      return { ...t23.context._internalState, error: t23.event.output.error };
    } }) } } }, GetOsVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetAppList" }] }, GetAppList: { invoke: { id: "getAppList", src: "getAppList", input: (t23) => ({ deviceInfo: t23.context._internalState.getOsVersionResponse }), onDone: { target: "GetAppListCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: (e18) => ({ ...t23.context._internalState, appList: e18 }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) } } }, GetAppListCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Error", guard: "appNotFound", actions: "assignAppNotFound" }, { target: "Error", guard: "depAppNotInstalled", actions: "assignDepAppNotInstalled" }, { target: "InstallApp" }] }, InstallApp: { invoke: { id: "installApp", src: "installApp", input: (t23) => ({ deviceInfo: t23.context._internalState.getOsVersionResponse, app: t23.context._internalState.appList.find(({ versionName: e18 }) => e18 === t23.context.input.appName) }), onSnapshot: { actions: assign({ intermediateValue: (t23) => {
      var _a7, _b4;
      return ((_a7 = t23.event.snapshot.context) == null ? void 0 : _a7.type) === o5.DeviceId ? { ...t23.context.intermediateValue, deviceId: t23.event.snapshot.context.payload.deviceId } : ((_b4 = t23.event.snapshot.context) == null ? void 0 : _b4.type) === o5.Progress ? { ...t23.context.intermediateValue, progress: t23.event.snapshot.context.payload.progress } : { ...t23.context.intermediateValue };
    }, _internalState: (t23) => {
      var _a7;
      return ((_a7 = t23.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error ? { ...t23.context._internalState, error: t23.event.snapshot.context.error.mapInstallDAErrors() } : t23.context._internalState;
    } }) }, onDone: { target: "ListInstalledApps", actions: "cleanupDeviceState" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Success: { type: "final", description: "App installed successfully" }, Error: { type: "final" } }, output: ({ context: t23 }) => t23._internalState.error ? left(t23._internalState.error) : right(void 0) });
  }
  extractDependencies(n18) {
    return { getOsVersion: () => n18.sendCommand(new P()), getAppList: ({ input: r10 }) => {
      const { deviceInfo: o12 } = r10;
      return n18.getManagerApiService().getAppList(o12);
    }, installApp: ({ input: r10 }) => {
      const { deviceInfo: o12, app: i23 } = r10, p30 = n18.getSecureChannelService().installApp(o12, i23);
      return new j(n18, { connection: p30 }).run();
    }, getDeviceSessionState: () => n18.getDeviceSessionState(), setDeviceSessionState: (r10) => n18.setDeviceSessionState(r10) };
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/secure-channel/device-action/UninstallApp/UninstallAppDeviceAction.js
var P5 = class extends E3 {
  makeStateMachine(n18) {
    const { getOsVersion: c21, getAppsByHash: u14, uninstallApp: d18, getDeviceSessionState: r10, setDeviceSessionState: s25 } = this.extractDependencies(n18), o12 = this.input.unlockTimeout ?? T, p30 = new L({ input: { unlockTimeout: o12 } }).makeStateMachine(n18), h5 = new _3({ input: { unlockTimeout: o12 } }).makeStateMachine(n18);
    return setup({ types: { input: {}, context: {}, output: {} }, actors: { listInstalledApps: h5, goToDashboard: p30, getOsVersion: fromPromise(c21), getAppsByHash: fromPromise(u14), uninstallApp: fromObservable(d18) }, guards: { hasError: (t23) => t23.context._internalState.error !== null, appNotInstalled: (t23) => !t23.context._internalState.installedApps.some((e18) => e18.name === t23.context.input.appName), appNotFound: (t23) => t23.context._internalState.appList.findIndex((e18) => (e18 == null ? void 0 : e18.versionName) === t23.context.input.appName) === -1, isDepAppOfOther: (t23) => t23.context._internalState.appList.some((e18) => (e18 == null ? void 0 : e18.parentName) === t23.context.input.appName) }, actions: { assignErrorFromEvent: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: t23.event.error }) }), assignAppNotFound: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: new s9("App to uninstall not found in manager API") }) }), assignIsDepAppOfOther: assign({ _internalState: (t23) => ({ ...t23.context._internalState, error: new s9("App to uninstall is a dependency of another installed app") }) }), cleanupDeviceState: () => {
      const t23 = r10();
      t23.sessionStateType !== a6.Connected && s25({ ...t23, installedApps: [], appsUpdates: void 0 });
    } } }).createMachine({ id: "UninstallAppDeviceAction", initial: "DeviceReady", context: (t23) => ({ input: { unlockTimeout: t23.input.unlockTimeout, appName: t23.input.appName }, intermediateValue: { requiredUserInteraction: s8.None }, _internalState: { error: null, installedApps: [], appList: [], getOsVersionResponse: null } }), states: { DeviceReady: { always: { target: "ListInstalledApps" } }, ListInstalledApps: { invoke: { id: "listInstalledApps", src: "listInstalledApps", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => ({ ...t23.context.intermediateValue, requiredUserInteraction: t23.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "ListInstalledAppsCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: ({ installedApps: e18 }) => ({ ...t23.context._internalState, installedApps: e18, hasCheckedInstalledApps: true }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, ListInstalledAppsCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Success", guard: "appNotInstalled" }, { target: "GetAppsByHash" }] }, GetAppsByHash: { invoke: { id: "getAppsByHash", src: "getAppsByHash", input: (t23) => t23.context._internalState.installedApps, onDone: { target: "GetAppsByHashCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: (e18) => ({ ...t23.context._internalState, appList: e18 }), Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GetAppsByHashCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "Error", guard: "appNotFound", actions: "assignAppNotFound" }, { target: "Error", guard: "isDepAppOfOther", actions: "assignIsDepAppOfOther" }, { target: "GoToDashboard" }] }, GoToDashboard: { invoke: { id: "goToDashboard", src: "goToDashboard", input: (t23) => ({ unlockTimeout: t23.context.input.unlockTimeout }), onSnapshot: { actions: assign({ intermediateValue: (t23) => ({ ...t23.context.intermediateValue, requiredUserInteraction: t23.event.snapshot.context.intermediateValue.requiredUserInteraction }) }) }, onDone: { target: "GoToDashboardCheck", actions: assign({ _internalState: (t23) => t23.event.output.caseOf({ Right: () => t23.context._internalState, Left: (e18) => ({ ...t23.context._internalState, error: e18 }) }) }) }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, GoToDashboardCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "GetOsVersion" }] }, GetOsVersion: { invoke: { id: "getOsVersion", src: "getOsVersion", input: (t23) => {
    }, onDone: { target: "GetOsVersionCheck", actions: assign({ _internalState: (t23) => {
      if (s5(t23.event.output)) {
        const e18 = r10(), g23 = t23.event.output.data.secureElementFlags.isSecureConnectionAllowed;
        return e18.sessionStateType !== a6.Connected && s25({ ...e18, isSecureConnectionAllowed: g23 }), { ...t23.context._internalState, getOsVersionResponse: t23.event.output.data };
      }
      return { ...t23.context._internalState, error: t23.event.output.error };
    } }) } } }, GetOsVersionCheck: { always: [{ target: "Error", guard: "hasError" }, { target: "UninstallApp" }] }, UninstallApp: { invoke: { id: "uninstallApp", src: "uninstallApp", input: (t23) => ({ deviceInfo: t23.context._internalState.getOsVersionResponse, app: t23.context._internalState.appList.find((e18) => (e18 == null ? void 0 : e18.versionName) === t23.context.input.appName) }), onSnapshot: { actions: assign({ intermediateValue: (t23) => {
      var _a7;
      switch ((_a7 = t23.event.snapshot.context) == null ? void 0 : _a7.type) {
        case o5.DeviceId:
          return { ...t23.context.intermediateValue, deviceId: t23.event.snapshot.context.payload.deviceId };
        case o5.PermissionRequested:
          return { ...t23.context.intermediateValue, requiredUserInteraction: s8.AllowSecureConnection };
        case o5.PermissionGranted:
          return { ...t23.context.intermediateValue, requiredUserInteraction: s8.None };
        default:
          return { ...t23.context.intermediateValue };
      }
    }, _internalState: (t23) => {
      var _a7;
      return ((_a7 = t23.event.snapshot.context) == null ? void 0 : _a7.type) === o5.Error ? { ...t23.context._internalState, error: t23.event.snapshot.context.error.mapDAErrors() } : t23.context._internalState;
    } }) }, onDone: { target: "ListInstalledApps", actions: "cleanupDeviceState" }, onError: { target: "Error", actions: "assignErrorFromEvent" } } }, Success: { type: "final", description: "App uninstalled successfully" }, Error: { type: "final" } }, output: ({ context: t23 }) => t23._internalState.error ? left(t23._internalState.error) : right(void 0) });
  }
  extractDependencies(n18) {
    return { getOsVersion: () => n18.sendCommand(new P()), getAppsByHash: ({ input: r10 }) => {
      const s25 = r10.map((o12) => o12.hash);
      return n18.getManagerApiService().getAppsByHash(s25);
    }, uninstallApp: ({ input: r10 }) => {
      const { deviceInfo: s25, app: o12 } = r10, p30 = n18.getSecureChannelService().uninstallApp(s25, o12);
      return new j(n18, { connection: p30 }).run();
    }, getDeviceSessionState: () => n18.getDeviceSessionState(), setDeviceSessionState: (r10) => n18.setDeviceSessionState(r10) };
  }
};

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v22;
  return Uint8Array.of((v22 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v22 >>> 16 & 255, v22 >>> 8 & 255, v22 & 255, (v22 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v22 & 255, (v22 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v22 & 255, (v22 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v22 & 255, (v22 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v22 / 4294967296 & 255, v22 >>> 24 & 255, v22 >>> 16 & 255, v22 >>> 8 & 255, v22 & 255);
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i23 = 0; i23 < 256; ++i23) {
  byteToHex.push((i23 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i23 = 0; i23 < input.length * 4; i23++) {
    bytes[i23] = input[i23 >> 2] >>> i23 % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x8, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x8);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x8 = xpad;
  let a24 = 1732584193;
  let b6 = -271733879;
  let c21 = -1732584194;
  let d18 = 271733878;
  for (let i23 = 0; i23 < x8.length; i23 += 16) {
    const olda = a24;
    const oldb = b6;
    const oldc = c21;
    const oldd = d18;
    a24 = md5ff(a24, b6, c21, d18, x8[i23], 7, -680876936);
    d18 = md5ff(d18, a24, b6, c21, x8[i23 + 1], 12, -389564586);
    c21 = md5ff(c21, d18, a24, b6, x8[i23 + 2], 17, 606105819);
    b6 = md5ff(b6, c21, d18, a24, x8[i23 + 3], 22, -1044525330);
    a24 = md5ff(a24, b6, c21, d18, x8[i23 + 4], 7, -176418897);
    d18 = md5ff(d18, a24, b6, c21, x8[i23 + 5], 12, 1200080426);
    c21 = md5ff(c21, d18, a24, b6, x8[i23 + 6], 17, -1473231341);
    b6 = md5ff(b6, c21, d18, a24, x8[i23 + 7], 22, -45705983);
    a24 = md5ff(a24, b6, c21, d18, x8[i23 + 8], 7, 1770035416);
    d18 = md5ff(d18, a24, b6, c21, x8[i23 + 9], 12, -1958414417);
    c21 = md5ff(c21, d18, a24, b6, x8[i23 + 10], 17, -42063);
    b6 = md5ff(b6, c21, d18, a24, x8[i23 + 11], 22, -1990404162);
    a24 = md5ff(a24, b6, c21, d18, x8[i23 + 12], 7, 1804603682);
    d18 = md5ff(d18, a24, b6, c21, x8[i23 + 13], 12, -40341101);
    c21 = md5ff(c21, d18, a24, b6, x8[i23 + 14], 17, -1502002290);
    b6 = md5ff(b6, c21, d18, a24, x8[i23 + 15], 22, 1236535329);
    a24 = md5gg(a24, b6, c21, d18, x8[i23 + 1], 5, -165796510);
    d18 = md5gg(d18, a24, b6, c21, x8[i23 + 6], 9, -1069501632);
    c21 = md5gg(c21, d18, a24, b6, x8[i23 + 11], 14, 643717713);
    b6 = md5gg(b6, c21, d18, a24, x8[i23], 20, -373897302);
    a24 = md5gg(a24, b6, c21, d18, x8[i23 + 5], 5, -701558691);
    d18 = md5gg(d18, a24, b6, c21, x8[i23 + 10], 9, 38016083);
    c21 = md5gg(c21, d18, a24, b6, x8[i23 + 15], 14, -660478335);
    b6 = md5gg(b6, c21, d18, a24, x8[i23 + 4], 20, -405537848);
    a24 = md5gg(a24, b6, c21, d18, x8[i23 + 9], 5, 568446438);
    d18 = md5gg(d18, a24, b6, c21, x8[i23 + 14], 9, -1019803690);
    c21 = md5gg(c21, d18, a24, b6, x8[i23 + 3], 14, -187363961);
    b6 = md5gg(b6, c21, d18, a24, x8[i23 + 8], 20, 1163531501);
    a24 = md5gg(a24, b6, c21, d18, x8[i23 + 13], 5, -1444681467);
    d18 = md5gg(d18, a24, b6, c21, x8[i23 + 2], 9, -51403784);
    c21 = md5gg(c21, d18, a24, b6, x8[i23 + 7], 14, 1735328473);
    b6 = md5gg(b6, c21, d18, a24, x8[i23 + 12], 20, -1926607734);
    a24 = md5hh(a24, b6, c21, d18, x8[i23 + 5], 4, -378558);
    d18 = md5hh(d18, a24, b6, c21, x8[i23 + 8], 11, -2022574463);
    c21 = md5hh(c21, d18, a24, b6, x8[i23 + 11], 16, 1839030562);
    b6 = md5hh(b6, c21, d18, a24, x8[i23 + 14], 23, -35309556);
    a24 = md5hh(a24, b6, c21, d18, x8[i23 + 1], 4, -1530992060);
    d18 = md5hh(d18, a24, b6, c21, x8[i23 + 4], 11, 1272893353);
    c21 = md5hh(c21, d18, a24, b6, x8[i23 + 7], 16, -155497632);
    b6 = md5hh(b6, c21, d18, a24, x8[i23 + 10], 23, -1094730640);
    a24 = md5hh(a24, b6, c21, d18, x8[i23 + 13], 4, 681279174);
    d18 = md5hh(d18, a24, b6, c21, x8[i23], 11, -358537222);
    c21 = md5hh(c21, d18, a24, b6, x8[i23 + 3], 16, -722521979);
    b6 = md5hh(b6, c21, d18, a24, x8[i23 + 6], 23, 76029189);
    a24 = md5hh(a24, b6, c21, d18, x8[i23 + 9], 4, -640364487);
    d18 = md5hh(d18, a24, b6, c21, x8[i23 + 12], 11, -421815835);
    c21 = md5hh(c21, d18, a24, b6, x8[i23 + 15], 16, 530742520);
    b6 = md5hh(b6, c21, d18, a24, x8[i23 + 2], 23, -995338651);
    a24 = md5ii(a24, b6, c21, d18, x8[i23], 6, -198630844);
    d18 = md5ii(d18, a24, b6, c21, x8[i23 + 7], 10, 1126891415);
    c21 = md5ii(c21, d18, a24, b6, x8[i23 + 14], 15, -1416354905);
    b6 = md5ii(b6, c21, d18, a24, x8[i23 + 5], 21, -57434055);
    a24 = md5ii(a24, b6, c21, d18, x8[i23 + 12], 6, 1700485571);
    d18 = md5ii(d18, a24, b6, c21, x8[i23 + 3], 10, -1894986606);
    c21 = md5ii(c21, d18, a24, b6, x8[i23 + 10], 15, -1051523);
    b6 = md5ii(b6, c21, d18, a24, x8[i23 + 1], 21, -2054922799);
    a24 = md5ii(a24, b6, c21, d18, x8[i23 + 8], 6, 1873313359);
    d18 = md5ii(d18, a24, b6, c21, x8[i23 + 15], 10, -30611744);
    c21 = md5ii(c21, d18, a24, b6, x8[i23 + 6], 15, -1560198380);
    b6 = md5ii(b6, c21, d18, a24, x8[i23 + 13], 21, 1309151649);
    a24 = md5ii(a24, b6, c21, d18, x8[i23 + 4], 6, -145523070);
    d18 = md5ii(d18, a24, b6, c21, x8[i23 + 11], 10, -1120210379);
    c21 = md5ii(c21, d18, a24, b6, x8[i23 + 2], 15, 718787259);
    b6 = md5ii(b6, c21, d18, a24, x8[i23 + 9], 21, -343485551);
    a24 = safeAdd(a24, olda);
    b6 = safeAdd(b6, oldb);
    c21 = safeAdd(c21, oldc);
    d18 = safeAdd(d18, oldd);
  }
  return Uint32Array.of(a24, b6, c21, d18);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i23 = 0; i23 < input.length; i23++) {
    output[i23 >> 2] |= (input[i23] & 255) << i23 % 4 * 8;
  }
  return output;
}
function safeAdd(x8, y6) {
  const lsw = (x8 & 65535) + (y6 & 65535);
  const msw = (x8 >> 16) + (y6 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q3, a24, b6, x8, s25, t23) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a24, q3), safeAdd(x8, t23)), s25), b6);
}
function md5ff(a24, b6, c21, d18, x8, s25, t23) {
  return md5cmn(b6 & c21 | ~b6 & d18, a24, b6, x8, s25, t23);
}
function md5gg(a24, b6, c21, d18, x8, s25, t23) {
  return md5cmn(b6 & d18 | c21 & ~d18, a24, b6, x8, s25, t23);
}
function md5hh(a24, b6, c21, d18, x8, s25, t23) {
  return md5cmn(b6 ^ c21 ^ d18, a24, b6, x8, s25, t23);
}
function md5ii(a24, b6, c21, d18, x8, s25, t23) {
  return md5cmn(c21 ^ (b6 | ~d18), a24, b6, x8, s25, t23);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i23 = 0; i23 < str.length; ++i23) {
    bytes[i23] = str.charCodeAt(i23);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i23 = 0; i23 < 16; ++i23) {
      buf[offset + i23] = bytes[i23];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v32(value, namespace, buf, offset) {
  return v35(48, md5_default, value, namespace, buf, offset);
}
v32.DNS = DNS;
v32.URL = URL2;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i23 = 0; i23 < 16; ++i23) {
      buf[offset + i23] = rnds[i23];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v42;

// node_modules/uuid/dist/esm-browser/sha1.js
function f5(s25, x8, y6, z3) {
  switch (s25) {
    case 0:
      return x8 & y6 ^ ~x8 & z3;
    case 1:
      return x8 ^ y6 ^ z3;
    case 2:
      return x8 & y6 ^ x8 & z3 ^ y6 & z3;
    case 3:
      return x8 ^ y6 ^ z3;
  }
}
function ROTL(x8, n18) {
  return x8 << n18 | x8 >>> 32 - n18;
}
function sha1(bytes) {
  const K3 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l19 = bytes.length / 4 + 2;
  const N4 = Math.ceil(l19 / 16);
  const M5 = new Array(N4);
  for (let i23 = 0; i23 < N4; ++i23) {
    const arr = new Uint32Array(16);
    for (let j4 = 0; j4 < 16; ++j4) {
      arr[j4] = bytes[i23 * 64 + j4 * 4] << 24 | bytes[i23 * 64 + j4 * 4 + 1] << 16 | bytes[i23 * 64 + j4 * 4 + 2] << 8 | bytes[i23 * 64 + j4 * 4 + 3];
    }
    M5[i23] = arr;
  }
  M5[N4 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M5[N4 - 1][14] = Math.floor(M5[N4 - 1][14]);
  M5[N4 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i23 = 0; i23 < N4; ++i23) {
    const W4 = new Uint32Array(80);
    for (let t23 = 0; t23 < 16; ++t23) {
      W4[t23] = M5[i23][t23];
    }
    for (let t23 = 16; t23 < 80; ++t23) {
      W4[t23] = ROTL(W4[t23 - 3] ^ W4[t23 - 8] ^ W4[t23 - 14] ^ W4[t23 - 16], 1);
    }
    let a24 = H3[0];
    let b6 = H3[1];
    let c21 = H3[2];
    let d18 = H3[3];
    let e18 = H3[4];
    for (let t23 = 0; t23 < 80; ++t23) {
      const s25 = Math.floor(t23 / 20);
      const T5 = ROTL(a24, 5) + f5(s25, b6, c21, d18) + e18 + K3[s25] + W4[t23] >>> 0;
      e18 = d18;
      d18 = c21;
      c21 = ROTL(b6, 30) >>> 0;
      b6 = a24;
      a24 = T5;
    }
    H3[0] = H3[0] + a24 >>> 0;
    H3[1] = H3[1] + b6 >>> 0;
    H3[2] = H3[2] + c21 >>> 0;
    H3[3] = H3[3] + d18 >>> 0;
    H3[4] = H3[4] + e18 >>> 0;
  }
  return Uint8Array.of(H3[0] >> 24, H3[0] >> 16, H3[0] >> 8, H3[0], H3[1] >> 24, H3[1] >> 16, H3[1] >> 8, H3[1], H3[2] >> 24, H3[2] >> 16, H3[2] >> 8, H3[2], H3[3] >> 24, H3[3] >> 16, H3[3] >> 8, H3[3], H3[4] >> 24, H3[4] >> 16, H3[4] >> 8, H3[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/utils/FramerUtils.js
var u5 = { getLastBytesFrom(r10, e18) {
  return r10.slice(-e18);
}, getFirstBytesFrom(r10, e18) {
  return r10.slice(0, e18);
}, bytesToNumber(r10) {
  return r10.reduce((e18, n18, t23) => e18 + n18 * Math.pow(256, r10.length - 1 - t23), 0);
}, numberToByteArray(r10, e18) {
  return new Uint8Array(e18).map((n18, t23) => r10 >> 8 * (e18 - 1 - t23) & 255);
} };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/data/ApduResponseConst.js
var E10 = 2;
var T4 = 800;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/Errors.js
var e5 = class {
  constructor() {
    __publicField(this, "_tag", "FramerOverflowError");
    __publicField(this, "originalError");
    this.originalError = new Error("Frame header length is greater than frame size");
  }
};
var i14 = class {
  constructor() {
    __publicField(this, "_tag", "FramerApduError");
    __publicField(this, "originalError");
    this.originalError = new Error("Frame offset is greater than apdu length");
  }
};
var s17 = class {
  constructor(r10) {
    __publicField(this, "_tag", "ReceiverApduError");
    __publicField(this, "originalError");
    this.originalError = new Error(r10 ?? "Unable to parse apdu");
  }
};
var n8 = class {
  constructor(r10) {
    __publicField(this, "_tag", "DeviceSessionNotFound");
    __publicField(this, "originalError");
    this.originalError = r10 ?? new Error("Device session not found");
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/Frame.js
var d4 = class {
  constructor({ header: t23, data: r10 }) {
    __publicField(this, "_header");
    __publicField(this, "_data");
    this._header = t23, this._data = r10;
  }
  toString() {
    return JSON.stringify({ header: this._header.toString(), data: o(this._data) }, null, 2);
  }
  getRawData() {
    const t23 = this._header.getRawData(), r10 = new Uint8Array(t23.length + this._data.length);
    return r10.set(t23, 0), r10.set(this._data, t23.length), r10;
  }
  getHeader() {
    return this._header;
  }
  getData() {
    return this._data;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/FrameHeader.js
var d5 = class {
  constructor({ uuid: t23, dataSize: e18, index: r10, headTag: a24, length: n18, channel: i23 }) {
    __publicField(this, "_uuid");
    __publicField(this, "_channel");
    __publicField(this, "_headTag");
    __publicField(this, "_index");
    __publicField(this, "_length");
    __publicField(this, "_dataLength");
    this._uuid = t23, this._dataLength = e18, this._index = r10, this._headTag = a24, this._length = n18, this._channel = i23;
  }
  getDataLength() {
    return this._dataLength.map((t23) => u5.bytesToNumber(t23));
  }
  setDataSize(t23) {
    return this._dataLength = t23, this;
  }
  getLength() {
    return this._length;
  }
  toString() {
    var _a7, _b4;
    return JSON.stringify({ uuid: this._uuid.toString(), dataSize: (_a7 = this._dataLength.extract()) == null ? void 0 : _a7.toString(), index: this._index.toString(), headTag: this._headTag.toString(), length: this._length.toString(), channel: (_b4 = this._channel.extract()) == null ? void 0 : _b4.toString() });
  }
  getRawData() {
    return new Uint8Array([...this._channel.caseOf({ Just: (t23) => [...t23], Nothing: () => [] }), ...this._headTag, ...this._index, ...this._dataLength.caseOf({ Just: (t23) => [...t23], Nothing: () => [] })]);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/logger-publisher/di/loggerTypes.js
var e6 = { LoggerPublisherServiceFactory: Symbol.for("LoggerPublisherServiceFactory") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/service/DefaultApduReceiverService.js
var S4 = Object.defineProperty;
var N3 = Object.getOwnPropertyDescriptor;
var d6 = (s25, e18, r10, t23) => {
  for (var n18 = t23 > 1 ? void 0 : t23 ? N3(e18, r10) : e18, i23 = s25.length - 1, a24; i23 >= 0; i23--) (a24 = s25[i23]) && (n18 = (t23 ? a24(e18, r10, n18) : a24(n18)) || n18);
  return t23 && n18 && S4(e18, r10, n18), n18;
};
var l8 = (s25, e18) => (r10, t23) => e18(r10, t23, s25);
var g5 = class {
  constructor({ channel: e18 = Maybe.zero() }, r10) {
    __publicField(this, "_channel");
    __publicField(this, "_logger");
    __publicField(this, "_pendingFrames");
    this._channel = e18, this._logger = r10("ApduReceiverService"), this._pendingFrames = [];
  }
  handleFrame(e18) {
    return this.getFrameFromBytes(e18).map((t23) => {
      if (this._pendingFrames.push(t23), !this._pendingFrames[0]) return nothing;
      const n18 = this._pendingFrames[0].getHeader().getDataLength();
      return this.getCompleteFrame(n18);
    });
  }
  getCompleteFrame(e18) {
    return e18.chain((r10) => {
      if (!this.isComplete(r10)) return this._logger.debug("frame is not complete, waiting for more"), nothing;
      const t23 = u5.getFirstBytesFrom(this.concatFrames(this._pendingFrames), r10), n18 = u5.getFirstBytesFrom(t23, t23.length - E10), i23 = u5.getLastBytesFrom(t23, E10);
      return this._pendingFrames = [], just(new a11({ data: n18, statusCode: i23 }));
    });
  }
  getFrameFromBytes(e18) {
    const r10 = this._channel.caseOf({ Just: () => E9, Nothing: () => 0 }), t23 = e18.slice(r10, r10 + t11), n18 = e18.slice(r10 + t11, r10 + t11 + A7), i23 = n18.reduce((L4, b6) => L4 + b6, 0) === 0;
    if (!i23 && this._pendingFrames.length === 0) return left(new s17());
    const a24 = r10 + t11 + A7, m15 = i23 ? H2 : 0;
    if (e18.length < r10 + t11 + A7 + m15) return left(new s17("Unable to parse header from apdu"));
    const f9 = i23 ? just(e18.slice(a24, a24 + m15)) : nothing, y6 = a24 + m15, v22 = e18.slice(y6), E14 = new d4({ header: new d5({ uuid: v4_default(), channel: this._channel, dataSize: f9, headTag: t23, index: n18, length: r10 + t11 + A7 + m15 }), data: v22 });
    return right(E14);
  }
  isComplete(e18) {
    return this._pendingFrames.reduce((t23, n18) => t23 + n18.getData().length, 0) >= e18;
  }
  concatFrames(e18) {
    return e18.reduce((r10, t23) => Uint8Array.from([...r10, ...t23.getData()]), new Uint8Array(0));
  }
};
g5 = d6([z2(), l8(1, N(e6.LoggerPublisherServiceFactory))], g5);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/service/DefaultApduReceiverService.stub.js
var p8 = (e18 = {}, r10) => new g5({ channel: Maybe.of(new Uint8Array([18, 52])), ...e18 }, r10);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/service/DefaultApduSenderService.js
var A8 = Object.defineProperty;
var _4 = Object.getOwnPropertyDescriptor;
var c6 = (m15, r10, t23, e18) => {
  for (var i23 = e18 > 1 ? void 0 : e18 ? _4(r10, t23) : r10, a24 = m15.length - 1, n18; a24 >= 0; a24--) (n18 = m15[a24]) && (i23 = (e18 ? n18(r10, t23, i23) : n18(i23)) || i23);
  return e18 && i23 && A8(r10, t23, i23), i23;
};
var d7 = (m15, r10) => (t23, e18) => r10(t23, e18, m15);
var o7 = class {
  constructor({ frameSize: r10, channel: t23 = Maybe.zero(), padding: e18 = false }, i23) {
    __publicField(this, "_frameSize");
    __publicField(this, "_channel");
    __publicField(this, "_padding");
    __publicField(this, "_logger");
    this._frameSize = r10, this._channel = t23, this._padding = e18, this._logger = i23("DefaultApduSenderService");
  }
  getFrames(r10) {
    const t23 = [];
    let e18 = 0, i23 = this.getFrameAtIndex(r10, e18);
    for (; i23.isRight(); ) t23.push(i23.extract()), e18 += 1, i23 = this.getFrameAtIndex(r10, e18).mapLeft((a24) => (a24 instanceof e5 || this._logger.error("Error while parsing frame", { data: { error: a24 } }), a24));
    return t23;
  }
  getFrameAtIndex(r10, t23) {
    const e18 = this.getFrameHeaderFrom(t23, r10.length), i23 = t23 === 0 ? 0 : t23 * this._frameSize - this.getHeaderSizeSumFrom(t23);
    if (i23 >= r10.length) return left(new e5());
    if (e18.getLength() > this._frameSize) return left(new i14());
    const a24 = this._frameSize - e18.getLength(), n18 = r10.slice(i23, i23 + this._frameSize - e18.getLength()), h5 = this._padding ? new Uint8Array(a24).fill(0) : new Uint8Array(n18.length < a24 ? n18.length : a24);
    h5.set(n18, 0);
    const S13 = new d4({ header: e18, data: h5 });
    return right(S13);
  }
  getFrameHeaderFrom(r10, t23) {
    const e18 = new d5({ uuid: v4_default(), channel: this._channel.map((i23) => u5.getLastBytesFrom(i23, E9)), headTag: new Uint8Array([o6]), index: u5.numberToByteArray(r10, A7), length: this.getFrameHeaderSizeFromIndex(r10), dataSize: Maybe.zero() });
    return r10 === 0 && e18.setDataSize(Maybe.of(u5.numberToByteArray(t23, H2))), e18;
  }
  getHeaderSizeSumFrom(r10) {
    let t23 = this.getFrameHeaderSizeFromIndex(0), e18 = 1;
    for (; e18 < r10; ) t23 += this.getFrameHeaderSizeFromIndex(e18), e18 += 1;
    return t23;
  }
  getFrameHeaderSizeFromIndex(r10) {
    return this._channel.caseOf({ Just: () => E9, Nothing: () => 0 }) + A7 + t11 + (r10 === 0 ? H2 : 0);
  }
};
o7 = c6([z2(), d7(1, N(e6.LoggerPublisherServiceFactory))], o7);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/service/DefaultApduSenderService.stub.js
var n9 = (e18 = {}, r10) => new o7({ frameSize: 64, channel: Maybe.of(new Uint8Array([18, 52])), padding: true, ...e18 }, r10);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/di/commandTypes.js
var e7 = { SendCommandUseCase: Symbol.for("SendCommandUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/di/configTypes.js
var o8 = { LocalConfigDataSource: Symbol.for("LocalConfigDataSource"), RemoteConfigDataSource: Symbol.for("RemoteConfigDataSource"), ConfigService: Symbol.for("ConfigService"), GetDmkVersionUseCase: Symbol.for("GetDmkVersionUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/di/deviceSessionTypes.js
var e8 = { ApduSenderServiceFactory: Symbol.for("ApduSenderServiceFactory"), ApduReceiverServiceFactory: Symbol.for("ApduReceiverServiceFactory"), DeviceSessionService: Symbol.for("DeviceSessionService"), GetDeviceSessionStateUseCase: Symbol.for("GetDeviceSessionStateUseCase"), DisableDeviceSessionRefresherUseCase: Symbol.for("DisableDeviceSessionRefresherUseCase"), CloseSessionsUseCase: Symbol.for("CloseSessionsUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/di/discoveryTypes.js
var e9 = { StartDiscoveringUseCase: Symbol.for("StartDiscoveringUseCase"), StopDiscoveringUseCase: Symbol.for("StopDiscoveringUseCase"), ConnectUseCase: Symbol.for("ConnectUseCase"), DisconnectUseCase: Symbol.for("DisconnectUseCase"), GetConnectedDeviceUseCase: Symbol.for("GetConnectedDeviceUseCase"), ListenToAvailableDevicesUseCase: Symbol.for("ListenToAvailableDevicesUseCase"), ListenToConnectedDeviceUseCase: Symbol.for("ListenToConnectedDeviceUseCase"), ListConnectedDevicesUseCase: Symbol.for("ListConnectedDevicesUseCase"), ReconnectUseCase: Symbol.for("ReconnectUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/di/managerApiTypes.js
var e10 = { ManagerApiService: Symbol.for("ManagerApiService"), ManagerApiDataSource: Symbol.for("ManagerApiDataSource"), DmkConfig: Symbol.for("ManagerApiDmkConfig"), SetProviderUseCase: Symbol.for("SetProviderUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/send/di/sendTypes.js
var e11 = { SendApduUseCase: Symbol.for("SendApduUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/transport/di/transportDiTypes.js
var r4 = { DmkConfig: Symbol.for("TransportDmkConfig"), TransportService: Symbol.for("TransportService"), TransportsInput: Symbol.for("TransportsInput") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/use-case/SendCommandUseCase.js
var S5 = Object.defineProperty;
var d8 = Object.getOwnPropertyDescriptor;
var g6 = (t23, e18, r10, s25) => {
  for (var o12 = s25 > 1 ? void 0 : s25 ? d8(e18, r10) : e18, i23 = t23.length - 1, c21; i23 >= 0; i23--) (c21 = t23[i23]) && (o12 = (s25 ? c21(e18, r10, o12) : c21(o12)) || o12);
  return s25 && o12 && S5(e18, r10, o12), o12;
};
var a12 = (t23, e18) => (r10, s25) => e18(r10, s25, t23);
var n10 = class {
  constructor(e18, r10) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = e18, this._logger = r10("SendCommandUseCase");
  }
  async execute({ sessionId: e18, command: r10, abortTimeout: s25 }) {
    return this._sessionService.getDeviceSessionById(e18).caseOf({ Right: async (i23) => await i23.sendCommand(r10, s25), Left: (i23) => {
      throw this._logger.error("Error getting session", { data: { error: i23 } }), i23;
    } });
  }
};
n10 = g6([z2(), a12(0, N(e8.DeviceSessionService)), a12(1, N(e6.LoggerPublisherServiceFactory))], n10);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/di.stub.js
var t12 = Object.defineProperty;
var x5 = Object.getOwnPropertyDescriptor;
var p9 = (f9, i23, l19, o12) => {
  for (var c21 = o12 > 1 ? void 0 : o12 ? x5(i23, l19) : i23, m15 = f9.length - 1, n18; m15 >= 0; m15--) (n18 = f9[m15]) && (c21 = (o12 ? n18(i23, l19, c21) : n18(c21)) || c21);
  return o12 && c21 && t12(i23, l19, c21), c21;
};
var r5 = class {
  constructor() {
    __publicField(this, "execute", vi.fn(() => "stub"));
  }
};
r5 = p9([z2()], r5);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/command/di/commandModule.js
var i15 = ({ stub: e18 = false } = {}) => new w6(({ bind: m15, rebindSync: a24 }) => {
  m15(e7.SendCommandUseCase).to(n10), e18 && a24(e7.SendCommandUseCase).to(r5);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/use-case/ExecuteDeviceActionUseCase.js
var p10 = Object.defineProperty;
var m4 = Object.getOwnPropertyDescriptor;
var v6 = (o12, r10, i23, t23) => {
  for (var e18 = t23 > 1 ? void 0 : t23 ? m4(r10, i23) : r10, n18 = o12.length - 1, c21; n18 >= 0; n18--) (c21 = o12[n18]) && (e18 = (t23 ? c21(r10, i23, e18) : c21(e18)) || e18);
  return t23 && e18 && p10(r10, i23, e18), e18;
};
var u6 = (o12, r10) => (i23, t23) => r10(i23, t23, o12);
var s18 = class {
  constructor(r10, i23) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = r10, this._logger = i23("ExecuteDeviceActionUseCase");
  }
  execute({ sessionId: r10, deviceAction: i23 }) {
    return this._sessionService.getDeviceSessionById(r10).caseOf({ Right: (e18) => e18.executeDeviceAction(i23), Left: (e18) => {
      throw this._logger.error("Error getting session", { data: { error: e18 } }), e18;
    } });
  }
};
s18 = v6([z2(), u6(0, N(e8.DeviceSessionService)), u6(1, N(e6.LoggerPublisherServiceFactory))], s18);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/di/deviceActionTypes.js
var e12 = { ExecuteDeviceActionUseCase: Symbol.for("ExecuteDeviceActionUseCase") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-action/di/deviceActionModule.js
var l9 = ({ stub: o12 = false } = {}) => new w6(({ bind: t23, rebindSync: i23 }) => {
  t23(e12.ExecuteDeviceActionUseCase).to(s18), o12 && i23(e12.ExecuteDeviceActionUseCase).to(r5);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/model/Config.js
function i16(n18) {
  return typeof n18 == "object" && n18 !== null && "version" in n18 && "name" in n18 && typeof n18.version == "string" && typeof n18.name == "string";
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/model/Errors.js
var a13 = class {
  constructor(r10) {
    __publicField(this, "_tag", "ApiCallError");
    __publicField(this, "originalError");
    this.err = r10;
    this.originalError = r10;
  }
};
var e13 = class {
  constructor(r10) {
    __publicField(this, "_tag", "ParseResponseError");
    __publicField(this, "originalError");
    this.err = r10;
    this.originalError = r10;
  }
};
var l10 = class {
  constructor(r10) {
    __publicField(this, "_tag", "JSONParseError");
    __publicField(this, "originalError");
    this.err = r10;
    this.originalError = r10;
  }
};
var i17 = class {
  constructor(r10) {
    __publicField(this, "_tag", "ReadFileError");
    __publicField(this, "originalError");
    this.err = r10;
    this.originalError = r10;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/package.json
var package_default = {
  dependencies: {
    "@noble/hashes": "^1.8.0",
    "@sentry/minimal": "catalog:",
    axios: "catalog:",
    inversify: "catalog:",
    "isomorphic-ws": "catalog:",
    "purify-ts": "catalog:",
    "reflect-metadata": "catalog:",
    semver: "catalog:",
    url: "catalog:",
    uuid: "catalog:",
    ws: "catalog:",
    xstate: "catalog:"
  },
  devDependencies: {
    "@ledgerhq/eslint-config-dsdk": "workspace:^",
    "@ledgerhq/ldmk-tool": "workspace:^",
    "@ledgerhq/prettier-config-dsdk": "workspace:^",
    "@ledgerhq/tsconfig-dsdk": "workspace:^",
    "@ledgerhq/vitest-config-dmk": "workspace:^",
    "@statelyai/inspect": "catalog:",
    "@types/semver": "catalog:",
    "@types/uuid": "catalog:",
    "@types/ws": "catalog:",
    rxjs: "catalog:",
    "ts-node": "catalog:"
  },
  exports: {
    ".": {
      import: "./lib/esm/index.js",
      require: "./lib/cjs/index.js",
      types: "./lib/types/index.d.ts"
    }
  },
  files: [
    "./lib",
    "package.json"
  ],
  license: "Apache-2.0",
  name: "@ledgerhq/device-management-kit",
  peerDependencies: {
    rxjs: "catalog:"
  },
  private: false,
  repository: {
    type: "git",
    url: "https://github.com/LedgerHQ/device-sdk-ts.git"
  },
  scripts: {
    build: "pnpm ldmk-tool build --entryPoints index.ts,src/**/*.ts --tsconfig tsconfig.prod.json",
    dev: 'concurrently "pnpm watch:builds" "pnpm watch:types"',
    lint: "eslint",
    "lint:fix": "pnpm lint --fix",
    "module:create": "pnpm hygen core-module with-prompt",
    postpack: "find . -name '*.tgz' -exec cp {} ../../dist/ \\; ",
    prebuild: "rimraf lib",
    prettier: "prettier . --check",
    "prettier:fix": "prettier . --write",
    test: "vitest run",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest",
    typecheck: "tsc --noEmit",
    "watch:builds": "pnpm ldmk-tool watch --entryPoints index.ts,src/**/*.ts --tsconfig tsconfig.prod.json",
    "watch:types": 'concurrently "tsc --watch -p tsconfig.prod.json" "tsc-alias --watch -p tsconfig.prod.json"'
  },
  version: "0.13.0"
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/data/LocalConfigDataSource.js
var c7 = Object.defineProperty;
var g7 = Object.getOwnPropertyDescriptor;
var s19 = (t23, r10, o12, n18) => {
  for (var e18 = n18 > 1 ? void 0 : n18 ? g7(r10, o12) : r10, f9 = t23.length - 1, m15; f9 >= 0; f9--) (m15 = t23[f9]) && (e18 = (n18 ? m15(r10, o12, e18) : m15(e18)) || e18);
  return n18 && e18 && c7(r10, o12, e18), e18;
};
var E11 = { name: package_default.name, version: package_default.version };
var h3 = () => JSON.stringify(E11);
var i18 = class {
  getConfig() {
    return Either.encase(() => h3()).mapLeft((r10) => new i17(r10)).chain((r10) => Either.encase(() => {
      const o12 = JSON.parse(r10);
      if (i16(o12)) return o12;
      throw new Error("Invalid config file");
    }).mapLeft((o12) => new l10(o12)));
  }
};
i18 = s19([z2()], i18);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/data/LocalConfigDataSource.stub.js
var s20 = Object.defineProperty;
var g8 = Object.getOwnPropertyDescriptor;
var p11 = (o12, r10, n18, i23) => {
  for (var e18 = i23 > 1 ? void 0 : i23 ? g8(r10, n18) : r10, t23 = o12.length - 1, f9; t23 >= 0; t23--) (f9 = o12[t23]) && (e18 = (i23 ? f9(r10, n18, e18) : f9(e18)) || e18);
  return i23 && e18 && s20(r10, n18, e18), e18;
};
var m5 = class {
  getConfig() {
    return Either.of({ name: "DeviceSDK", version: "0.0.0-stub.1" });
  }
};
m5 = p11([z2()], m5);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/data/RemoteConfigDataSource.js
var c8 = Object.defineProperty;
var E12 = Object.getOwnPropertyDescriptor;
var p12 = (s25, r10, e18, o12) => {
  for (var i23 = o12 > 1 ? void 0 : o12 ? E12(r10, e18) : r10, a24 = s25.length - 1, f9; a24 >= 0; a24--) (f9 = s25[a24]) && (i23 = (o12 ? f9(r10, e18, i23) : f9(i23)) || i23);
  return o12 && i23 && c8(r10, e18, i23), i23;
};
var t13 = class {
  async getConfig() {
    const r10 = await this._callApi();
    if (r10.isLeft()) return left(new a13(r10.extract()));
    if (!r10.extract().ok) return left(new a13(new Error("response not ok")));
    const e18 = await r10.extract().json();
    return e18.isLeft() ? left(new l10()) : e18.chain((o12) => this._parseResponse(o12)).map((o12) => o12);
  }
  _parseResponse(r10) {
    const { name: e18, version: o12 } = r10;
    return !e18 || !o12 ? left(new e13()) : Either.of({ name: e18, version: o12 });
  }
  _callApi() {
    return new Promise((r10) => {
      r10(Either.of({ ok: true, json: async () => new Promise((e18) => {
        e18(Either.of({ name: "DeviceSDK", version: "0.0.0-fake.1", yolo: "yolo" }));
      }) }));
    });
  }
};
t13 = p12([z2()], t13);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/data/RemoteConfigDataSource.stub.js
var t14 = Object.defineProperty;
var a14 = Object.getOwnPropertyDescriptor;
var p13 = (m15, r10, n18, i23) => {
  for (var e18 = i23 > 1 ? void 0 : i23 ? a14(r10, n18) : r10, f9 = m15.length - 1, s25; f9 >= 0; f9--) (s25 = m15[f9]) && (e18 = (i23 ? s25(r10, n18, e18) : s25(e18)) || e18);
  return i23 && e18 && t14(r10, n18, e18), e18;
};
var o9 = class {
  async getConfig() {
    return new Promise((r10) => r10(Either.of({ name: "DeviceSDK", version: "0.0.0-fake.2" })));
  }
};
o9 = p13([z2()], o9);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/service/DefaultConfigService.js
var s21 = Object.defineProperty;
var u7 = Object.getOwnPropertyDescriptor;
var f6 = (t23, e18, o12, r10) => {
  for (var i23 = r10 > 1 ? void 0 : r10 ? u7(e18, o12) : e18, c21 = t23.length - 1, n18; c21 >= 0; c21--) (n18 = t23[c21]) && (i23 = (r10 ? n18(e18, o12, i23) : n18(i23)) || i23);
  return r10 && i23 && s21(e18, o12, i23), i23;
};
var a15 = (t23, e18) => (o12, r10) => e18(o12, r10, t23);
var g9 = class {
  constructor(e18, o12, r10) {
    __publicField(this, "_local");
    __publicField(this, "_remote");
    __publicField(this, "_logger");
    this._local = e18, this._remote = o12, this._logger = r10("config");
  }
  async getDmkConfig() {
    const e18 = this._local.getConfig().ifLeft((o12) => {
      this._logger.error("Local config not available", { data: { error: o12 } });
    });
    if (e18.isRight()) {
      const o12 = e18.extract();
      return this._logger.info("Local config available", { data: { config: o12 } }), o12;
    }
    return this._remote.getConfig().then((o12) => o12.mapLeft((r10) => (this._logger.error("Local config available", { data: { error: r10 } }), { name: "DeadDmk", version: "0.0.0-dead.1" })).extract());
  }
};
g9 = f6([z2(), a15(0, N(o8.LocalConfigDataSource)), a15(1, N(o8.RemoteConfigDataSource)), a15(2, N(e6.LoggerPublisherServiceFactory))], g9);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/use-case/GetDmkVersionUseCase.js
var S6 = Object.defineProperty;
var p14 = Object.getOwnPropertyDescriptor;
var g10 = (e18, i23, o12, c21) => {
  for (var r10 = c21 > 1 ? void 0 : c21 ? p14(i23, o12) : i23, t23 = e18.length - 1, f9; t23 >= 0; t23--) (f9 = e18[t23]) && (r10 = (c21 ? f9(i23, o12, r10) : f9(r10)) || r10);
  return c21 && r10 && S6(i23, o12, r10), r10;
};
var v7 = (e18, i23) => (o12, c21) => i23(o12, c21, e18);
var n11 = class {
  constructor(i23) {
    __publicField(this, "_configService");
    this._configService = i23;
  }
  async getDmkVersion() {
    return (await this._configService.getDmkConfig()).version;
  }
};
n11 = g10([z2(), v7(0, N(o8.ConfigService))], n11);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/config/di/configModule.js
var y4 = ({ stub: r10 }) => new w6(({ bind: t23, rebindSync: e18 }) => {
  t23(o8.LocalConfigDataSource).to(i18), t23(o8.RemoteConfigDataSource).to(t13), t23(o8.GetDmkVersionUseCase).to(n11), t23(o8.ConfigService).to(g9), r10 && (e18(o8.LocalConfigDataSource).to(m5), e18(o8.RemoteConfigDataSource).to(o9));
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-model/di/deviceModelTypes.js
var e14 = { DeviceModelDataSource: Symbol.for("DeviceModelDataSource") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-model/di/deviceModelModule.js
var p15 = ({ stub: o12 }) => new w6(({ bind: e18 }) => {
  e18(e14.DeviceModelDataSource).to(i13);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/use-case/DisableDeviceSessionRefresher.js
var p16 = Object.defineProperty;
var l11 = Object.getOwnPropertyDescriptor;
var v8 = (o12, r10, i23, s25) => {
  for (var e18 = s25 > 1 ? void 0 : s25 ? l11(r10, i23) : r10, c21 = o12.length - 1, g23; c21 >= 0; c21--) (g23 = o12[c21]) && (e18 = (s25 ? g23(r10, i23, e18) : g23(e18)) || e18);
  return s25 && e18 && p16(r10, i23, e18), e18;
};
var n12 = (o12, r10) => (i23, s25) => r10(i23, s25, o12);
var t15 = class {
  constructor(r10, i23) {
    __publicField(this, "_logger");
    this._sessionService = r10;
    this._logger = i23("DisableDeviceSessionRefresherUseCase");
  }
  execute({ sessionId: r10, blockerId: i23 }) {
    return this._sessionService.getDeviceSessionById(r10).caseOf({ Left: (e18) => {
      throw this._logger.error("Error getting device session", { data: { error: e18 } }), e18;
    }, Right: (e18) => e18.disableRefresher(i23) });
  }
};
t15 = v8([z2(), n12(0, N(e8.DeviceSessionService)), n12(1, N(e6.LoggerPublisherServiceFactory))], t15);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/service/DefaultDeviceSessionService.js
var S7 = Object.defineProperty;
var a16 = Object.getOwnPropertyDescriptor;
var v9 = (r10, e18, s25, i23) => {
  for (var o12 = i23 > 1 ? void 0 : i23 ? a16(e18, s25) : e18, n18 = r10.length - 1, c21; n18 >= 0; n18--) (c21 = r10[n18]) && (o12 = (i23 ? c21(e18, s25, o12) : c21(o12)) || o12);
  return i23 && o12 && S7(e18, s25, o12), o12;
};
var h4 = (r10, e18) => (s25, i23) => e18(s25, i23, r10);
var t16 = class {
  constructor(e18) {
    __publicField(this, "_sessions");
    __publicField(this, "_sessionsSubject");
    __publicField(this, "_logger");
    this._sessions = [], this._sessionsSubject = new ReplaySubject(), this._logger = e18("DeviceSessionService");
  }
  get sessionsObs() {
    return this._sessionsSubject.asObservable();
  }
  addDeviceSession(e18) {
    return this._sessions.find((i23) => i23.id === e18.id) ? (this._logger.warn("DeviceSession already exists", { data: { deviceSession: e18 } }), this) : (this._sessions.push(e18), this._sessionsSubject.next(e18), this._logger.info("DeviceSession added", { data: { sessionId: e18.id } }), this);
  }
  removeDeviceSession(e18) {
    const s25 = this._sessions.find((i23) => i23.id === e18);
    return s25 ? (s25.close(), this._sessions = this._sessions.filter((i23) => i23.id !== e18), this._logger.info("DeviceSession removed", { data: { sessionId: e18 } }), this) : (this._logger.warn("DeviceSession not found", { data: { sessionId: e18 } }), this);
  }
  getDeviceSessionById(e18) {
    return Maybe.fromNullable(this._sessions.find((s25) => s25.id === e18)).toEither(new n8());
  }
  getDeviceSessionsByDeviceId(e18) {
    return Maybe.fromPredicate(({ length: s25 }) => s25 > 0, this._sessions.filter((s25) => s25.connectedDevice.id === e18)).toEither(new n8());
  }
  getDeviceSessions() {
    return this._sessions;
  }
};
t16 = v9([z2(), h4(0, N(e6.LoggerPublisherServiceFactory))], t16);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/use-case/CloseSessionsUseCase.js
var a17 = Object.defineProperty;
var m6 = Object.getOwnPropertyDescriptor;
var S8 = (o12, e18, i23, s25) => {
  for (var r10 = s25 > 1 ? void 0 : s25 ? m6(e18, i23) : e18, t23 = o12.length - 1, n18; t23 >= 0; t23--) (n18 = o12[t23]) && (r10 = (s25 ? n18(e18, i23, r10) : n18(r10)) || r10);
  return s25 && r10 && a17(e18, i23, r10), r10;
};
var v10 = (o12, e18) => (i23, s25) => e18(i23, s25, o12);
var c9 = class {
  constructor(e18, i23) {
    __publicField(this, "_sessionService");
    __publicField(this, "_transportService");
    this._sessionService = e18, this._transportService = i23;
  }
  execute() {
    const e18 = this._sessionService.getDeviceSessions();
    for (const i23 of e18) this._transportService.closeConnection(i23.connectedDevice), this._sessionService.removeDeviceSession(i23.id);
  }
};
c9 = S8([z2(), v10(0, N(e8.DeviceSessionService)), v10(1, N(r4.TransportService))], c9);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/use-case/GetDeviceSessionStateUseCase.js
var p17 = Object.defineProperty;
var a18 = Object.getOwnPropertyDescriptor;
var g11 = (o12, i23, r10, e18) => {
  for (var s25 = e18 > 1 ? void 0 : e18 ? a18(i23, r10) : i23, c21 = o12.length - 1, n18; c21 >= 0; c21--) (n18 = o12[c21]) && (s25 = (e18 ? n18(i23, r10, s25) : n18(s25)) || s25);
  return e18 && s25 && p17(i23, r10, s25), s25;
};
var v11 = (o12, i23) => (r10, e18) => i23(r10, e18, o12);
var t17 = class {
  constructor(i23, r10) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = i23, this._logger = r10("GetDeviceSessionStateUseCase");
  }
  execute({ sessionId: i23 }) {
    return this._sessionService.getDeviceSessionById(i23).caseOf({ Left: (e18) => {
      throw this._logger.error("Error getting session device", { data: { error: e18 } }), e18;
    }, Right: (e18) => e18.state });
  }
};
t17 = g11([z2(), v11(0, N(e8.DeviceSessionService)), v11(1, N(e6.LoggerPublisherServiceFactory))], t17);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/di/deviceSessionModule.js
var b4 = ({ stub: p30 } = { stub: false }) => new w6(({ bind: r10, rebindSync: i23 }) => {
  r10(e8.ApduSenderServiceFactory).toFactory((o12) => {
    const s25 = o12.get(e6.LoggerPublisherServiceFactory);
    return (t23) => new o7(t23, s25);
  }), r10(e8.ApduReceiverServiceFactory).toFactory((o12) => {
    const s25 = o12.get(e6.LoggerPublisherServiceFactory);
    return (t23 = {}) => new g5(t23, s25);
  }), r10(e8.DeviceSessionService).to(t16).inSingletonScope(), r10(e8.GetDeviceSessionStateUseCase).to(t17), r10(e8.CloseSessionsUseCase).to(c9), r10(e8.DisableDeviceSessionRefresherUseCase).to(t15), p30 && (i23(e8.GetDeviceSessionStateUseCase).to(r5), i23(e8.DisableDeviceSessionRefresherUseCase).to(r5));
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/data/DeviceSessionRefresherConst.js
var E13 = 1e3;
var I4 = 1e3;
var S9 = { isRefresherDisabled: false, pollingInterval: 1e3 };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/service/MutexService.js
var u8 = class {
  constructor() {
    __publicField(this, "_queue", []);
    __publicField(this, "_locked", false);
  }
  async lock() {
    return new Promise((e18) => {
      const s25 = () => {
        if (this._locked = false, this._queue.length > 0) {
          const t23 = this._queue.shift();
          this._locked = true, t23();
        }
      };
      this._locked ? this._queue.push(() => e18(s25)) : (this._locked = true, e18(s25));
    });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/service/RefresherService.js
var l12 = class {
  constructor(r10, e18) {
    __publicField(this, "_refresherBlockers", /* @__PURE__ */ new Set());
    __publicField(this, "_logger");
    this._refresher = e18;
    this._logger = r10("refresher-service");
  }
  disableRefresher(r10) {
    const e18 = `${r10}-${v4_default()}`;
    this.addRefresherBlocker(e18), this._logger.debug("Refresher disabled", { data: { blockerId: e18, blockers: Array.from(this._refresherBlockers) } });
    let s25 = false;
    return () => {
      s25 || (s25 = true, this.removeRefresherBlocker(e18), this._logger.debug("Refresher re-enabled", { data: { blockerId: e18, blockers: Array.from(this._refresherBlockers) } }));
    };
  }
  addRefresherBlocker(r10) {
    const e18 = this._refresherBlockers.size;
    this._refresherBlockers.add(r10), e18 === 0 && this._refresher.stop();
  }
  removeRefresherBlocker(r10) {
    const e18 = this._refresherBlockers.size;
    this._refresherBlockers.delete(r10), e18 > 0 && this._refresherBlockers.size === 0 && this._refresher.start();
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/DeviceSessionEventDispatcher.js
var t18 = ((e18) => (e18.NEW_STATE = "NEW_STATE", e18.REFRESH_NEEDED = "REFRESH_NEEDED", e18.COMMAND_SUCCEEDED = "COMMAND_SUCCEEDED", e18.DEVICE_STATE_UPDATE_BUSY = "DEVICE_STATE_UPDATE_BUSY", e18.DEVICE_STATE_UPDATE_LOCKED = "DEVICE_STATE_UPDATE_LOCKED", e18.DEVICE_STATE_UPDATE_CONNECTED = "DEVICE_STATE_UPDATE_CONNECTED", e18))(t18 || {});
var s22 = class {
  constructor() {
    __publicField(this, "_eventEmitter", new Subject());
  }
  listen() {
    return this._eventEmitter.asObservable();
  }
  dispatch(E14) {
    this._eventEmitter.next(E14);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/DevicePinger.js
var D4 = class {
  constructor(e18, t23, r10, n18) {
    __publicField(this, "_sendCommandFunction");
    __publicField(this, "_subscription");
    __publicField(this, "_logger");
    __publicField(this, "mapEventAction", async (e18) => {
      switch (e18.eventName) {
        case t18.REFRESH_NEEDED:
          return await this.ping();
        default:
          return null;
      }
    });
    this.connectedDevice = t23;
    this._sessionEventDispatcher = r10;
    this._sendCommandFunction = n18, this._logger = e18("device-pinger"), this._subscription = this._sessionEventDispatcher.listen().subscribe(async (s25) => await this.mapEventAction(s25));
  }
  async ping() {
    try {
      return await this.mapDevicePingAction(this.connectedDevice.deviceModel.id);
    } catch (e18) {
      throw this._logger.error("Error while pinging device", { data: { error: e18 } }), e18;
    }
  }
  async mapDevicePingAction(e18) {
    switch (e18) {
      case t2.NANO_S: {
        const t23 = async () => {
          const s25 = await this._sendCommandFunction(new R(), T4);
          return this._sendCommandFunction(new P(), T4), s25;
        }, r10 = new Promise((s25) => {
          setTimeout(() => s25(null), E13 * 2 + 100);
        }), n18 = await Promise.race([t23(), r10]);
        return n18 ? this._sessionEventDispatcher.dispatch({ eventName: t18.COMMAND_SUCCEEDED, eventData: n18 }) : this._sessionEventDispatcher.dispatch({ eventName: t18.DEVICE_STATE_UPDATE_LOCKED }), n18;
      }
      default: {
        const t23 = await this._sendCommandFunction(new R(), T4);
        return this._sessionEventDispatcher.dispatch({ eventName: t18.COMMAND_SUCCEEDED, eventData: t23 }), t23;
      }
    }
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/DeviceSessionRefresher.js
var d9 = class {
  constructor(i23, s25, e18, r10) {
    __publicField(this, "_refresherSubscription");
    __publicField(this, "_refresherOptions");
    __publicField(this, "_logger");
    __publicField(this, "_connectedDeviceID");
    __publicField(this, "getValidPollingInterval", (i23, s25) => {
      const { pollingInterval: e18 } = i23;
      switch (this._connectedDeviceID) {
        case t2.NANO_S: {
          const r10 = E13 * 2;
          return e18 !== void 0 && e18 < r10 ? (s25.warn(`Polling interval of ${e18} is too low, setting to minimum as ${r10}`), r10) : e18 ?? r10;
        }
        default:
          return e18 !== void 0 && e18 < I4 ? (s25.warn(`Polling interval of ${e18} is too low, setting to minimum as ${I4}`), I4) : e18 ?? E13;
      }
    });
    this._sessionEventDispatcher = e18;
    this._refresherOptions = s25, this._logger = i23("device-session-refresher"), this._connectedDeviceID = r10.deviceModel.id;
  }
  startRefresher() {
    if (this._refresherOptions.isRefresherDisabled) return;
    const i23 = this.getValidPollingInterval(this._refresherOptions, this._logger) * 2;
    this._refresherSubscription = timer(0, i23).subscribe(() => {
      this._sessionEventDispatcher.dispatch({ eventName: t18.REFRESH_NEEDED });
    });
  }
  stopRefresher() {
    this._refresherSubscription && (this._refresherSubscription.unsubscribe(), this._refresherSubscription = void 0, this._logger.info("Refresher stopped."));
  }
  restartRefresher() {
    this.stopRefresher(), this.startRefresher(), this._logger.info("Refresher restarted.");
  }
  destroy() {
    this.stopRefresher();
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/DeviceSessionStateHandler.js
var d10 = class {
  constructor(e18, n18, a24, c21, r10) {
    __publicField(this, "_subscription");
    __publicField(this, "_logger");
    __publicField(this, "mapEventAction", (e18) => {
      switch (e18.eventName) {
        case t18.COMMAND_SUCCEEDED:
          return this._updateDeviceState(e18.eventData);
        case t18.DEVICE_STATE_UPDATE_BUSY:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: E.BUSY });
        case t18.DEVICE_STATE_UPDATE_LOCKED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: E.LOCKED });
        case t18.DEVICE_STATE_UPDATE_CONNECTED:
          return this.setDeviceSessionState({ ...this._deviceState.getValue(), deviceStatus: E.CONNECTED });
        default:
          return null;
      }
    });
    this._sessionEventDispatcher = n18;
    this._connectedDevice = a24;
    this._deviceState = c21;
    this.setDeviceSessionState = r10;
    this._subscription = this._sessionEventDispatcher.listen().subscribe((t23) => this.mapEventAction(t23)), this._logger = e18("device-session-state-handler");
  }
  _updateDeviceState(e18) {
    const n18 = this._parseDeviceStatus(e18);
    if (n18) {
      const { sessionStateType: a24, deviceStatus: c21, currentApp: r10 } = n18, t23 = this._deviceState.getValue();
      t23.sessionStateType === a6.Connected ? this.setDeviceSessionState({ sessionStateType: a24, deviceStatus: c21, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: r10, installedApps: [], isSecureConnectionAllowed: false }) : this.setDeviceSessionState({ ...t23, sessionStateType: a24, deviceStatus: c21, deviceModelId: this._connectedDevice.deviceModel.id, currentApp: r10 });
    }
  }
  _parseDeviceStatus(e18) {
    return s5(e18) ? { sessionStateType: a6.ReadyWithoutSecureChannel, deviceStatus: E.CONNECTED, currentApp: { name: e18.data.name, version: e18.data.version } } : (this._logger.debug("Error while parsing APDU response", { data: { parsedResponse: e18 } }), null);
  }
  unsubscribe() {
    this._subscription.unsubscribe();
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/device-session/model/DeviceSession.js
var L3 = class {
  constructor({ connectedDevice: e18, id: r10 = v4_default() }, s25, t23, i23, n18) {
    __publicField(this, "_id");
    __publicField(this, "_connectedDevice");
    __publicField(this, "_deviceState");
    __publicField(this, "_managerApiService");
    __publicField(this, "_secureChannelService");
    __publicField(this, "_logger");
    __publicField(this, "_refresherOptions");
    __publicField(this, "_pinger");
    __publicField(this, "_deviceSessionRefresher");
    __publicField(this, "_refresherService");
    __publicField(this, "_commandMutex", new u8());
    __publicField(this, "_sessionEventDispatcher", new s22());
    this._id = r10, this._connectedDevice = e18, this._logger = s25("device-session"), this._managerApiService = t23, this._secureChannelService = i23, this._refresherOptions = { ...S9, ...n18 }, this._deviceState = new BehaviorSubject({ sessionStateType: a6.Connected, deviceStatus: E.CONNECTED, deviceModelId: this._connectedDevice.deviceModel.id }), this._pinger = new D4(s25, e18, this._sessionEventDispatcher, (c21, p30) => this.sendCommand(c21, p30)), this._deviceSessionRefresher = new d9(s25, this._refresherOptions, this._sessionEventDispatcher, this._connectedDevice), new d10(s25, this._sessionEventDispatcher, this._connectedDevice, this._deviceState, (c21) => this.setDeviceSessionState(c21)), this._refresherService = new l12(s25, { start: () => this._deviceSessionRefresher.restartRefresher(), stop: () => this._deviceSessionRefresher.stopRefresher() });
  }
  async initialiseSession() {
    try {
      await this._pinger.ping();
    } catch (e18) {
      throw this._logger.error("Error while initialising session", { data: { error: e18 } }), e18;
    } finally {
      this._refresherOptions.isRefresherDisabled || this._deviceSessionRefresher.startRefresher();
    }
  }
  get id() {
    return this._id;
  }
  get connectedDevice() {
    return this._connectedDevice;
  }
  get state() {
    return this._deviceState.asObservable();
  }
  getDeviceSessionState() {
    return this._deviceState.getValue();
  }
  setDeviceSessionState(e18) {
    this._deviceState.next(e18);
  }
  async sendApdu(e18, r10 = { isPolling: false, triggersDisconnection: false, abortTimeout: void 0 }) {
    const s25 = await this._commandMutex.lock();
    try {
      this._sessionEventDispatcher.dispatch({ eventName: t18.DEVICE_STATE_UPDATE_BUSY }), this._logger.debug(`[exchange] => ${o(e18, false)}`);
      const t23 = await this._connectedDevice.sendApdu(e18, r10.triggersDisconnection, r10.abortTimeout);
      return t23.ifRight((i23) => {
        this._logger.debug(`[exchange] <= ${o(i23.data, false)}${o(i23.statusCode, false)}`), e2.isLockedDeviceResponse(i23) ? this._sessionEventDispatcher.dispatch({ eventName: t18.DEVICE_STATE_UPDATE_LOCKED }) : this._sessionEventDispatcher.dispatch({ eventName: t18.DEVICE_STATE_UPDATE_CONNECTED });
      }).ifLeft(() => {
        this._sessionEventDispatcher.dispatch({ eventName: t18.DEVICE_STATE_UPDATE_CONNECTED });
      }), t23;
    } finally {
      s25();
    }
  }
  async sendCommand(e18, r10) {
    this._logger.debug(`[sendCommand] ${e18.name}`);
    const s25 = e18.getApdu();
    return (await this.sendApdu(s25.getRawApdu(), { isPolling: false, triggersDisconnection: e18.triggersDisconnection ?? false, abortTimeout: r10 })).caseOf({ Left: (i23) => {
      throw this._logger.error("[sendCommand] error", { data: { err: i23 } }), i23;
    }, Right: (i23) => {
      const n18 = e18.parseResponse(i23, this._connectedDevice.deviceModel.id);
      return this._logger.debug("[sendCommand] result", { data: { result: n18 } }), n18;
    } });
  }
  executeDeviceAction(e18) {
    const { observable: r10, cancel: s25 } = e18._execute({ sendApdu: async (t23) => this.sendApdu(t23), sendCommand: async (t23, i23) => this.sendCommand(t23, i23), getDeviceModel: () => this._connectedDevice.deviceModel, getDeviceSessionState: () => this._deviceState.getValue(), getDeviceSessionStateObservable: () => this.state, setDeviceSessionState: (t23) => (this.setDeviceSessionState(t23), this._deviceState.getValue()), disableRefresher: (t23) => this._refresherService.disableRefresher(t23), getManagerApiService: () => this._managerApiService, getSecureChannelService: () => this._secureChannelService });
    return { observable: r10, cancel: s25 };
  }
  close() {
    this._updateDeviceStatus(E.NOT_CONNECTED), this._deviceState.complete(), this._deviceSessionRefresher.stopRefresher();
  }
  disableRefresher(e18) {
    return this._refresherService.disableRefresher(e18);
  }
  _updateDeviceStatus(e18) {
    const r10 = this._deviceState.getValue();
    this._deviceState.next({ ...r10, deviceStatus: e18 });
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/di/secureChannelTypes.js
var e15 = { SecureChannelService: Symbol.for("SecureChannelService"), SecureChannelDataSource: Symbol.for("SecureChannelDataSource"), DmkConfig: Symbol.for("SecureChannelDmkConfig") };

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/ConnectUseCase.js
var S10 = Object.defineProperty;
var g12 = Object.getOwnPropertyDescriptor;
var p18 = (c21, e18, s25, i23) => {
  for (var o12 = i23 > 1 ? void 0 : i23 ? g12(e18, s25) : e18, r10 = c21.length - 1, n18; r10 >= 0; r10--) (n18 = c21[r10]) && (o12 = (i23 ? n18(e18, s25, o12) : n18(o12)) || o12);
  return i23 && o12 && S10(e18, s25, o12), o12;
};
var t19 = (c21, e18) => (s25, i23) => e18(s25, i23, c21);
var v12 = class {
  constructor(e18, s25, i23, o12, r10) {
    __publicField(this, "_transportService");
    __publicField(this, "_sessionService");
    __publicField(this, "_loggerFactory");
    __publicField(this, "_managerApi");
    __publicField(this, "_secureChannel");
    __publicField(this, "_logger");
    this._sessionService = s25, this._transportService = e18, this._loggerFactory = i23, this._logger = i23("ConnectUseCase"), this._managerApi = o12, this._secureChannel = r10;
  }
  handleDeviceDisconnect(e18) {
    this._sessionService.getDeviceSessionsByDeviceId(e18).ifRight((s25) => {
      s25.forEach((i23) => {
        this._sessionService.removeDeviceSession(i23.id), this._logger.info("Session removed", { data: { deviceId: e18, sessionId: i23.id } });
      });
    });
  }
  async execute({ device: e18, sessionRefresherOptions: s25 }) {
    const i23 = this._transportService.getTransport(e18.transport), o12 = "sessionId" in e18 ? e18.sessionId : void 0;
    return EitherAsync.liftEither(i23.toEither(new i8(new Error("Unknown transport")))).chain(async (r10) => r10.connect({ deviceId: e18.id, onDisconnect: (n18) => this.handleDeviceDisconnect(n18) })).ifLeft((r10) => {
      this._logger.error("Error connecting to device", { data: { deviceId: e18.id, error: r10 } });
    }).map(async (r10) => {
      const n18 = new L3({ connectedDevice: r10, id: o12 }, this._loggerFactory, this._managerApi, this._secureChannel, s25);
      return this._sessionService.addDeviceSession(n18), await n18.initialiseSession(), n18.id;
    }).caseOf({ Left: (r10) => {
      throw r10;
    }, Right: (r10) => r10 });
  }
};
v12 = p18([z2(), t19(0, N(r4.TransportService)), t19(1, N(e8.DeviceSessionService)), t19(2, N(e6.LoggerPublisherServiceFactory)), t19(3, N(e10.ManagerApiService)), t19(4, N(e15.SecureChannelService))], v12);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/DisconnectUseCase.js
var S11 = Object.defineProperty;
var g13 = Object.getOwnPropertyDescriptor;
var p19 = (s25, r10, e18, i23) => {
  for (var o12 = i23 > 1 ? void 0 : i23 ? g13(r10, e18) : r10, t23 = s25.length - 1, n18; t23 >= 0; t23--) (n18 = s25[t23]) && (o12 = (i23 ? n18(r10, e18, o12) : n18(o12)) || o12);
  return i23 && o12 && S11(r10, e18, o12), o12;
};
var c10 = (s25, r10) => (e18, i23) => r10(e18, i23, s25);
var v13 = class {
  constructor(r10, e18, i23) {
    __publicField(this, "_transportService");
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = e18, this._transportService = r10, this._logger = i23("DisconnectUseCase");
  }
  async execute({ sessionId: r10 }) {
    return this._logger.debug("Disconnecting from device", { data: { test: this._sessionService.getDeviceSessions().map((e18) => e18.id) } }), EitherAsync(async ({ liftEither: e18 }) => {
      const i23 = await e18(this._sessionService.getDeviceSessionById(r10).ifLeft((n18) => {
        this._logger.error("Device session not found", { data: { sessionId: r10, error: n18 } });
      })), o12 = i23.connectedDevice.transport, t23 = await e18(this._transportService.getTransport(o12).toEither(new i8(new Error("Unknown transport"))));
      i23.close(), this._sessionService.removeDeviceSession(r10), await t23.disconnect({ connectedDevice: i23.connectedDevice });
    }).caseOf({ Left: (e18) => {
      throw this._logger.error("Error disconnecting from device", { data: { error: e18 } }), e18;
    }, Right: () => {
    } });
  }
};
v13 = p19([z2(), c10(0, N(r4.TransportService)), c10(1, N(e8.DeviceSessionService)), c10(2, N(e6.LoggerPublisherServiceFactory))], v13);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/transport/model/ConnectedDevice.js
var c11 = class {
  constructor({ transportConnectedDevice: { id: e18, deviceModel: { id: o12, productName: n18 }, type: t23, transport: i23, name: r10 }, sessionId: d18 }) {
    __publicField(this, "id");
    __publicField(this, "sessionId");
    __publicField(this, "modelId");
    __publicField(this, "name");
    __publicField(this, "type");
    __publicField(this, "transport");
    this.id = e18, this.sessionId = d18, this.modelId = o12, this.name = r10 ?? n18, this.type = t23, this.transport = i23;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/GetConnectedDeviceUseCase.js
var d11 = Object.defineProperty;
var p20 = Object.getOwnPropertyDescriptor;
var g14 = (o12, i23, r10, e18) => {
  for (var s25 = e18 > 1 ? void 0 : e18 ? p20(i23, r10) : i23, t23 = o12.length - 1, n18; t23 >= 0; t23--) (n18 = o12[t23]) && (s25 = (e18 ? n18(i23, r10, s25) : n18(s25)) || s25);
  return e18 && s25 && d11(i23, r10, s25), s25;
};
var v14 = (o12, i23) => (r10, e18) => i23(r10, e18, o12);
var c12 = class {
  constructor(i23, r10) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = i23, this._logger = r10("GetConnectedDeviceUseCase");
  }
  execute({ sessionId: i23 }) {
    return this._sessionService.getDeviceSessionById(i23).caseOf({ Right: (e18) => new c11({ sessionId: e18.id, transportConnectedDevice: e18.connectedDevice }), Left: (e18) => {
      throw this._logger.error("Error getting session", { data: { error: e18 } }), e18;
    } });
  }
};
c12 = g14([z2(), v14(0, N(e8.DeviceSessionService)), v14(1, N(e6.LoggerPublisherServiceFactory))], c12);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/ListConnectedDevicesUseCase.js
var p21 = Object.defineProperty;
var l13 = Object.getOwnPropertyDescriptor;
var g15 = (c21, e18, i23, o12) => {
  for (var r10 = o12 > 1 ? void 0 : o12 ? l13(e18, i23) : e18, n18 = c21.length - 1, t23; n18 >= 0; n18--) (t23 = c21[n18]) && (r10 = (o12 ? t23(e18, i23, r10) : t23(r10)) || r10);
  return o12 && r10 && p21(e18, i23, r10), r10;
};
var v15 = (c21, e18) => (i23, o12) => e18(i23, o12, c21);
var s23 = class {
  constructor(e18, i23) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = e18, this._logger = i23("ListConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Listing connected devices"), this._sessionService.getDeviceSessions().map((e18) => new c11({ transportConnectedDevice: e18.connectedDevice, sessionId: e18.id }));
  }
};
s23 = g15([z2(), v15(0, N(e8.DeviceSessionService)), v15(1, N(e6.LoggerPublisherServiceFactory))], s23);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/ListenToAvailableDevicesUseCase.js
var m7 = Object.defineProperty;
var g16 = Object.getOwnPropertyDescriptor;
var v16 = (n18, r10, t23, o12) => {
  for (var e18 = o12 > 1 ? void 0 : o12 ? g16(r10, t23) : r10, i23 = n18.length - 1, s25; i23 >= 0; i23--) (s25 = n18[i23]) && (e18 = (o12 ? s25(r10, t23, e18) : s25(e18)) || e18);
  return o12 && e18 && m7(r10, t23, e18), e18;
};
var p22 = (n18, r10) => (t23, o12) => r10(t23, o12, n18);
var a19 = class {
  constructor(r10, t23) {
    __publicField(this, "_transports");
    __publicField(this, "_transportService");
    __publicField(this, "_logger");
    this._transports = r10.getAllTransports(), this._transportService = r10, this._logger = t23("ListenToAvailableDevicesUseCase");
  }
  mapTransportDiscoveredDeviceToDiscoveredDevice(r10) {
    const t23 = new i6({ id: r10.id, model: r10.deviceModel.id, name: r10.deviceModel.productName });
    return { id: r10.id, deviceModel: t23, transport: r10.transport, name: r10.name || t23.name, rssi: r10.rssi };
  }
  execute({ transport: r10 } = {}) {
    if (this._logger.info("Listening to available devices"), this._transports.length === 0) return this._logger.warn("No transports available"), from([[]]);
    if (!r10) {
      this._logger.info("Discovering all available transports");
      const o12 = this._transports.map((e18, i23) => e18.listenToAvailableDevices().pipe(map((s25) => ({ index: i23, arr: s25 }))));
      return merge(...o12).pipe(scan((e18, { index: i23, arr: s25 }) => (e18[i23] = s25, e18), {}), map((e18) => Object.values(e18).flat().map(this.mapTransportDiscoveredDeviceToDiscoveredDevice)));
    }
    return this._logger.info(`Discovering devices on transport ${r10}`), this._transportService.getTransport(r10).caseOf({ Nothing: () => (this._logger.error(`Transport ${r10} not found`), of([])), Just: (o12) => o12.listenToAvailableDevices().pipe(map((e18) => e18.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice))) });
  }
};
a19 = v16([z2(), p22(0, N(r4.TransportService)), p22(1, N(e6.LoggerPublisherServiceFactory))], a19);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/ListenToConnectedDeviceUseCase.js
var l14 = Object.defineProperty;
var m8 = Object.getOwnPropertyDescriptor;
var g17 = (s25, e18, r10, o12) => {
  for (var i23 = o12 > 1 ? void 0 : o12 ? m8(e18, r10) : e18, t23 = s25.length - 1, n18; t23 >= 0; t23--) (n18 = s25[t23]) && (i23 = (o12 ? n18(e18, r10, i23) : n18(i23)) || i23);
  return o12 && i23 && l14(e18, r10, i23), i23;
};
var v17 = (s25, e18) => (r10, o12) => e18(r10, o12, s25);
var c13 = class {
  constructor(e18, r10) {
    __publicField(this, "_logger");
    this._sessionService = e18;
    this._logger = r10("ListenToConnectedDeviceUseCase");
  }
  execute() {
    return this._logger.info("Observe connected devices"), this._sessionService.sessionsObs.pipe(map((e18) => new c11({ transportConnectedDevice: e18.connectedDevice, sessionId: e18.id })));
  }
};
c13 = g17([z2(), v17(0, N(e8.DeviceSessionService)), v17(1, N(e6.LoggerPublisherServiceFactory))], c13);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/ReconnectUseCase.js
var d12 = Object.defineProperty;
var C3 = Object.getOwnPropertyDescriptor;
var p23 = (i23, e18, s25, o12) => {
  for (var r10 = o12 > 1 ? void 0 : o12 ? C3(e18, s25) : e18, c21 = i23.length - 1, a24; c21 >= 0; c21--) (a24 = i23[c21]) && (r10 = (o12 ? a24(e18, s25, r10) : a24(r10)) || r10);
  return o12 && r10 && d12(e18, s25, r10), r10;
};
var t20 = (i23, e18) => (s25, o12) => e18(s25, o12, i23);
var n13 = class {
  constructor(e18, s25, o12) {
    __publicField(this, "_logger");
    this.connectUseCase = e18;
    this.disconnectUseCase = s25;
    this._logger = o12("ReconnectUseCase");
  }
  async execute({ device: e18, sessionRefresherOptions: s25 }) {
    return this._logger.debug("Reconnecting device session", { data: { deviceId: e18.id, transport: e18.transport } }), await this.disconnectUseCase.execute({ sessionId: e18.sessionId }), this.connectUseCase.execute({ device: e18, sessionRefresherOptions: s25 });
  }
};
n13 = p23([z2(), t20(0, N(e9.ConnectUseCase)), t20(1, N(e9.DisconnectUseCase)), t20(2, N(e6.LoggerPublisherServiceFactory))], n13);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/StartDiscoveringUseCase.js
var v18 = Object.defineProperty;
var d13 = Object.getOwnPropertyDescriptor;
var a20 = (i23, r10, o12, t23) => {
  for (var e18 = t23 > 1 ? void 0 : t23 ? d13(r10, o12) : r10, s25 = i23.length - 1, n18; s25 >= 0; s25--) (n18 = i23[s25]) && (e18 = (t23 ? n18(r10, o12, e18) : n18(e18)) || e18);
  return t23 && e18 && v18(r10, o12, e18), e18;
};
var c14 = (i23, r10) => (o12, t23) => r10(o12, t23, i23);
var p24 = class {
  constructor(r10) {
    this._transportService = r10;
  }
  mapDiscoveredDevice(r10) {
    const o12 = new i6({ id: r10.id, model: r10.deviceModel.id, name: r10.deviceModel.productName });
    return { id: r10.id, deviceModel: o12, transport: r10.transport, name: r10.name || o12.name, rssi: r10.rssi };
  }
  execute({ transport: r10 } = {}) {
    if (!r10) {
      const t23 = this._transportService.getAllTransports();
      return of(...t23).pipe(mergeMap((e18) => e18.startDiscovering().pipe(map((s25) => this.mapDiscoveredDevice(s25)))));
    }
    return this._transportService.getTransport(r10).caseOf({ Just: (t23) => t23.startDiscovering().pipe(map((e18) => this.mapDiscoveredDevice(e18))), Nothing: () => {
      throw new i8(new Error("Unknown transport"));
    } });
  }
};
p24 = a20([z2(), c14(0, N(r4.TransportService))], p24);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/use-case/StopDiscoveringUseCase.js
var l15 = Object.defineProperty;
var v19 = Object.getOwnPropertyDescriptor;
var a21 = (i23, r10, e18, t23) => {
  for (var o12 = t23 > 1 ? void 0 : t23 ? v19(r10, e18) : r10, g23 = i23.length - 1, p30; g23 >= 0; g23--) (p30 = i23[g23]) && (o12 = (t23 ? p30(r10, e18, o12) : p30(o12)) || o12);
  return t23 && o12 && l15(r10, e18, o12), o12;
};
var c15 = (i23, r10) => (e18, t23) => r10(e18, t23, i23);
var s24 = class {
  constructor(r10, e18) {
    __publicField(this, "_logger");
    this.transportService = r10;
    this._logger = e18("StopDiscoveringUseCase");
  }
  async execute() {
    this._logger.debug("Stopping discovering devices");
    for (const r10 of this.transportService.getAllTransports()) await r10.stopDiscovering();
  }
};
s24 = a21([z2(), c15(0, N(r4.TransportService)), c15(1, N(e6.LoggerPublisherServiceFactory))], s24);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/discovery/di/discoveryModule.js
var w7 = ({ stub: a24 = false }) => new w6(({ bind: o12, rebindSync: s25 }) => {
  o12(e9.ConnectUseCase).to(v12), o12(e9.DisconnectUseCase).to(v13), o12(e9.ReconnectUseCase).to(n13), o12(e9.StartDiscoveringUseCase).to(p24), o12(e9.StopDiscoveringUseCase).to(s24), o12(e9.GetConnectedDeviceUseCase).to(c12), o12(e9.ListenToAvailableDevicesUseCase).to(a19), o12(e9.ListenToConnectedDeviceUseCase).to(c13), o12(e9.ListConnectedDevicesUseCase).to(s23), a24 && (s25(e9.ConnectUseCase).to(r5), s25(e9.DisconnectUseCase).to(r5), s25(e9.StartDiscoveringUseCase).to(r5), s25(e9.StopDiscoveringUseCase).to(r5), s25(e9.GetConnectedDeviceUseCase).to(r5), s25(e9.ListenToAvailableDevicesUseCase).to(r5), s25(e9.ListenToConnectedDeviceUseCase).to(r5), s25(e9.ListConnectedDevicesUseCase).to(r5));
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/logger-subscriber/model/LogLevel.js
var n14 = ((r10) => (r10[r10.Fatal = 0] = "Fatal", r10[r10.Error = 1] = "Error", r10[r10.Warning = 2] = "Warning", r10[r10.Info = 3] = "Info", r10[r10.Debug = 4] = "Debug", r10))(n14 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/logger-publisher/service/DefaultLoggerPublisherService.js
var c16 = Object.defineProperty;
var m9 = Object.getOwnPropertyDescriptor;
var p25 = (b6, r10, i23, s25) => {
  for (var o12 = s25 > 1 ? void 0 : s25 ? m9(r10, i23) : r10, t23 = b6.length - 1, n18; t23 >= 0; t23--) (n18 = b6[t23]) && (o12 = (s25 ? n18(r10, i23, o12) : n18(o12)) || o12);
  return s25 && o12 && c16(r10, i23, o12), o12;
};
var e16 = class {
  constructor(r10, i23) {
    __publicField(this, "subscribers");
    __publicField(this, "tag");
    this.subscribers = r10, this.tag = i23;
  }
  _log(r10, i23, s25) {
    this.subscribers.forEach((o12) => {
      const t23 = { timestamp: Date.now(), tag: this.tag, ...s25 };
      o12.log(r10, i23, t23);
    });
  }
  info(r10, i23) {
    this._log(n14.Info, r10, i23);
  }
  warn(r10, i23) {
    this._log(n14.Warning, r10, i23);
  }
  debug(r10, i23) {
    this._log(n14.Debug, r10, i23);
  }
  error(r10, i23) {
    this._log(n14.Error, r10, i23);
  }
};
e16 = p25([z2()], e16);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/logger-publisher/di/loggerModule.js
var u9 = ({ subscribers: r10 } = { subscribers: [] }) => new w6(({ bind: e18 }) => {
  e18(e6.LoggerPublisherServiceFactory).toFactory((g23) => (o12) => new e16(r10, o12));
});

// node_modules/axios/lib/helpers/bind.js
function bind2(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator: iterator2, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray: isArray5 } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction2 = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator2 in val);
};
var isEmptyObject = (val) => {
  if (!isObject2(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e18) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction2(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i23;
  let l19;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray5(obj)) {
    for (i23 = 0, l19 = obj.length; i23 < l19; i23++) {
      fn.call(null, obj[i23], i23, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i23 = 0; i23 < len; i23++) {
      key = keys[i23];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i23 = keys.length;
  let _key;
  while (i23-- > 0) {
    _key = keys[i23];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge3() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge3(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge3({}, val);
    } else if (isArray5(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i23 = 0, l19 = arguments.length; i23 < l19; i23++) {
    arguments[i23] && forEach(arguments[i23], assignValue);
  }
  return result;
}
var extend = (a24, b6, thisArg, { allOwnKeys } = {}) => {
  forEach(b6, (val, key) => {
    if (thisArg && isFunction2(val)) {
      a24[key] = bind2(val, thisArg);
    } else {
      a24[key] = val;
    }
  }, { allOwnKeys });
  return a24;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i23;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i23 = props.length;
    while (i23-- > 0) {
      prop = props[i23];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray3 = (thing) => {
  if (!thing) return null;
  if (isArray5(thing)) return thing;
  let i23 = thing.length;
  if (!isNumber(i23)) return null;
  const arr = new Array(i23);
  while (i23-- > 0) {
    arr[i23] = thing[i23];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator2];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m15, p1, p210) {
      return p1.toUpperCase() + p210;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction2(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray5(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction2(thing.append) && thing[toStringTag] === "FormData" && thing[iterator2]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i23) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i23] = source;
        const target = isArray5(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i23 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i23] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject2(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction2(_global.postMessage)
);
var asap2 = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable2 = (thing) => thing != null && isFunction2(thing[iterator2]);
var utils_default = {
  isArray: isArray5,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject2,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge3,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray3,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap: asap2,
  isIterable: isIterable2
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config2, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i23) {
    token = removeBrackets(token);
    return !dots && i23 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h5) {
      if (h5 !== null) {
        fn(h5);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default2
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers3) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers3.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i23;
  const len = keys.length;
  let key;
  for (i23 = 0; i23 < len; i23++) {
    key = keys[i23];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e18) {
      if (e18.name !== "SyntaxError") {
        throw e18;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e18) {
        if (strictJSONParsing) {
          if (e18.name === "SyntaxError") {
            throw AxiosError_default.from(e18, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e18;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i23;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i23 = line.indexOf(":");
    key = line.substring(0, i23).trim().toLowerCase();
    val = line.substring(i23 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context2, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w8, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i23 = keys.length;
    let deleted = false;
    while (i23--) {
      const key = keys[i23];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context2 = response || config2;
  const headers = AxiosHeaders_default.from(context2.headers);
  let data = context2.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config2, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i23 = tail;
    let bytesCount = 0;
    while (i23 !== head) {
      bytesCount += bytes[i23++];
      i23 = i23 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle2(fn, freq) {
  let timestamp2 = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer2;
  const invoke = (args, now = Date.now()) => {
    timestamp2 = now;
    lastArgs = null;
    if (timer2) {
      clearTimeout(timer2);
      timer2 = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp2;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer2) {
        timer2 = setTimeout(() => {
          timer2 = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle2;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e18) => {
    const loaded = e18.loaded;
    const total = e18.lengthComputable ? e18.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e18,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure, sameSite) {
      if (typeof document === "undefined") return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined") return null;
      const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match ? decodeURIComponent(match[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a24, b6, prop, caseless) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(a24, b6, prop, caseless);
    } else if (!utils_default.isUndefined(a24)) {
      return getMergedValue(void 0, a24, prop, caseless);
    }
  }
  function valueFromConfig2(a24, b6) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    }
  }
  function defaultToConfig2(a24, b6) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    } else if (!utils_default.isUndefined(a24)) {
      return getMergedValue(void 0, a24);
    }
  }
  function mergeDirectKeys(a24, b6, prop) {
    if (prop in config2) {
      return getMergedValue(a24, b6);
    } else if (prop in config1) {
      return getMergedValue(void 0, a24);
    }
  }
  const mergeMap2 = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a24, b6, prop) => mergeDeepProperties(headersToObject(a24), headersToObject(b6), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge4 = mergeMap2[prop] || mergeDeepProperties;
    const configValue = merge4(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge4 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config2, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel2) => {
        if (!request) {
          return;
        }
        reject(!cancel2 || cancel2.type ? new CanceledError_default(null, config2, request) : cancel2);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout2) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout2 || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer2 = timeout2 && setTimeout(() => {
      timer2 = null;
      onabort(new AxiosError_default(`timeout ${timeout2} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout2);
    const unsubscribe = () => {
      if (signals) {
        timer2 && clearTimeout(timer2);
        timer2 = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator3 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e18) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e18);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator3.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator3.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction3 } = utils_default;
var globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e18) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction3(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction3(Request);
  const isResponseSupported = isFunction3(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction3(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config2) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config2) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout: timeout2,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config2);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config2, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config2) => {
  let env = config2 && config2.env || {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i23 = len, seed, target, map2 = seedCache;
  while (i23--) {
    seed = seeds[i23];
    target = map2.get(seed);
    target === void 0 && map2.set(seed, target = i23 ? /* @__PURE__ */ new Map() : factory(env));
    map2 = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e18) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config2) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i23 = 0; i23 < length; i23++) {
    nameOrAdapter = adapters[i23];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config2)))) {
      break;
    }
    rejectedReasons[id || "#" + i23] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s25 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s25,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var adapters_default = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config2.adapter || defaults_default.adapter, config2);
  return adapter2(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.13.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i23) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i23 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i23 = keys.length;
  while (i23-- > 0) {
    const opt = keys[i23];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e18) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config2, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i23 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i23 < len) {
        promise = promise.then(chain[i23++], chain[i23++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    while (i23 < len) {
      const onFulfilled = requestInterceptorChain[i23++];
      const onRejected = requestInterceptorChain[i23++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i23 = 0;
    len = responseInterceptorChain.length;
    while (i23 < len) {
      promise = promise.then(responseInterceptorChain[i23++], responseInterceptorChain[i23++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel2) => {
      if (!token._listeners) return;
      let i23 = token._listeners.length;
      while (i23-- > 0) {
        token._listeners[i23](cancel2);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel2(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel2;
    const token = new _CancelToken(function executor(c21) {
      cancel2 = c21;
    });
    return {
      token,
      cancel: cancel2
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context2 = new Axios_default(defaultConfig);
  const instance = bind2(Axios_default.prototype.request, context2);
  utils_default.extend(instance, Axios_default.prototype, context2, { allOwnKeys: true });
  utils_default.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/model/Application.js
var r6 = ((n18) => (n18.currency = "currency", n18.plugin = "plugin", n18.tool = "tool", n18.swap = "swap", n18))(r6 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/model/Const.js
var t21 = "https://manager.api.live.ledger.com/api";
var _5 = "http://localhost:8080";
var o10 = 1;
var A9 = "0";

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/model/Errors.js
var t22 = class {
  constructor(r10) {
    __publicField(this, "_tag", "FetchError");
    __publicField(this, "originalError");
    this.error = r10;
    this.originalError = r10;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/data/ManagerApiDto.js
var r7 = ((n18) => (n18.currency = "currency", n18.plugin = "plugin", n18.tool = "tool", n18.swap = "swap", n18))(r7 || {});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/data/AxiosManagerApiDataSource.js
var d14 = Object.defineProperty;
var A10 = Object.getOwnPropertyDescriptor;
var u10 = (p30, e18, r10, i23) => {
  for (var t23 = i23 > 1 ? void 0 : i23 ? A10(e18, r10) : e18, n18 = p30.length - 1, m15; n18 >= 0; n18--) (m15 = p30[n18]) && (t23 = (i23 ? m15(e18, r10, t23) : m15(t23)) || t23);
  return i23 && t23 && d14(e18, r10, t23), t23;
};
var g18 = (p30, e18) => (r10, i23) => e18(r10, i23, p30);
var y5 = class {
  constructor({ managerApiUrl: e18, provider: r10, firmwareDistributionSalt: i23 }) {
    __publicField(this, "_managerApiBaseUrl");
    __publicField(this, "_provider", o10);
    __publicField(this, "_firmwareDistributionSalt", A9);
    this._managerApiBaseUrl = e18, this._provider = r10, this._firmwareDistributionSalt = i23;
  }
  setProvider(e18) {
    this._provider === e18 || e18 < 1 || (this._provider = e18);
  }
  getProvider() {
    return this._provider;
  }
  getAppList(e18) {
    const { targetId: r10, firmwareVersionName: i23 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/v2/apps/by-target`, { params: { target_id: r10, provider: this._provider, firmware_version_name: i23 } })).map((t23) => t23.data).chain((t23) => this.mapApplicationDtoToApplication(t23)).mapLeft((t23) => new t22(t23));
  }
  getMcuList() {
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/mcu_versions`, {})).map((e18) => e18.data).chain((e18) => this.mapMcuDtoToMcu(e18)).mapLeft((e18) => new t22(e18));
  }
  getDeviceVersion(e18) {
    const { targetId: r10 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/get_device_version`, { params: { target_id: r10, provider: this._provider } })).map((i23) => i23.data).chain((i23) => this.mapDeviceVersionDto(i23)).mapLeft((i23) => new t22(i23));
  }
  getFirmwareVersion(e18) {
    const { deviceId: r10, version: i23 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/get_firmware_version`, { params: { device_version: r10, version_name: i23, provider: this._provider } })).map((t23) => t23.data).chain((t23) => this.mapFinalFirmwareDto(t23)).mapLeft((t23) => new t22(t23));
  }
  getFirmwareVersionById(e18) {
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/firmware_final_versions/${e18}`, {})).map((r10) => r10.data).chain((r10) => this.mapFinalFirmwareDto(r10)).mapLeft((r10) => new t22(r10));
  }
  getOsuFirmwareVersion(e18) {
    const { deviceId: r10, version: i23 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/get_osu_version`, { params: { device_version: r10, version_name: i23, provider: this._provider } })).map((t23) => t23.data).chain((t23) => this.mapOsuFirmwareDto(t23)).mapLeft((t23) => new t22(t23));
  }
  getLatestFirmwareVersion(e18) {
    const r10 = "34.27.0", { currentFinalFirmwareId: i23, deviceId: t23 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/get_latest_firmware`, { params: { current_se_firmware_final_version: i23, device_version: t23, provider: this._provider, salt: this._firmwareDistributionSalt, livecommonversion: r10 } })).map((n18) => n18.data).chain((n18) => this.mapLatestFirmwareDto(n18)).mapLeft((n18) => new t22(n18));
  }
  getAppsByHash(e18) {
    const { hashes: r10 } = e18;
    return EitherAsync(() => axios_default.post(`${this._managerApiBaseUrl}/v2/apps/hash`, r10)).map((i23) => i23.data).chain((i23) => this.mapNullableApplicationDtoToApplication(i23)).mapLeft((i23) => new t22(i23));
  }
  getLanguagePackages(e18) {
    const { deviceId: r10, currentFinalFirmwareId: i23 } = e18;
    return EitherAsync(() => axios_default.get(`${this._managerApiBaseUrl}/language-packages`, { params: { device_version: r10, current_se_firmware_final_version: i23 } })).map((t23) => t23.data).chain((t23) => this.mapLanguagesDtoToLanguages(t23)).mapLeft((t23) => new t22(t23));
  }
  mapAppTypeDtoToAppType(e18) {
    if (e18 === null) return null;
    switch (e18) {
      case r7.currency:
        return r6.currency;
      case r7.plugin:
        return r6.plugin;
      case r7.tool:
        return r6.tool;
      case r7.swap:
        return r6.swap;
    }
  }
  mapApplicationDtoToApplication(e18) {
    return EitherAsync(() => Promise.resolve(e18.map((r10) => this.mapApplicationDto(r10))));
  }
  mapNullableApplicationDtoToApplication(e18) {
    return EitherAsync(() => Promise.resolve(e18.map((r10) => r10 === null ? null : this.mapApplicationDto(r10))));
  }
  mapApplicationDto(e18) {
    if (typeof e18 != "object" || typeof e18.versionId != "number" || typeof e18.versionName != "string" || e18.versionDisplayName !== null && typeof e18.versionDisplayName != "string" || typeof e18.version != "string" || e18.currencyId !== null && typeof e18.currencyId != "string" || e18.description !== null && typeof e18.description != "string" || e18.applicationType !== null && typeof e18.applicationType != "string" || typeof e18.dateModified != "string" || e18.icon !== null && typeof e18.icon != "string" || e18.authorName !== null && typeof e18.authorName != "string" || e18.supportURL !== null && typeof e18.supportURL != "string" || e18.contactURL !== null && typeof e18.contactURL != "string" || e18.sourceURL !== null && typeof e18.sourceURL != "string" || e18.compatibleWallets !== null && typeof e18.compatibleWallets != "string" || typeof e18.hash != "string" || typeof e18.perso != "string" || typeof e18.firmware != "string" || typeof e18.firmwareKey != "string" || typeof e18.delete != "string" || typeof e18.deleteKey != "string" || e18.bytes !== null && typeof e18.bytes != "number" || e18.warning !== null && typeof e18.warning != "string" || typeof e18.isDevTools != "boolean" || e18.category !== null && typeof e18.category != "number" || e18.parent !== null && typeof e18.parent != "number" || e18.parentName !== null && typeof e18.parentName != "string") throw new Error(`Incomplete application: ${JSON.stringify(e18)}`);
    const { applicationType: r10, hash: i23, perso: t23, firmware: n18, firmwareKey: m15, delete: f9, deleteKey: h5, ...v22 } = e18;
    return { ...v22, hash: i23, perso: t23, firmware: n18, firmwareKey: m15, delete: f9, deleteKey: h5, applicationType: this.mapAppTypeDtoToAppType(r10) };
  }
  mapMcuDtoToMcu(e18) {
    return EitherAsync(() => Promise.resolve(e18.map((r10) => {
      if (typeof r10 != "object" || typeof r10.id != "number" || typeof r10.name != "string") throw new Error(`Incomplete MCU version: ${JSON.stringify(r10)}`);
      return { id: r10.id, name: r10.name };
    })));
  }
  mapDeviceVersionDto(e18) {
    return EitherAsync(() => {
      if (typeof e18 != "object" || typeof e18.id != "number") throw new Error(`Incomplete device version: ${JSON.stringify(e18)}`);
      const r10 = { id: e18.id };
      return Promise.resolve(r10);
    });
  }
  mapFinalFirmwareDto(e18) {
    return EitherAsync(() => {
      if (typeof e18 != "object" || typeof e18.id != "number" || typeof e18.version != "string" || typeof e18.perso != "string" || e18.firmware !== null && typeof e18.firmware != "string" || e18.firmware_key !== null && typeof e18.firmware_key != "string" || e18.hash !== null && typeof e18.hash != "string" || e18.bytes !== null && typeof e18.bytes != "number" || !Array.isArray(e18.mcu_versions)) throw new Error(`Incomplete final firmware: ${JSON.stringify(e18)}`);
      const r10 = { id: e18.id, version: e18.version, perso: e18.perso, firmware: e18.firmware, firmwareKey: e18.firmware_key, hash: e18.hash, bytes: e18.bytes, mcuVersions: e18.mcu_versions };
      return Promise.resolve(r10);
    });
  }
  mapLatestFirmwareDto(e18) {
    return EitherAsync(() => {
      if (e18.result !== "success" || !e18.se_firmware_osu_version) throw new Error(`Latest firmware could not be retrieved: ${e18.result}`);
      const r10 = e18.se_firmware_osu_version;
      return Promise.resolve(r10);
    }).chain((r10) => this.mapOsuFirmwareDto(r10));
  }
  mapOsuFirmwareDto(e18) {
    return EitherAsync(() => {
      if (typeof e18 != "object" || typeof e18.id != "number" || typeof e18.perso != "string" || typeof e18.firmware != "string" || typeof e18.firmware_key != "string" || e18.hash !== null && typeof e18.hash != "string" || typeof e18.next_se_firmware_final_version != "number") throw new Error(`Incomplete latest firmware: ${JSON.stringify(e18)}`);
      const r10 = { id: e18.id, perso: e18.perso, firmware: e18.firmware, firmwareKey: e18.firmware_key, hash: e18.hash, nextFinalFirmware: e18.next_se_firmware_final_version };
      return Promise.resolve(r10);
    });
  }
  mapLanguagesDtoToLanguages(e18) {
    return EitherAsync(() => Promise.resolve(e18.map((r10) => this.mapLanguageDto(r10))));
  }
  mapLanguageDto(e18) {
    if (typeof e18 != "object" || typeof e18.language != "string" || typeof e18.languagePackageVersionId != "number" || typeof e18.version != "string" || typeof e18.language_package_id != "number" || typeof e18.apdu_install_url != "string" || typeof e18.apdu_uninstall_url != "string" || typeof e18.bytes != "number" || typeof e18.date_creation != "string" || typeof e18.date_last_modified != "string") throw new Error(`Incomplete language version: ${JSON.stringify(e18)}`);
    return { language: e18.language, languagePackageVersionId: e18.languagePackageVersionId, version: e18.version, languagePackageId: e18.language_package_id, apduInstallUrl: e18.apdu_install_url, apduUninstallUrl: e18.apdu_uninstall_url, bytes: e18.bytes, dateCreation: e18.date_creation, dateLastModified: e18.date_last_modified };
  }
};
y5 = u10([z2(), g18(0, N(e10.DmkConfig))], y5);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/service/DefaultManagerApiService.js
var g19 = Object.defineProperty;
var u11 = Object.getOwnPropertyDescriptor;
var p26 = (s25, e18, r10, t23) => {
  for (var a24 = t23 > 1 ? void 0 : t23 ? u11(e18, r10) : e18, i23 = s25.length - 1, o12; i23 >= 0; i23--) (o12 = s25[i23]) && (a24 = (t23 ? o12(e18, r10, a24) : o12(a24)) || a24);
  return t23 && a24 && g19(e18, r10, a24), a24;
};
var m10 = (s25, e18) => (r10, t23) => e18(r10, t23, s25);
var n15 = class {
  constructor(e18) {
    this.dataSource = e18;
  }
  getAppList(e18) {
    const r10 = { targetId: e18.targetId.toString(), firmwareVersionName: e18.seVersion };
    return this.dataSource.getAppList(r10);
  }
  getDeviceVersion(e18) {
    const r10 = { targetId: e18.targetId.toString() };
    return this.dataSource.getDeviceVersion(r10);
  }
  getFirmwareVersion(e18, r10) {
    const t23 = { version: e18.seVersion, deviceId: r10.id };
    return this.dataSource.getFirmwareVersion(t23);
  }
  getOsuFirmwareVersion(e18, r10) {
    const t23 = { version: e18.seVersion, deviceId: r10.id };
    return this.dataSource.getOsuFirmwareVersion(t23);
  }
  getLatestFirmwareVersion(e18, r10) {
    const t23 = { currentFinalFirmwareId: e18.id, deviceId: r10.id };
    return this.dataSource.getLatestFirmwareVersion(t23);
  }
  getNextFirmwareVersion(e18) {
    return this.dataSource.getFirmwareVersionById(e18.nextFinalFirmware);
  }
  getLanguagePackages(e18, r10) {
    const t23 = { deviceId: e18.id, currentFinalFirmwareId: r10.id };
    return this.dataSource.getLanguagePackages(t23);
  }
  getMcuList() {
    return this.dataSource.getMcuList();
  }
  getAppsByHash(e18) {
    const r10 = { hashes: e18 };
    return EitherAsync(async ({ fromPromise: t23, throwE: a24 }) => {
      if (r10.hashes.length === 0) return [];
      try {
        return await t23(this.dataSource.getAppsByHash(r10));
      } catch (i23) {
        return i23 instanceof t22 ? a24(i23) : a24(new t22(i23));
      }
    });
  }
};
n15 = p26([z2(), m10(0, N(e10.ManagerApiDataSource))], n15);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/use-case/SetProviderUseCase.js
var m11 = Object.defineProperty;
var v20 = Object.getOwnPropertyDescriptor;
var p27 = (o12, e18, i23, s25) => {
  for (var t23 = s25 > 1 ? void 0 : s25 ? v20(e18, i23) : e18, a24 = o12.length - 1, r10; a24 >= 0; a24--) (r10 = o12[a24]) && (t23 = (s25 ? r10(e18, i23, t23) : r10(t23)) || t23);
  return s25 && t23 && m11(e18, i23, t23), t23;
};
var c17 = (o12, e18) => (i23, s25) => e18(i23, s25, o12);
var n16 = class {
  constructor(e18, i23) {
    this.sessionService = e18;
    this.managerApiDataSource = i23;
  }
  execute(e18) {
    for (const i23 of this.sessionService.getDeviceSessions()) {
      const s25 = i23.getDeviceSessionState();
      s25.sessionStateType !== a6.Connected && i23.setDeviceSessionState({ ...s25, firmwareUpdateContext: void 0, installedApps: [], appsUpdates: void 0, catalog: void 0 });
    }
    this.managerApiDataSource.setProvider(e18);
  }
};
n16 = p27([z2(), c17(0, N(e8.DeviceSessionService)), c17(1, N(e10.ManagerApiDataSource))], n16);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/manager-api/di/managerApiModule.js
var C4 = ({ stub: a24, config: i23 }) => new w6(({ bind: e18, rebindSync: r10 }) => {
  e18(e10.DmkConfig).toConstantValue(i23), e18(e10.ManagerApiDataSource).to(y5).inSingletonScope(), e18(e10.ManagerApiService).to(n15).inSingletonScope(), e18(e10.SetProviderUseCase).to(n16), a24 && (r10(e10.ManagerApiDataSource).to(r5), r10(e10.ManagerApiService).to(r5), r10(e10.SetProviderUseCase).to(r5));
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/data/DefaultSecureChannelDataSource.js
var import_url = __toESM(require_url());
var k5 = Object.defineProperty;
var l16 = Object.getOwnPropertyDescriptor;
var m12 = (s25, e18, t23, o12) => {
  for (var r10 = o12 > 1 ? void 0 : o12 ? l16(e18, t23) : e18, c21 = s25.length - 1, i23; c21 >= 0; c21--) (i23 = s25[c21]) && (r10 = (o12 ? i23(e18, t23, r10) : i23(r10)) || r10);
  return o12 && r10 && k5(e18, t23, r10), r10;
};
var p28 = (s25, e18) => (t23, o12) => e18(t23, o12, s25);
var a22 = class {
  constructor({ webSocketUrl: e18 }) {
    __publicField(this, "webSocketBaseUrl");
    this.webSocketBaseUrl = e18;
  }
  genuineCheck(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/genuine`, query: e18 });
    return this._connectWebSocket(t23);
  }
  installApp(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e18 });
    return this._connectWebSocket(t23);
  }
  listInstalledApps(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/apps/list`, query: e18 });
    return this._connectWebSocket(t23);
  }
  uninstallApp(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e18 });
    return this._connectWebSocket(t23);
  }
  updateFirmware(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/install`, query: e18 });
    return this._connectWebSocket(t23);
  }
  updateMcu(e18) {
    const t23 = import_url.default.format({ pathname: `${this.webSocketBaseUrl}/mcu`, query: e18 });
    return this._connectWebSocket(t23);
  }
  _connectWebSocket(e18) {
    try {
      return right(new browser_default(e18));
    } catch (t23) {
      return left(new i11(t23));
    }
  }
};
a22 = m12([z2(), p28(0, N(e15.DmkConfig))], a22);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/service/DefaultSecureChannelService.js
var l17 = Object.defineProperty;
var d15 = Object.getOwnPropertyDescriptor;
var c18 = (n18, e18, r10, t23) => {
  for (var a24 = t23 > 1 ? void 0 : t23 ? d15(e18, r10) : e18, o12 = n18.length - 1, s25; o12 >= 0; o12--) (s25 = n18[o12]) && (a24 = (t23 ? s25(e18, r10, a24) : s25(a24)) || a24);
  return t23 && a24 && l17(e18, r10, a24), a24;
};
var m13 = (n18, e18) => (r10, t23) => e18(r10, t23, n18);
var i19 = class {
  constructor(e18) {
    this.dataSource = e18;
  }
  genuineCheck(e18, r10) {
    const t23 = { targetId: e18.targetId.toString(), perso: r10.perso };
    return this.dataSource.genuineCheck(t23);
  }
  installApp(e18, r10) {
    const { perso: t23, firmware: a24, firmwareKey: o12, hash: s25 } = r10, p30 = { targetId: e18.targetId.toString(), perso: t23, firmware: a24, firmwareKey: o12, hash: s25 };
    return this.dataSource.installApp(p30);
  }
  listInstalledApps(e18, r10) {
    const t23 = { targetId: e18.targetId.toString(), perso: r10.perso };
    return this.dataSource.listInstalledApps(t23);
  }
  uninstallApp(e18, r10) {
    const { perso: t23, delete: a24, deleteKey: o12, hash: s25 } = r10, p30 = { targetId: e18.targetId.toString(), perso: t23, firmware: a24, firmwareKey: o12, hash: s25 };
    return this.dataSource.uninstallApp(p30);
  }
  updateFirmware(e18, r10) {
    const t23 = { targetId: e18.targetId.toString(), perso: r10.perso, firmware: r10.firmware, firmwareKey: r10.firmwareKey };
    return this.dataSource.updateFirmware(t23);
  }
  updateMcu(e18, r10) {
    const t23 = { targetId: e18.targetId.toString(), version: r10.version };
    return this.dataSource.updateMcu(t23);
  }
};
i19 = c18([z2(), m13(0, N(e15.SecureChannelDataSource))], i19);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/di/secureChannelModule.js
var i20 = ({ stub: r10, config: t23 }) => new w6(({ bind: e18 }) => {
  e18(e15.DmkConfig).toConstantValue(t23), e18(e15.SecureChannelDataSource).to(a22), e18(e15.SecureChannelService).to(i19);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/secure-channel/model/Const.js
var e17 = "wss://scriptrunner.api.live.ledger.com/update";

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/send/use-case/SendApduUseCase.js
var a23 = Object.defineProperty;
var d16 = Object.getOwnPropertyDescriptor;
var S12 = (t23, e18, r10, s25) => {
  for (var i23 = s25 > 1 ? void 0 : s25 ? d16(e18, r10) : e18, n18 = t23.length - 1, o12; n18 >= 0; n18--) (o12 = t23[n18]) && (i23 = (s25 ? o12(e18, r10, i23) : o12(i23)) || i23);
  return s25 && i23 && a23(e18, r10, i23), i23;
};
var v21 = (t23, e18) => (r10, s25) => e18(r10, s25, t23);
var g20 = class {
  constructor(e18, r10) {
    __publicField(this, "_sessionService");
    __publicField(this, "_logger");
    this._sessionService = e18, this._logger = r10("SendApduUseCase");
  }
  async execute({ sessionId: e18, apdu: r10, abortTimeout: s25, triggersDisconnection: i23 }) {
    return this._sessionService.getDeviceSessionById(e18).caseOf({ Right: async (o12) => (await o12.sendApdu(r10, { abortTimeout: s25, triggersDisconnection: i23 })).caseOf({ Right: (c21) => c21, Left: (c21) => {
      throw this._logger.error("Error sending APDU", { data: { sessionId: e18, apdu: r10, error: c21 } }), c21;
    } }), Left: (o12) => {
      throw this._logger.error("Error getting deviceSession", { data: { error: o12 } }), o12;
    } });
  }
};
g20 = S12([z2(), v21(0, N(e8.DeviceSessionService)), v21(1, N(e6.LoggerPublisherServiceFactory))], g20);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/send/di/sendModule.js
var f7 = ({ stub: o12 = false }) => new w6(({ bind: s25, rebindSync: r10 }) => {
  s25(e11.SendApduUseCase).to(g20), o12 && r10(e11.SendApduUseCase).to(r5);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/transport/service/DefaultTransportService.js
var m14 = Object.defineProperty;
var u12 = Object.getOwnPropertyDescriptor;
var g21 = (n18, r10, e18, t23) => {
  for (var o12 = t23 > 1 ? void 0 : t23 ? u12(r10, e18) : r10, s25 = n18.length - 1, p30; s25 >= 0; s25--) (p30 = n18[s25]) && (o12 = (t23 ? p30(r10, e18, o12) : p30(o12)) || o12);
  return t23 && o12 && m14(r10, e18, o12), o12;
};
var i21 = (n18, r10) => (e18, t23) => r10(e18, t23, n18);
var c19 = class {
  constructor(r10, e18, t23, o12, s25, p30) {
    __publicField(this, "_transports", /* @__PURE__ */ new Map());
    __publicField(this, "_logger");
    this._config = e18;
    this._loggerModuleFactory = t23;
    this._deviceModelDataSource = o12;
    this._apduSenderServiceFactory = s25;
    this._apduReceiverServiceFactory = p30;
    if (this._logger = t23("TransportService"), r10.length === 0) throw this._logger.warn("No transports provided, please check your configuration"), new A3("No transports provided, please check your configuration");
    for (const l19 of r10) {
      const d18 = this.addTransport(l19);
      if (d18.isLeft()) throw d18.extract();
    }
  }
  addTransport(r10) {
    const e18 = r10({ deviceModelDataSource: this._deviceModelDataSource, loggerServiceFactory: this._loggerModuleFactory, config: this._config, apduSenderServiceFactory: this._apduSenderServiceFactory, apduReceiverServiceFactory: this._apduReceiverServiceFactory });
    return this.addTransportInternal(e18);
  }
  addTransportInternal(r10) {
    return this.getTransport(r10.getIdentifier()).isJust() ? (this._logger.warn(`Transport ${r10.getIdentifier()} already exists, please check your configuration`), left(new g3(`Transport ${r10.getIdentifier()} already exists, please check your configuration`))) : (this._transports.set(r10.getIdentifier(), r10), right(void 0));
  }
  getTransport(r10) {
    return Maybe.fromNullable(this._transports.get(r10));
  }
  getAllTransports() {
    return Array.from(this._transports.values());
  }
  closeConnection(r10) {
    this.getTransport(r10.transport).map((t23) => t23.disconnect({ connectedDevice: r10 }));
  }
};
c19 = g21([z2(), i21(0, N(r4.TransportsInput)), i21(1, N(r4.DmkConfig)), i21(2, N(e6.LoggerPublisherServiceFactory)), i21(3, N(e14.DeviceModelDataSource)), i21(4, N(e8.ApduSenderServiceFactory)), i21(5, N(e8.ApduReceiverServiceFactory))], c19);

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/internal/transport/di/transportModule.js
var f8 = ({ stub: r10 = false, transports: a24 = [], config: n18 } = {}) => new w6(({ bind: o12 }) => {
  o12(r4.TransportsInput).toConstantValue(a24), o12(r4.TransportService).to(c19).inSingletonScope(), o12(r4.DmkConfig).toConstantValue(n18);
});

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/di.js
var x6 = ({ stub: o12 = false, transports: t23 = [], loggers: i23 = [], config: r10 = { mockUrl: _5, managerApiUrl: t21, webSocketUrl: e17, provider: o10, firmwareDistributionSalt: A9 } }) => {
  const e18 = new L2();
  return e18.loadSync(y4({ stub: o12 }), p15({ stub: o12 }), f8({ stub: o12, transports: t23, config: r10 }), C4({ stub: o12, config: r10 }), i20({ stub: o12, config: r10 }), w7({ stub: o12 }), u9({ subscribers: i23 }), b4({ stub: o12 }), f7({ stub: o12 }), i15({ stub: o12 }), l9({ stub: o12 })), e18;
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/DeviceManagementKit.js
var x7 = class {
  constructor({ stub: e18, transports: i23, loggers: o12, config: n18 } = {}) {
    __publicField(this, "container");
    this.container = x6({ stub: e18, transports: i23, loggers: o12, config: n18 });
  }
  getVersion() {
    return this.container.get(o8.GetDmkVersionUseCase).getDmkVersion();
  }
  startDiscovering(e18) {
    return this.container.get(e9.StartDiscoveringUseCase).execute(e18);
  }
  stopDiscovering() {
    return this.container.get(e9.StopDiscoveringUseCase).execute();
  }
  listenToAvailableDevices(e18) {
    return this.container.get(e9.ListenToAvailableDevicesUseCase).execute(e18);
  }
  async reconnect(e18) {
    return this.container.get(e9.ReconnectUseCase).execute(e18);
  }
  connect(e18) {
    return this.container.get(e9.ConnectUseCase).execute(e18);
  }
  disconnect(e18) {
    return this.container.get(e9.DisconnectUseCase).execute(e18);
  }
  sendApdu(e18) {
    return this.container.get(e11.SendApduUseCase).execute(e18);
  }
  sendCommand(e18) {
    return this.container.get(e7.SendCommandUseCase).execute(e18);
  }
  executeDeviceAction(e18) {
    return this.container.get(e12.ExecuteDeviceActionUseCase).execute(e18);
  }
  getConnectedDevice(e18) {
    return this.container.get(e9.GetConnectedDeviceUseCase).execute(e18);
  }
  getDeviceSessionState(e18) {
    return this.container.get(e8.GetDeviceSessionStateUseCase).execute(e18);
  }
  close() {
    return this.container.get(e8.CloseSessionsUseCase).execute();
  }
  listConnectedDevices() {
    return this.container.get(e9.ListConnectedDevicesUseCase).execute();
  }
  listenToConnectedDevice() {
    return this.container.get(e9.ListenToConnectedDeviceUseCase).execute();
  }
  disableDeviceSessionRefresher(e18) {
    return this.container.get(e8.DisableDeviceSessionRefresherUseCase).execute(e18);
  }
  setProvider(e18) {
    return this.container.get(e10.SetProviderUseCase).execute(e18);
  }
  getProvider() {
    return this.container.get(e10.ManagerApiDataSource).getProvider();
  }
  isEnvironmentSupported() {
    return this.container.get(r4.TransportService).getAllTransports().some((e18) => e18.isSupported());
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/DeviceManagementKitBuilder.js
var c20 = class {
  constructor() {
    __publicField(this, "stub", false);
    __publicField(this, "loggers", []);
    __publicField(this, "transports", []);
    __publicField(this, "config", { managerApiUrl: t21, mockUrl: _5, webSocketUrl: e17, provider: o10, firmwareDistributionSalt: A9 });
  }
  build() {
    return new x7({ stub: this.stub, transports: this.transports, loggers: this.loggers, config: this.config });
  }
  setStub(r10) {
    return this.stub = r10, this;
  }
  addTransport(r10) {
    return this.transports.push(r10), this;
  }
  addLogger(r10) {
    return this.loggers.push(r10), this;
  }
  addConfig(r10) {
    return this.config = { ...this.config, ...r10 }, this;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/logger-subscriber/service/ConsoleLogger.js
var g22 = class {
  constructor(t23 = n14.Debug) {
    __publicField(this, "maxLevel");
    this.maxLevel = t23;
  }
  log(t23, a24, r10) {
    const i23 = `[${r10.tag}]`;
    switch (t23) {
      case n14.Info: {
        this.maxLevel >= n14.Info && this.logWithData(i23, console.info, a24, r10);
        break;
      }
      case n14.Warning: {
        this.maxLevel >= n14.Warning && this.logWithData(i23, console.warn, a24, r10);
        break;
      }
      case n14.Debug: {
        this.maxLevel >= n14.Debug && this.logWithData(i23, console.debug, a24, r10);
        break;
      }
      case n14.Error: {
        this.maxLevel >= n14.Error && this.logWithData(i23, console.error, a24, r10);
        break;
      }
      case n14.Fatal: {
        this.maxLevel >= n14.Fatal && this.logWithData(i23, console.error, a24, r10);
        break;
      }
      default:
        this.logWithData(i23, console.log, a24, r10);
    }
  }
  logWithData(t23, a24, r10, i23) {
    i23.data ? a24(t23, r10, i23.data) : a24(t23, r10);
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/logger-subscriber/service/WebLogsExporterLogger.js
function p29() {
  const n18 = [];
  return function(r10, e18) {
    if (e18 instanceof Uint8Array) {
      const t23 = Array.from(e18).map((o12) => o12.toString(16).padStart(2, "0"));
      return { hex: "0x" + t23.join(""), readableHex: t23.join(" "), value: e18.toString() };
    }
    if (e18 instanceof L3) {
      const { connectedDevice: { deviceModel: t23, type: o12, id: i23 } } = e18;
      return { id: e18.id, connectedDevice: { deviceModel: t23, type: o12, id: i23 } };
    }
    if (typeof e18 != "object" || e18 === null) return e18;
    for (; n18.length > 0 && n18.at(-1) !== this; ) n18.pop();
    return n18.includes(e18) ? "[Circular]" : (n18.push(e18), e18);
  };
}
var l18 = class {
  constructor() {
    __publicField(this, "logs", []);
  }
  log(r10, e18, t23) {
    this.logs.push([r10, e18, t23]);
  }
  formatLogsToJSON() {
    const r10 = this.logs.map(([e18, t23, o12]) => {
      const { timestamp: i23, ...s25 } = o12;
      return { level: n14[e18], message: t23, options: { ...s25, date: new Date(o12.timestamp) } };
    });
    return JSON.stringify(r10, p29(), 2);
  }
  exportLogsToJSON() {
    const r10 = this.formatLogsToJSON(), e18 = new Blob([r10], { type: "application/json" }), t23 = URL.createObjectURL(e18), o12 = document.createElement("a");
    o12.href = t23, o12.download = `ledger-device-management-kit-logs-${(/* @__PURE__ */ new Date()).toISOString()}.json`, o12.click();
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/transport/model/DeviceConnectionStateMachine.js
var W3 = class {
  constructor(n18) {
    __publicField(this, "deviceId");
    __publicField(this, "deviceAdpuSender");
    __publicField(this, "machineActor");
    __publicField(this, "timeoutDuration");
    __publicField(this, "timeout", null);
    this.deviceId = n18.deviceId, this.deviceAdpuSender = n18.deviceApduSender, this.timeoutDuration = n18.timeoutDuration, this.machineActor = createActor(b5({ sendApduFn: (r10, s25, t23) => this.sendApduToDeviceConnection(r10, s25, t23), startReconnectionTimeout: () => this.startReconnectionTimeout(), cancelReconnectionTimeout: () => {
      this.timeout && (clearTimeout(this.timeout), this.timeout = null);
    }, tryToReconnect: () => {
      n18.tryToReconnect(this.timeoutDuration);
    }, onTerminated: n18.onTerminated, closeConnection: () => {
      this.deviceAdpuSender.closeConnection();
    } })), this.machineActor.start();
  }
  startReconnectionTimeout() {
    this.timeout = setTimeout(() => {
      this.machineActor.send({ type: "ReconnectionTimedOut" });
    }, this.timeoutDuration);
  }
  sendApduToDeviceConnection(n18, r10, s25) {
    this.deviceAdpuSender.sendApdu(n18, r10, s25).then((t23) => {
      t23.caseOf({ Left: (c21) => {
        this.machineActor.send({ type: "ApduSendingError", error: c21 });
      }, Right: (c21) => {
        this.machineActor.send({ type: "ApduResponseReceived", apduResponse: c21 });
      } });
    }).catch((t23) => {
      this.machineActor.send({ type: "ApduSendingError", error: new a3(t23) });
    });
  }
  getDependencies() {
    return this.deviceAdpuSender.getDependencies();
  }
  setDependencies(n18) {
    this.deviceAdpuSender.setDependencies(n18);
  }
  getDeviceId() {
    return this.deviceId;
  }
  sendApdu(n18, r10, s25) {
    return new Promise((t23) => {
      this.machineActor.send({ type: "SendApduCalled", apdu: n18, triggersDisconnection: !!r10, abortTimeout: s25, responseCallback: t23 });
    });
  }
  async setupConnection() {
    await this.deviceAdpuSender.setupConnection();
  }
  eventDeviceConnected() {
    this.machineActor.send({ type: "DeviceConnected" });
  }
  eventDeviceDisconnected() {
    this.machineActor.send({ type: "DeviceDisconnected" });
  }
  closeConnection() {
    this.machineActor.send({ type: "CloseConnectionCalled" });
  }
};
function b5({ sendApduFn: u14, startReconnectionTimeout: n18, cancelReconnectionTimeout: r10, tryToReconnect: s25, onTerminated: t23, closeConnection: c21 }) {
  return setup({ types: {}, actions: { startTimer: () => {
    n18();
  }, cancelTimer: () => {
    r10();
  }, reconnectionTimeoutEvent: emit({ type: "ReconnectionTimedOut" }), sendApdu: ({ context: e18 }) => {
    e18.apduInProgress.map(({ apdu: i23, abortTimeout: d18 }) => {
      u14(i23, false, d18);
    });
  }, sendApduResponse: ({ context: e18 }, i23) => {
    e18.apduInProgress.map(({ responseCallback: d18 }) => d18(i23.response));
  }, sendGetAppAndVersion: () => {
    u14(new R().getApdu().getRawApdu(), false);
  }, tryToReconnect: () => {
    s25();
  }, clearApduInProgress: assign({ apduInProgress: nothing }), clearApduResponse: assign({ apduResponse: nothing }), signalTermination: () => {
    t23();
  }, closeConnection: () => {
    c21();
  } }, guards: { isApduThatTriggersDisconnection: ({ context: e18, event: i23 }) => i23.type !== "ApduResponseReceived" ? false : e18.apduInProgress.caseOf({ Just: ({ triggersDisconnection: d18, apdu: R6 }) => (d18 || e2.isApduThatTriggersDisconnection(R6)) && e2.isSuccessResponse(i23.apduResponse), Nothing: () => false }), isSendApduBusyError: ({ event: e18 }) => e18.type !== "ApduResponseReceived" ? false : e18.apduResponse.statusCode[0] === 102 && e18.apduResponse.statusCode[1] === 1 } }).createMachine({ id: "deviceConnection", initial: "Connected", context: { apduInProgress: nothing, apduResponse: nothing }, states: { Connected: { on: { DeviceDisconnected: { target: "WaitingForReconnection" }, SendApduCalled: { target: "SendingApdu", actions: assign({ apduInProgress: ({ event: e18 }) => Maybe.of({ apdu: e18.apdu, triggersDisconnection: e18.triggersDisconnection, abortTimeout: e18.abortTimeout, responseCallback: e18.responseCallback }) }) }, CloseConnectionCalled: { target: "Terminated" } } }, SendingApdu: { entry: "sendApdu", on: { ApduResponseReceived: [{ guard: "isApduThatTriggersDisconnection", target: "WaitingForDisconnection", actions: [assign({ apduResponse: ({ event: e18 }) => Maybe.of(e18.apduResponse) })] }, { target: "Connected", actions: [{ type: "sendApduResponse", params: ({ event: e18 }) => ({ response: right(e18.apduResponse) }) }, { type: "clearApduInProgress" }] }], ApduSendingError: { target: "Connected", actions: [{ type: "sendApduResponse", params: ({ event: e18 }) => ({ response: left(e18.error) }) }, "clearApduInProgress"] }, DeviceDisconnected: { target: "WaitingForReconnection", actions: [{ type: "sendApduResponse", params: { response: left(new k2()) } }, "clearApduInProgress"] }, CloseConnectionCalled: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: left(new k2()) } }, "clearApduInProgress"] }, SendApduCalled: { actions: ({ event: e18 }) => {
    e18.responseCallback(left(new D()));
  } } } }, WaitingForDisconnection: { entry: ["sendGetAppAndVersion"], exit: [{ type: "sendApduResponse", params: ({ context: e18 }) => ({ response: e18.apduResponse.caseOf({ Just: (i23) => right(i23), Nothing: () => left(new a3()) }) }) }, { type: "clearApduInProgress" }, { type: "clearApduResponse" }], on: { ApduResponseReceived: [{ guard: "isSendApduBusyError", actions: ["sendGetAppAndVersion"], target: "WaitingForDisconnection" }, { target: "Connected" }], ApduSendingError: [{ target: "WaitingForReconnection" }], SendApduCalled: { actions: ({ event: e18 }) => {
    e18.responseCallback(left(new D()));
  } }, DeviceDisconnected: { target: "WaitingForReconnection" }, CloseConnectionCalled: { target: "Terminated" } } }, WaitingForReconnection: { entry: ["startTimer", "tryToReconnect"], on: { DeviceConnected: { target: "Connected", actions: "cancelTimer" }, SendApduCalled: { target: "WaitingForReconnectionWithQueuedSendApdu", actions: assign({ apduInProgress: ({ event: e18 }) => Maybe.of({ apdu: e18.apdu, triggersDisconnection: e18.triggersDisconnection, abortTimeout: e18.abortTimeout, responseCallback: e18.responseCallback }) }) }, ReconnectionTimedOut: { target: "Terminated" }, CloseConnectionCalled: { target: "Terminated" } } }, WaitingForReconnectionWithQueuedSendApdu: { on: { DeviceConnected: { target: "SendingApdu", actions: "cancelTimer" }, ReconnectionTimedOut: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: left(new w()) } }, { type: "clearApduInProgress" }] }, CloseConnectionCalled: { target: "Terminated", actions: [{ type: "sendApduResponse", params: { response: left(new k2()) } }, "clearApduInProgress"] }, SendApduCalled: { actions: ({ event: e18 }) => {
    e18.responseCallback(left(new D()));
  } } } }, Terminated: { entry: ["signalTermination", "closeConnection"], type: "final" } } });
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/transport/model/TransportConnectedDevice.js
var d17 = class {
  constructor({ id: e18, deviceModel: t23, type: n18, transport: r10, sendApdu: o12, name: p30 }) {
    __publicField(this, "id");
    __publicField(this, "deviceModel");
    __publicField(this, "sendApdu");
    __publicField(this, "type");
    __publicField(this, "transport");
    __publicField(this, "name");
    this.id = e18, this.deviceModel = t23, this.sendApdu = o12, this.type = n18, this.transport = r10, this.name = p30;
  }
};

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-model/model/DeviceModel.stub.js
function r8(e18 = {}) {
  return { id: t2.NANO_X, productName: "Ledger Nano X", usbProductId: 64, bootloaderUsbProductId: 4, usbOnly: false, memorySize: 2 * 1024 * 1024, getBlockSize: () => 4 * 1024, masks: [855638016], bluetoothSpec: [{ serviceUuid: "13d63400-2c97-0004-0000-4c6564676572", notifyUuid: "13d63400-2c97-0004-0001-4c6564676572", writeUuid: "13d63400-2c97-0004-0002-4c6564676572", writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572" }], ...e18 };
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/device-session/ApduResponse.stub.js
var r9 = ({ statusCode: e18 = Uint8Array.from([144, 0]), data: p30 = Uint8Array.from([]) } = {}) => new a11({ statusCode: e18, data: p30 });

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/transport/model/TransportConnectedDevice.stub.js
function u13(e18 = {}) {
  const r10 = r8();
  return new d17({ deviceModel: r10, id: "42", type: "MOCK", transport: "USB", sendApdu: vi.fn(async () => Promise.resolve(right(r9()))), ...e18 });
}

// node_modules/@ledgerhq/device-management-kit/lib/esm/src/api/utils/Base64String.js
function o11(r10) {
  return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(r10);
}
function i22(r10) {
  if (r10.length === 0) return new Uint8Array();
  if (!o11(r10)) return null;
  try {
    const n18 = atob(r10), e18 = new Uint8Array(n18.length);
    for (let t23 = 0; t23 < n18.length; t23++) e18[t23] = n18.charCodeAt(t23);
    return e18;
  } catch {
    return Uint8Array.from(Buffer.from(r10, "base64"));
  }
}

export {
  __publicField,
  s,
  e,
  f,
  o,
  l,
  s2,
  i,
  g,
  r,
  A,
  s3,
  i2,
  a,
  s4,
  a2,
  o2,
  s5,
  e2,
  s6,
  a3,
  c,
  o3,
  d,
  p,
  i4 as i3,
  R,
  A2,
  c2,
  t2 as t,
  i6 as i4,
  l3 as l2,
  P,
  S,
  k,
  f2,
  E,
  t3 as t2,
  s8 as s7,
  Maybe,
  nothing,
  left,
  right,
  EitherAsync,
  e3,
  t4 as t3,
  i7 as i5,
  a5 as a4,
  l4 as l3,
  s9 as s8,
  BehaviorSubject,
  from,
  map,
  switchMap,
  E3 as E2,
  a6 as a5,
  z,
  n4 as n,
  t5 as t4,
  s10 as s9,
  d2,
  c3,
  a7 as a6,
  i8 as i6,
  l5 as l4,
  u3 as u,
  p3 as p2,
  E4 as E3,
  y,
  x2 as x,
  v,
  g3 as g2,
  k2,
  D,
  w,
  A3,
  W,
  R2,
  L,
  I,
  E6 as E4,
  Y,
  K,
  O,
  w4 as w2,
  h,
  s16 as s10,
  i12 as i7,
  i13 as i8,
  a11 as a7,
  o6 as o4,
  t11 as t5,
  E9 as E5,
  A7 as A4,
  H2 as H,
  P4 as P2,
  _3 as _,
  X,
  P5 as P3,
  v4_default,
  u5 as u2,
  p8 as p3,
  n9 as n2,
  c11 as c4,
  n14 as n3,
  x7 as x2,
  c20 as c5,
  g22 as g3,
  l18 as l5,
  W3 as W2,
  d17 as d3,
  u13 as u3,
  o11 as o5,
  i22 as i9
};
/*! Bundled license information:

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

reflect-metadata/Reflect.js:
  (*! *****************************************************************************
  Copyright (C) Microsoft. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-GDHLO7W6.js.map
