{
  "version": 3,
  "sources": ["../../../../../../src/internal/config/data/RemoteConfigDataSource.test.ts"],
  "sourcesContent": ["import { Either, Left } from \"purify-ts\";\n\nimport {\n  ApiCallError,\n  JSONParseError,\n  ParseResponseError,\n} from \"@internal/config/model/Errors\";\n\nimport { type RemoteConfigDataSource } from \"./ConfigDataSource\";\nimport { RestRemoteConfigDataSource } from \"./RemoteConfigDataSource\";\n\nlet datasource: RemoteConfigDataSource;\n\n// Necessary to use `any` on the prototype to be able to spy on private methods\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst callApiSpy = vi.spyOn(\n  RestRemoteConfigDataSource.prototype as any,\n  \"_callApi\",\n);\nconst parseResponseSpy = vi.spyOn(\n  RestRemoteConfigDataSource.prototype as any,\n  \"_parseResponse\",\n);\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\ndescribe(\"RemoteRestConfigDataSource\", () => {\n  describe(\"RestRemoteConfigDataSource\", () => {\n    beforeEach(() => {\n      callApiSpy.mockClear();\n      parseResponseSpy.mockClear();\n      datasource = new RestRemoteConfigDataSource();\n    });\n\n    it(\"should return an Either<never, Config>\", async () => {\n      callApiSpy.mockResolvedValue(\n        Either.of({\n          ok: true,\n          json: () =>\n            Promise.resolve(\n              Either.of({ name: \"DeviceSDK\", version: \"0.0.0-fake.1\" }),\n            ),\n        }),\n      );\n\n      parseResponseSpy.mockReturnValue(\n        Either.of({\n          name: \"DeviceSDK\",\n          version: \"0.0.0-fake.1\",\n        }),\n      );\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Either.of({\n          name: \"DeviceSDK\",\n          version: \"0.0.0-fake.1\",\n        }),\n      );\n    });\n\n    it(\"should return an Either<ApiCallError, never> if _callApi throws\", async () => {\n      const err = new Error(\"_callApi error\");\n      callApiSpy.mockResolvedValue(Left(err));\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Left(new ApiCallError(err)),\n      );\n    });\n\n    it(\"should return an Either<ApiCallError, never> if _callApi returns a non-ok response\", async () => {\n      callApiSpy.mockResolvedValue(\n        Either.of({\n          ok: false,\n          json: () =>\n            Promise.resolve(\n              Either.of({ name: \"DeviceSDK\", version: \"0.0.0-fake.1\" }),\n            ),\n        }),\n      );\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Left(new ApiCallError(new Error(\"response not ok\"))),\n      );\n    });\n\n    it(\"should return an Either<JSONParseError, never> if deserializing json fails\", async () => {\n      const err = new Error(\"deserializing json failure\");\n      callApiSpy.mockResolvedValue(\n        Either.of({\n          ok: true,\n          json: () => Promise.resolve(Left(err)),\n        }),\n      );\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Left(new JSONParseError()),\n      );\n    });\n\n    it(\"should return an Either<ParseResponseError, never> if _parseResponse throws\", async () => {\n      callApiSpy.mockResolvedValue(\n        Either.of({\n          ok: true,\n          json: () =>\n            Promise.resolve(\n              Either.of({ name: \"DeviceSDK\", version: \"0.0.0-fake.1\" }),\n            ),\n        }),\n      );\n\n      parseResponseSpy.mockImplementation(() => {\n        return Left(new ParseResponseError());\n      });\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Left(new ParseResponseError()),\n      );\n    });\n\n    it(\"should return an Either<ParseResponseError, never> if `name` is missing in Dto\", async () => {\n      parseResponseSpy.mockRestore();\n      callApiSpy.mockResolvedValue(\n        Either.of({\n          ok: true,\n          json: () =>\n            Promise.resolve(\n              Either.of({\n                version: \"0.0.0-fake.1\",\n                yolo: \"yolo\",\n              }),\n            ),\n        }),\n      );\n\n      expect(await datasource.getConfig()).toStrictEqual(\n        Left(new ParseResponseError()),\n      );\n    });\n\n    describe(\"without private methods spy\", () => {\n      beforeEach(() => {\n        callApiSpy.mockRestore();\n        parseResponseSpy.mockRestore();\n      });\n\n      it(\"should return an Either<never, Config>\", async () => {\n        expect(await datasource.getConfig()).toStrictEqual(\n          Either.of({\n            name: \"DeviceSDK\",\n            version: \"0.0.0-fake.1\",\n          }),\n        );\n      });\n    });\n  });\n});\n"],
  "mappings": "aAAA,IAAAA,EAA6B,qBAE7BC,EAIO,yCAGPC,EAA2C,oCAE3C,IAAIC,EAIJ,MAAMC,EAAa,GAAG,MACpB,6BAA2B,UAC3B,UACF,EACMC,EAAmB,GAAG,MAC1B,6BAA2B,UAC3B,gBACF,EAGA,SAAS,6BAA8B,IAAM,CAC3C,SAAS,6BAA8B,IAAM,CAC3C,WAAW,IAAM,CACfD,EAAW,UAAU,EACrBC,EAAiB,UAAU,EAC3BF,EAAa,IAAI,4BACnB,CAAC,EAED,GAAG,yCAA0C,SAAY,CACvDC,EAAW,kBACT,SAAO,GAAG,CACR,GAAI,GACJ,KAAM,IACJ,QAAQ,QACN,SAAO,GAAG,CAAE,KAAM,YAAa,QAAS,cAAe,CAAC,CAC1D,CACJ,CAAC,CACH,EAEAC,EAAiB,gBACf,SAAO,GAAG,CACR,KAAM,YACN,QAAS,cACX,CAAC,CACH,EAEA,OAAO,MAAMF,EAAW,UAAU,CAAC,EAAE,cACnC,SAAO,GAAG,CACR,KAAM,YACN,QAAS,cACX,CAAC,CACH,CACF,CAAC,EAED,GAAG,kEAAmE,SAAY,CAChF,MAAMG,EAAM,IAAI,MAAM,gBAAgB,EACtCF,EAAW,qBAAkB,QAAKE,CAAG,CAAC,EAEtC,OAAO,MAAMH,EAAW,UAAU,CAAC,EAAE,iBACnC,QAAK,IAAI,eAAaG,CAAG,CAAC,CAC5B,CACF,CAAC,EAED,GAAG,qFAAsF,SAAY,CACnGF,EAAW,kBACT,SAAO,GAAG,CACR,GAAI,GACJ,KAAM,IACJ,QAAQ,QACN,SAAO,GAAG,CAAE,KAAM,YAAa,QAAS,cAAe,CAAC,CAC1D,CACJ,CAAC,CACH,EAEA,OAAO,MAAMD,EAAW,UAAU,CAAC,EAAE,iBACnC,QAAK,IAAI,eAAa,IAAI,MAAM,iBAAiB,CAAC,CAAC,CACrD,CACF,CAAC,EAED,GAAG,6EAA8E,SAAY,CAC3F,MAAMG,EAAM,IAAI,MAAM,4BAA4B,EAClDF,EAAW,kBACT,SAAO,GAAG,CACR,GAAI,GACJ,KAAM,IAAM,QAAQ,WAAQ,QAAKE,CAAG,CAAC,CACvC,CAAC,CACH,EAEA,OAAO,MAAMH,EAAW,UAAU,CAAC,EAAE,iBACnC,QAAK,IAAI,gBAAgB,CAC3B,CACF,CAAC,EAED,GAAG,8EAA+E,SAAY,CAC5FC,EAAW,kBACT,SAAO,GAAG,CACR,GAAI,GACJ,KAAM,IACJ,QAAQ,QACN,SAAO,GAAG,CAAE,KAAM,YAAa,QAAS,cAAe,CAAC,CAC1D,CACJ,CAAC,CACH,EAEAC,EAAiB,mBAAmB,OAC3B,QAAK,IAAI,oBAAoB,CACrC,EAED,OAAO,MAAMF,EAAW,UAAU,CAAC,EAAE,iBACnC,QAAK,IAAI,oBAAoB,CAC/B,CACF,CAAC,EAED,GAAG,iFAAkF,SAAY,CAC/FE,EAAiB,YAAY,EAC7BD,EAAW,kBACT,SAAO,GAAG,CACR,GAAI,GACJ,KAAM,IACJ,QAAQ,QACN,SAAO,GAAG,CACR,QAAS,eACT,KAAM,MACR,CAAC,CACH,CACJ,CAAC,CACH,EAEA,OAAO,MAAMD,EAAW,UAAU,CAAC,EAAE,iBACnC,QAAK,IAAI,oBAAoB,CAC/B,CACF,CAAC,EAED,SAAS,8BAA+B,IAAM,CAC5C,WAAW,IAAM,CACfC,EAAW,YAAY,EACvBC,EAAiB,YAAY,CAC/B,CAAC,EAED,GAAG,yCAA0C,SAAY,CACvD,OAAO,MAAMF,EAAW,UAAU,CAAC,EAAE,cACnC,SAAO,GAAG,CACR,KAAM,YACN,QAAS,cACX,CAAC,CACH,CACF,CAAC,CACH,CAAC,CACH,CAAC,CACH,CAAC",
  "names": ["import_purify_ts", "import_Errors", "import_RemoteConfigDataSource", "datasource", "callApiSpy", "parseResponseSpy", "err"]
}
