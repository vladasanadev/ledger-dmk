"use strict";var o=require("purify-ts"),D=require("../../../api/transport/model/__mocks__/TransportMock"),S=require("../../../api/transport/model/Errors"),y=require("../../../api/transport/model/TransportConnectedDevice.stub"),u=require("../../device-session/data/DeviceSessionRefresherConst"),v=require("../../device-session/model/DeviceSession.stub"),C=require("../../device-session/model/Errors"),h=require("../../device-session/service/DefaultDeviceSessionService"),w=require("../../logger-publisher/service/DefaultLoggerPublisherService"),g=require("../../manager-api/data/AxiosManagerApiDataSource"),T=require("../../manager-api/service/DefaultManagerApiService"),k=require("../../secure-channel/data/DefaultSecureChannelDataSource"),A=require("../../secure-channel/service/DefaultSecureChannelService"),E=require("../../transport/service/DefaultTransportService"),a=require("./DisconnectUseCase");vi.mock("@internal/transport/service/DefaultTransportService");let e,p,s=[];const n=vi.fn().mockReturnValue(new w.DefaultLoggerPublisherService([],"DisconnectUseCaseTest"));let c,m,f,d,l;const i="sessionId";describe("DisconnectUseCase",()=>{beforeAll(()=>{p=new D.TransportMock,s=[p],e=new h.DefaultDeviceSessionService(n),c=new E.DefaultTransportService,vi.spyOn(c,"getTransport").mockReturnValue(o.Maybe.of(p))}),it("should disconnect from a device",async()=>{const r=(0,y.connectedDeviceStubBuilder)();f=new g.AxiosManagerApiDataSource({}),m=new T.DefaultManagerApiService(f),d=new k.DefaultSecureChannelDataSource({}),l=new A.DefaultSecureChannelService(d);const t=(0,v.deviceSessionStubBuilder)({id:i,connectedDevice:r},n,m,l,u.DEVICE_SESSION_REFRESHER_DEFAULT_OPTIONS);vi.spyOn(e,"getDeviceSessionById").mockImplementation(()=>(0,o.Right)(t)),vi.spyOn(t,"close"),vi.spyOn(e,"removeDeviceSession"),vi.spyOn(s[0],"disconnect").mockImplementation(()=>Promise.resolve((0,o.Right)(void 0))),await new a.DisconnectUseCase(c,e,n).execute({sessionId:i}),expect(t.close).toHaveBeenCalled(),expect(e.removeDeviceSession).toHaveBeenCalledWith(i),expect(s[0].disconnect).toHaveBeenCalledWith({connectedDevice:r})}),it("should throw an error when deviceSession not found",async()=>{const r=new a.DisconnectUseCase(c,e,n);try{await r.execute({sessionId:i})}catch(t){expect(t).toStrictEqual(new C.DeviceSessionNotFound)}}),it("should throw an error if usb hid disconnection fails",async()=>{vi.spyOn(e,"getDeviceSessionById").mockImplementation(()=>(0,o.Right)((0,v.deviceSessionStubBuilder)({id:i},n,m,l,u.DEVICE_SESSION_REFRESHER_DEFAULT_OPTIONS))),vi.spyOn(s[0],"disconnect").mockResolvedValue((0,o.Left)(new S.DisconnectError));const r=new a.DisconnectUseCase(c,e,n);try{await r.execute({sessionId:i})}catch(t){expect(t).toStrictEqual(new S.DisconnectError)}})});
//# sourceMappingURL=DisconnectUseCase.test.js.map
