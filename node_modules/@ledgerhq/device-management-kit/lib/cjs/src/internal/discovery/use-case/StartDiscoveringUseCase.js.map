{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/StartDiscoveringUseCase.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { map, mergeMap, Observable, of } from \"rxjs\";\n\nimport { DeviceModel } from \"@api/device/DeviceModel\";\nimport { DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { TransportNotSupportedError } from \"@api/transport/model/Errors\";\nimport { TransportDiscoveredDevice } from \"@api/transport/model/TransportDiscoveredDevice\";\nimport { TransportIdentifier } from \"@api/transport/model/TransportIdentifier\";\nimport { transportDiTypes } from \"@internal/transport/di/transportDiTypes\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\nexport type StartDiscoveringUseCaseArgs = {\n  /**\n   * Identifier of the transport to start discovering devices.\n   * Can be undefined to discover all available transports in parralel.\n   */\n  transport?: TransportIdentifier;\n};\n\n/**\n * Starts discovering devices connected.\n *\n * For the WebHID implementation, this use-case needs to be called as a result of an user interaction (button \"click\" event for ex).\n */\n@injectable()\nexport class StartDiscoveringUseCase {\n  constructor(\n    @inject(transportDiTypes.TransportService)\n    private readonly _transportService: TransportService,\n  ) {}\n\n  private mapDiscoveredDevice(\n    device: TransportDiscoveredDevice,\n  ): DiscoveredDevice {\n    const deviceModel = new DeviceModel({\n      id: device.id,\n      model: device.deviceModel.id,\n      name: device.deviceModel.productName,\n    });\n    return {\n      id: device.id,\n      deviceModel,\n      transport: device.transport,\n      name: device.name || deviceModel.name,\n      rssi: device.rssi,\n    };\n  }\n\n  execute({\n    transport,\n  }: StartDiscoveringUseCaseArgs = {}): Observable<DiscoveredDevice> {\n    if (!transport) {\n      const transports = this._transportService.getAllTransports();\n      return of(...transports).pipe(\n        mergeMap((instance) =>\n          instance\n            .startDiscovering()\n            .pipe(map((device) => this.mapDiscoveredDevice(device))),\n        ),\n      );\n    }\n\n    const instance = this._transportService.getTransport(transport);\n\n    return instance.caseOf({\n      Just: (t) => {\n        return t\n          .startDiscovering()\n          .pipe(map((device) => this.mapDiscoveredDevice(device)));\n      },\n      Nothing: () => {\n        throw new TransportNotSupportedError(new Error(\"Unknown transport\"));\n      },\n    });\n  }\n}\n"],
  "mappings": "okBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,6BAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAmC,qBACnCC,EAA8C,gBAE9CC,EAA4B,mCAE5BC,EAA2C,uCAG3CC,EAAiC,mDAiB1B,IAAMC,EAAN,KAA8B,CACnC,YAEmBC,EACjB,CADiB,uBAAAA,CAChB,CAEK,oBACNC,EACkB,CAClB,MAAMC,EAAc,IAAI,cAAY,CAClC,GAAID,EAAO,GACX,MAAOA,EAAO,YAAY,GAC1B,KAAMA,EAAO,YAAY,WAC3B,CAAC,EACD,MAAO,CACL,GAAIA,EAAO,GACX,YAAAC,EACA,UAAWD,EAAO,UAClB,KAAMA,EAAO,MAAQC,EAAY,KACjC,KAAMD,EAAO,IACf,CACF,CAEA,QAAQ,CACN,UAAAE,CACF,EAAiC,CAAC,EAAiC,CACjE,GAAI,CAACA,EAAW,CACd,MAAMC,EAAa,KAAK,kBAAkB,iBAAiB,EAC3D,SAAO,MAAG,GAAGA,CAAU,EAAE,QACvB,YAAUC,GACRA,EACG,iBAAiB,EACjB,QAAK,OAAKJ,GAAW,KAAK,oBAAoBA,CAAM,CAAC,CAAC,CAC3D,CACF,CACF,CAIA,OAFiB,KAAK,kBAAkB,aAAaE,CAAS,EAE9C,OAAO,CACrB,KAAOG,GACEA,EACJ,iBAAiB,EACjB,QAAK,OAAKL,GAAW,KAAK,oBAAoBA,CAAM,CAAC,CAAC,EAE3D,QAAS,IAAM,CACb,MAAM,IAAI,6BAA2B,IAAI,MAAM,mBAAmB,CAAC,CACrE,CACF,CAAC,CACH,CACF,EAlDaF,EAANQ,EAAA,IADN,cAAW,EAGPC,EAAA,eAAO,mBAAiB,gBAAgB,IAFhCT",
  "names": ["StartDiscoveringUseCase_exports", "__export", "StartDiscoveringUseCase", "__toCommonJS", "import_inversify", "import_rxjs", "import_DeviceModel", "import_Errors", "import_transportDiTypes", "StartDiscoveringUseCase", "_transportService", "device", "deviceModel", "transport", "transports", "instance", "t", "__decorateClass", "__decorateParam"]
}
