{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/ReconnectUseCase.test.ts"],
  "sourcesContent": ["import { type DeviceModelId } from \"@api/device/DeviceModel\";\nimport { type ConnectionType } from \"@api/discovery/ConnectionType\";\nimport { type LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { type ConnectedDevice } from \"@api/transport/model/ConnectedDevice\";\nimport { DefaultLoggerPublisherService } from \"@internal/logger-publisher/service/DefaultLoggerPublisherService\";\n\nimport { type ConnectUseCase } from \"./ConnectUseCase\";\nimport { type DisconnectUseCase } from \"./DisconnectUseCase\";\nimport { ReconnectUseCase } from \"./ReconnectUseCase\";\n\nvi.mock(\"uuid\", () => ({\n  v4: vi.fn().mockReturnValue(\"newSessionId\"),\n}));\n\nlet logger: LoggerPublisherService;\nlet connectUseCase: ConnectUseCase;\nlet disconnectUseCase: DisconnectUseCase;\n\nconst newSessionId = \"newSessionId\";\n\ndescribe(\"ReconnectUseCase\", () => {\n  const stubConnectedDevice = {\n    sessionId: \"session-id\",\n    id: \"device-id\",\n    transport: \"USB\",\n    type: \"MOCK\" as unknown as ConnectionType,\n    modelId: \"model-id\" as unknown as DeviceModelId,\n    name: \"device-name\",\n  };\n  const tag = \"logger-tag\";\n\n  beforeAll(() => {\n    logger = new DefaultLoggerPublisherService([], tag);\n    connectUseCase = {} as ConnectUseCase;\n    disconnectUseCase = {} as DisconnectUseCase;\n  });\n\n  afterAll(() => {\n    vi.restoreAllMocks();\n  });\n\n  test(\"Should successfully reconnect device session (disconnect then connect)\", async () => {\n    // Given\n    connectUseCase.execute = vi.fn().mockResolvedValue(newSessionId);\n    disconnectUseCase.execute = vi.fn().mockResolvedValue(undefined);\n\n    const usecase = new ReconnectUseCase(\n      connectUseCase,\n      disconnectUseCase,\n      () => logger,\n    );\n\n    // When\n    const sessionId = await usecase.execute({\n      device: stubConnectedDevice,\n    });\n\n    // Then\n    expect(disconnectUseCase.execute).toHaveBeenCalledWith({\n      sessionId: stubConnectedDevice.sessionId,\n    });\n    expect(connectUseCase.execute).toHaveBeenCalledWith({\n      device: stubConnectedDevice,\n      sessionRefresherOptions: undefined,\n    });\n    expect(sessionId).toBe(newSessionId);\n  });\n\n  test(\"Should throw an error when disconnect fails\", async () => {\n    // Given\n    const disconnectError = new Error(\"Disconnect failed\");\n    disconnectUseCase.execute = vi.fn().mockRejectedValue(disconnectError);\n    connectUseCase.execute = vi.fn();\n\n    const usecase = new ReconnectUseCase(\n      connectUseCase,\n      disconnectUseCase,\n      () => logger,\n    );\n\n    // When / Then\n    await expect(\n      usecase.execute({\n        device: stubConnectedDevice as unknown as ConnectedDevice,\n      }),\n    ).rejects.toThrow(disconnectError);\n    expect(disconnectUseCase.execute).toHaveBeenCalled();\n    expect(connectUseCase.execute).not.toHaveBeenCalled();\n  });\n\n  test(\"Should throw an error when connect fails after successful disconnect\", async () => {\n    // Given\n    const connectError = new Error(\"Connect failed\");\n    disconnectUseCase.execute = vi.fn().mockResolvedValue(undefined);\n    connectUseCase.execute = vi.fn().mockRejectedValue(connectError);\n\n    const usecase = new ReconnectUseCase(\n      connectUseCase,\n      disconnectUseCase,\n      () => logger,\n    );\n\n    // When / Then\n    await expect(\n      usecase.execute({\n        device: stubConnectedDevice as unknown as ConnectedDevice,\n      }),\n    ).rejects.toThrow(connectError);\n    expect(disconnectUseCase.execute).toHaveBeenCalled();\n    expect(connectUseCase.execute).toHaveBeenCalled();\n  });\n});\n"],
  "mappings": "aAIA,IAAAA,EAA8C,4EAI9CC,EAAiC,8BAEjC,GAAG,KAAK,OAAQ,KAAO,CACrB,GAAI,GAAG,GAAG,EAAE,gBAAgB,cAAc,CAC5C,EAAE,EAEF,IAAIC,EACAC,EACAC,EAEJ,MAAMC,EAAe,eAErB,SAAS,mBAAoB,IAAM,CACjC,MAAMC,EAAsB,CAC1B,UAAW,aACX,GAAI,YACJ,UAAW,MACX,KAAM,OACN,QAAS,WACT,KAAM,aACR,EACMC,EAAM,aAEZ,UAAU,IAAM,CACdL,EAAS,IAAI,gCAA8B,CAAC,EAAGK,CAAG,EAClDJ,EAAiB,CAAC,EAClBC,EAAoB,CAAC,CACvB,CAAC,EAED,SAAS,IAAM,CACb,GAAG,gBAAgB,CACrB,CAAC,EAED,KAAK,yEAA0E,SAAY,CAEzFD,EAAe,QAAU,GAAG,GAAG,EAAE,kBAAkBE,CAAY,EAC/DD,EAAkB,QAAU,GAAG,GAAG,EAAE,kBAAkB,MAAS,EAS/D,MAAMI,EAAY,MAPF,IAAI,mBAClBL,EACAC,EACA,IAAMF,CACR,EAGgC,QAAQ,CACtC,OAAQI,CACV,CAAC,EAGD,OAAOF,EAAkB,OAAO,EAAE,qBAAqB,CACrD,UAAWE,EAAoB,SACjC,CAAC,EACD,OAAOH,EAAe,OAAO,EAAE,qBAAqB,CAClD,OAAQG,EACR,wBAAyB,MAC3B,CAAC,EACD,OAAOE,CAAS,EAAE,KAAKH,CAAY,CACrC,CAAC,EAED,KAAK,8CAA+C,SAAY,CAE9D,MAAMI,EAAkB,IAAI,MAAM,mBAAmB,EACrDL,EAAkB,QAAU,GAAG,GAAG,EAAE,kBAAkBK,CAAe,EACrEN,EAAe,QAAU,GAAG,GAAG,EAE/B,MAAMO,EAAU,IAAI,mBAClBP,EACAC,EACA,IAAMF,CACR,EAGA,MAAM,OACJQ,EAAQ,QAAQ,CACd,OAAQJ,CACV,CAAC,CACH,EAAE,QAAQ,QAAQG,CAAe,EACjC,OAAOL,EAAkB,OAAO,EAAE,iBAAiB,EACnD,OAAOD,EAAe,OAAO,EAAE,IAAI,iBAAiB,CACtD,CAAC,EAED,KAAK,uEAAwE,SAAY,CAEvF,MAAMQ,EAAe,IAAI,MAAM,gBAAgB,EAC/CP,EAAkB,QAAU,GAAG,GAAG,EAAE,kBAAkB,MAAS,EAC/DD,EAAe,QAAU,GAAG,GAAG,EAAE,kBAAkBQ,CAAY,EAE/D,MAAMD,EAAU,IAAI,mBAClBP,EACAC,EACA,IAAMF,CACR,EAGA,MAAM,OACJQ,EAAQ,QAAQ,CACd,OAAQJ,CACV,CAAC,CACH,EAAE,QAAQ,QAAQK,CAAY,EAC9B,OAAOP,EAAkB,OAAO,EAAE,iBAAiB,EACnD,OAAOD,EAAe,OAAO,EAAE,iBAAiB,CAClD,CAAC,CACH,CAAC",
  "names": ["import_DefaultLoggerPublisherService", "import_ReconnectUseCase", "logger", "connectUseCase", "disconnectUseCase", "newSessionId", "stubConnectedDevice", "tag", "sessionId", "disconnectError", "usecase", "connectError"]
}
