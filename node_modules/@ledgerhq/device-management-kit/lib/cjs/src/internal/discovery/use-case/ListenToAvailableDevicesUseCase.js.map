{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/ListenToAvailableDevicesUseCase.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { from, map, merge, Observable, of, scan } from \"rxjs\";\n\nimport { DeviceModel } from \"@api/device/DeviceModel\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { type Transport } from \"@api/transport/model/Transport\";\nimport { type TransportDiscoveredDevice } from \"@api/transport/model/TransportDiscoveredDevice\";\nimport { type TransportIdentifier } from \"@api/transport/model/TransportIdentifier\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\nimport { transportDiTypes } from \"@internal/transport/di/transportDiTypes\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\nexport type ListenToAvailableDevicesUseCaseArgs = {\n  /**\n   * Identifier of the transport to start discovering devices.\n   * Can be undefined to discover all available transports in parallel.\n   */\n  transport?: TransportIdentifier;\n};\n\n/**\n * Listen to list of known discovered devices (and later BLE).\n */\n@injectable()\nexport class ListenToAvailableDevicesUseCase {\n  private readonly _transports: Transport[];\n  private readonly _transportService: TransportService;\n  private readonly _logger: LoggerPublisherService;\n  constructor(\n    @inject(transportDiTypes.TransportService)\n    transportService: TransportService,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    this._transports = transportService.getAllTransports();\n    this._transportService = transportService;\n    this._logger = loggerFactory(\"ListenToAvailableDevicesUseCase\");\n  }\n\n  private mapTransportDiscoveredDeviceToDiscoveredDevice(\n    discoveredDevice: TransportDiscoveredDevice,\n  ): DiscoveredDevice {\n    const deviceModel = new DeviceModel({\n      id: discoveredDevice.id,\n      model: discoveredDevice.deviceModel.id,\n      name: discoveredDevice.deviceModel.productName,\n    });\n    return {\n      id: discoveredDevice.id,\n      deviceModel,\n      transport: discoveredDevice.transport,\n      name: discoveredDevice.name || deviceModel.name,\n      rssi: discoveredDevice.rssi,\n    };\n  }\n\n  execute({ transport }: ListenToAvailableDevicesUseCaseArgs = {}): Observable<\n    DiscoveredDevice[]\n  > {\n    this._logger.info(\"Listening to available devices\");\n\n    if (this._transports.length === 0) {\n      this._logger.warn(\"No transports available\");\n      return from([[]]);\n    }\n\n    if (!transport) {\n      this._logger.info(\"Discovering all available transports\");\n      /**\n       * Note: we're not using combineLatest because combineLatest will\n       * - wait for all observables to emit at least once before emitting.\n       * - complete as soon as one of the observables completes.\n       * Some transports will just return an empty array and complete.\n       * We want to keep listening to all transports until all have completed.\n       */\n\n      const observablesWithIndex = this._transports.map((t, index) =>\n        t.listenToAvailableDevices().pipe(\n          map((arr) => ({\n            index,\n            arr,\n          })),\n        ),\n      );\n\n      return merge(...observablesWithIndex).pipe(\n        scan<\n          { index: number; arr: TransportDiscoveredDevice[] },\n          { [key: number]: TransportDiscoveredDevice[] }\n        >((acc, { index, arr }) => {\n          acc[index] = arr;\n          return acc;\n        }, {}),\n        map((acc) =>\n          Object.values(acc)\n            .flat()\n            .map(this.mapTransportDiscoveredDeviceToDiscoveredDevice),\n        ),\n      );\n    }\n\n    this._logger.info(`Discovering devices on transport ${transport}`);\n\n    const instance = this._transportService.getTransport(transport);\n\n    return instance.caseOf({\n      Nothing: () => {\n        this._logger.error(`Transport ${transport} not found`);\n        return of([]);\n      },\n      Just: (t) => {\n        return t\n          .listenToAvailableDevices()\n          .pipe(\n            map((devices) =>\n              devices.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice),\n            ),\n          );\n      },\n    });\n  }\n}\n"],
  "mappings": "okBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,qCAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAmC,qBACnCC,EAAuD,gBAEvDC,EAA4B,mCAM5BC,EAA4B,qDAC5BC,EAAiC,mDAe1B,IAAMC,EAAN,KAAsC,CAC1B,YACA,kBACA,QACjB,YAEEC,EAEAC,EACA,CACA,KAAK,YAAcD,EAAiB,iBAAiB,EACrD,KAAK,kBAAoBA,EACzB,KAAK,QAAUC,EAAc,iCAAiC,CAChE,CAEQ,+CACNC,EACkB,CAClB,MAAMC,EAAc,IAAI,cAAY,CAClC,GAAID,EAAiB,GACrB,MAAOA,EAAiB,YAAY,GACpC,KAAMA,EAAiB,YAAY,WACrC,CAAC,EACD,MAAO,CACL,GAAIA,EAAiB,GACrB,YAAAC,EACA,UAAWD,EAAiB,UAC5B,KAAMA,EAAiB,MAAQC,EAAY,KAC3C,KAAMD,EAAiB,IACzB,CACF,CAEA,QAAQ,CAAE,UAAAE,CAAU,EAAyC,CAAC,EAE5D,CAGA,GAFA,KAAK,QAAQ,KAAK,gCAAgC,EAE9C,KAAK,YAAY,SAAW,EAC9B,YAAK,QAAQ,KAAK,yBAAyB,KACpC,QAAK,CAAC,CAAC,CAAC,CAAC,EAGlB,GAAI,CAACA,EAAW,CACd,KAAK,QAAQ,KAAK,sCAAsC,EASxD,MAAMC,EAAuB,KAAK,YAAY,IAAI,CAACC,EAAGC,IACpDD,EAAE,yBAAyB,EAAE,QAC3B,OAAKE,IAAS,CACZ,MAAAD,EACA,IAAAC,CACF,EAAE,CACJ,CACF,EAEA,SAAO,SAAM,GAAGH,CAAoB,EAAE,QACpC,QAGE,CAACI,EAAK,CAAE,MAAAF,EAAO,IAAAC,CAAI,KACnBC,EAAIF,CAAK,EAAIC,EACNC,GACN,CAAC,CAAC,KACL,OAAKA,GACH,OAAO,OAAOA,CAAG,EACd,KAAK,EACL,IAAI,KAAK,8CAA8C,CAC5D,CACF,CACF,CAEA,YAAK,QAAQ,KAAK,oCAAoCL,CAAS,EAAE,EAEhD,KAAK,kBAAkB,aAAaA,CAAS,EAE9C,OAAO,CACrB,QAAS,KACP,KAAK,QAAQ,MAAM,aAAaA,CAAS,YAAY,KAC9C,MAAG,CAAC,CAAC,GAEd,KAAOE,GACEA,EACJ,yBAAyB,EACzB,QACC,OAAKI,GACHA,EAAQ,IAAI,KAAK,8CAA8C,CACjE,CACF,CAEN,CAAC,CACH,CACF,EAjGaX,EAANY,EAAA,IADN,cAAW,EAMPC,EAAA,eAAO,mBAAiB,gBAAgB,GAExCA,EAAA,eAAO,cAAY,6BAA6B,IAPxCb",
  "names": ["ListenToAvailableDevicesUseCase_exports", "__export", "ListenToAvailableDevicesUseCase", "__toCommonJS", "import_inversify", "import_rxjs", "import_DeviceModel", "import_loggerTypes", "import_transportDiTypes", "ListenToAvailableDevicesUseCase", "transportService", "loggerFactory", "discoveredDevice", "deviceModel", "transport", "observablesWithIndex", "t", "index", "arr", "acc", "devices", "__decorateClass", "__decorateParam"]
}
