"use strict";var o=require("purify-ts"),D=require("../../../api/transport/model/__mocks__/TransportMock"),v=require("../../../api/transport/model/Errors"),g=require("../../../api/transport/model/TransportConnectedDevice.stub"),y=require("../../device-session/service/DefaultDeviceSessionService"),k=require("../../logger-publisher/service/DefaultLoggerPublisherService"),C=require("../../manager-api/data/AxiosManagerApiDataSource"),w=require("../../manager-api/service/DefaultManagerApiService"),I=require("../../secure-channel/data/DefaultSecureChannelDataSource"),M=require("../../secure-channel/service/DefaultSecureChannelService"),T=require("../../transport/service/DefaultTransportService"),m=require("./ConnectUseCase");vi.mock("uuid",()=>({v4:vi.fn().mockReturnValue("fakeSessionId")}));vi.mock("@internal/manager-api/data/AxiosManagerApiDataSource");vi.mock("@internal/transport/service/DefaultTransportService");let n,t,s,e,c,f,l,a;const b="fakeSessionId",d="fakeSessionIdConnectedDevice";describe("ConnectUseCase",()=>{const u={id:"",deviceModel:{},transport:"USB",name:"TEST"},S=(0,g.connectedDeviceStubBuilder)({id:"1"}),h={id:"1",sessionId:d,modelId:"model-id",name:"device-name",type:"MOCK",transport:"USB"},A="logger-tag";beforeAll(()=>{s=new k.DefaultLoggerPublisherService([],A),n=new D.TransportMock,e=new y.DefaultDeviceSessionService(()=>s),f=new C.AxiosManagerApiDataSource({}),c=new w.DefaultManagerApiService(f),l=new I.DefaultSecureChannelDataSource({}),a=new M.DefaultSecureChannelService(l),t=new T.DefaultTransportService}),afterEach(()=>{for(const r of e.getDeviceSessions())e.removeDeviceSession(r.id)}),afterAll(()=>{vi.restoreAllMocks()}),test("If connect use case encounter an error, return it",async()=>{vi.spyOn(n,"connect").mockResolvedValue((0,o.Left)(new v.UnknownDeviceError)),vi.spyOn(t,"getTransport").mockReturnValue(o.Maybe.of(n));const r=new m.ConnectUseCase(t,e,()=>s,c,a);await expect(r.execute({device:u})).rejects.toBeInstanceOf(v.UnknownDeviceError)}),test("If connect is in success, return a deviceSession id",async()=>{vi.spyOn(n,"connect").mockResolvedValue((0,o.Right)(S)),vi.spyOn(t,"getTransport").mockReturnValue(o.Maybe.of(n)),vi.spyOn(e,"addDeviceSession").mockImplementation(p=>(p.setDeviceSessionState({}),e));const i=await new m.ConnectUseCase(t,e,()=>s,c,a).execute({device:u});expect(i).toBe(b),e.removeDeviceSession(i)}),test("If connect is in success after a reconnect, return the same deviceSession id",async()=>{vi.spyOn(n,"connect").mockResolvedValue((0,o.Right)(S)),vi.spyOn(t,"getTransport").mockReturnValue(o.Maybe.of(n)),vi.spyOn(e,"addDeviceSession").mockImplementation(p=>(p.setDeviceSessionState({}),e));const i=await new m.ConnectUseCase(t,e,()=>s,c,a).execute({device:h});expect(i).toBe(d),e.removeDeviceSession(i)})});
//# sourceMappingURL=ConnectUseCase.test.js.map
