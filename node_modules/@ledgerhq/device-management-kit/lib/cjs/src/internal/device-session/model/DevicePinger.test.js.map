{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DevicePinger.test.ts"],
  "sourcesContent": ["import { Subject } from \"rxjs\";\nimport { afterEach, beforeEach, describe, expect, it, vi } from \"vitest\";\n\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport {\n  GetAppAndVersionCommand,\n  type TransportConnectedDevice,\n} from \"@api/index\";\nimport type { LoggerPublisherService } from \"@api/types\";\nimport { DEVICE_SESSION_REFRESHER_POLLING_INTERVAL } from \"@internal/device-session/data/DeviceSessionRefresherConst\";\nimport {\n  type DeviceSessionEventDispatcher,\n  type NewEvent,\n  SessionEvents,\n} from \"@internal/device-session/model/DeviceSessionEventDispatcher\";\n\nimport { DevicePinger } from \"./DevicePinger\";\n\ndescribe(\"DevicePinger\", () => {\n  let dummySendCommandFunction: ReturnType<typeof vi.fn>;\n  let mockLogger: LoggerPublisherService & {\n    info: ReturnType<typeof vi.fn>;\n    warn: ReturnType<typeof vi.fn>;\n    error: ReturnType<typeof vi.fn>;\n  };\n  const mockedLoggerModuleFactory = vi.fn(() => mockLogger);\n  let eventSubject: Subject<NewEvent>;\n  let mockSessionEventDispatcher: DeviceSessionEventDispatcher;\n  let dummyConnectedDevice: TransportConnectedDevice;\n  let devicePinger: DevicePinger;\n\n  beforeEach(() => {\n    eventSubject = new Subject<NewEvent>();\n    mockSessionEventDispatcher = {\n      listen: () => eventSubject.asObservable(),\n      dispatch: vi.fn(),\n    } as unknown as DeviceSessionEventDispatcher;\n\n    dummySendCommandFunction = vi.fn();\n    mockLogger = {\n      info: vi.fn(),\n      warn: vi.fn(),\n      error: vi.fn(),\n      debug: vi.fn(),\n      subscribers: [],\n    };\n\n    dummyConnectedDevice = {\n      deviceModel: {\n        id: DeviceModelId.NANO_X,\n      },\n    } as unknown as TransportConnectedDevice;\n\n    devicePinger = new DevicePinger(\n      mockedLoggerModuleFactory,\n      dummyConnectedDevice,\n      mockSessionEventDispatcher,\n      dummySendCommandFunction,\n    );\n  });\n\n  afterEach(() => {\n    devicePinger.unsubscribe();\n    vi.restoreAllMocks();\n  });\n\n  it(\"should call sendCommandFunction and dispatch COMMAND_SUCCEEDED event on successful ping for non-NANO_S\", async () => {\n    // given\n    const dummyResult = {\n      status: \"success\",\n      data: { foo: \"bar\" },\n    };\n    dummySendCommandFunction.mockResolvedValue(dummyResult);\n\n    // when\n    const result = await devicePinger.ping();\n\n    // then\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n    const commandArg = dummySendCommandFunction.mock\n      .calls[0]![0] as GetAppAndVersionCommand;\n    expect(commandArg).toBeInstanceOf(GetAppAndVersionCommand);\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.COMMAND_SUCCEEDED,\n      eventData: dummyResult,\n    });\n    expect(result).toEqual(dummyResult);\n  });\n\n  it(\"should log error and throw error on ping failure\", async () => {\n    // given\n    const dummyError = new Error(\"ping failed\");\n    dummySendCommandFunction.mockRejectedValue(dummyError);\n\n    // then\n    await expect(devicePinger.ping()).rejects.toThrow(\"ping failed\");\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should dispatch DEVICE_STATE_UPDATE_LOCKED and return null on timeout for NANO_S\", async () => {\n    // given\n    dummyConnectedDevice.deviceModel.id = DeviceModelId.NANO_S;\n    devicePinger.unsubscribe();\n    devicePinger = new DevicePinger(\n      mockedLoggerModuleFactory,\n      dummyConnectedDevice,\n      mockSessionEventDispatcher,\n      dummySendCommandFunction,\n    );\n    const neverResolvingPromise = new Promise(() => {});\n    dummySendCommandFunction.mockReturnValueOnce(neverResolvingPromise);\n    vi.useFakeTimers();\n\n    // when\n    const pingPromise = devicePinger.ping();\n    vi.advanceTimersByTime(DEVICE_SESSION_REFRESHER_POLLING_INTERVAL * 4);\n\n    const result = await pingPromise;\n\n    // then\n    expect(result).toBeNull();\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.DEVICE_STATE_UPDATE_LOCKED,\n    });\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n\n    vi.useRealTimers();\n  });\n\n  it(\"should call ping on REFRESH_NEEDED event\", async () => {\n    // given\n    const dummyResult = {\n      status: \"success\",\n      data: { foo: \"bar\" },\n    };\n    dummySendCommandFunction.mockResolvedValue(dummyResult);\n\n    // when\n    eventSubject.next({\n      eventName: SessionEvents.REFRESH_NEEDED,\n      eventData: undefined,\n    });\n    await Promise.resolve();\n\n    // then\n    expect(dummySendCommandFunction).toHaveBeenCalled();\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.COMMAND_SUCCEEDED,\n      eventData: dummyResult,\n    });\n  });\n\n  it(\"should not process events after unsubscribe is called\", async () => {\n    // given\n    devicePinger.unsubscribe();\n    dummySendCommandFunction.mockClear();\n\n    // when\n    eventSubject.next({\n      eventName: SessionEvents.REFRESH_NEEDED,\n      eventData: undefined,\n    });\n    await Promise.resolve();\n\n    // then\n    expect(dummySendCommandFunction).not.toHaveBeenCalled();\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_rxjs", "import_vitest", "import_DeviceModel", "import_api", "import_DeviceSessionRefresherConst", "import_DeviceSessionEventDispatcher", "import_DevicePinger", "dummySendCommandFunction", "mockLogger", "mockedLoggerModuleFactory", "eventSubject", "mockSessionEventDispatcher", "dummyConnectedDevice", "devicePinger", "dummyResult", "result", "commandArg", "dummyError", "neverResolvingPromise", "pingPromise"]
}
