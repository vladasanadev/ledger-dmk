{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DevicePinger.ts"],
  "sourcesContent": ["import { type Subscription } from \"rxjs\";\n\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport {\n  GetAppAndVersionCommand,\n  type GetAppAndVersionResponse,\n  GetOsVersionCommand,\n  type TransportConnectedDevice,\n} from \"@api/index\";\nimport {\n  type Command,\n  type CommandResult,\n  type LoggerPublisherService,\n} from \"@api/types\";\nimport { PINGER_TIMEOUT } from \"@internal/device-session/data/ApduResponseConst\";\nimport { DEVICE_SESSION_REFRESHER_POLLING_INTERVAL } from \"@internal/device-session/data/DeviceSessionRefresherConst\";\nimport {\n  type DeviceSessionEventDispatcher,\n  type NewEvent,\n  SessionEvents,\n} from \"@internal/device-session/model/DeviceSessionEventDispatcher\";\n\ntype SendCommandFunction = <Response, Args, ErrorStatusCodes>(\n  command: Command<Response, Args, ErrorStatusCodes>,\n  abortTimeout?: number,\n) => Promise<CommandResult<Response, ErrorStatusCodes>>;\n\nexport class DevicePinger {\n  private readonly _sendCommandFunction: SendCommandFunction;\n  private _subscription: Subscription;\n  private _logger: LoggerPublisherService;\n\n  constructor(\n    loggerModuleFactory: (tag: string) => LoggerPublisherService,\n    private connectedDevice: TransportConnectedDevice,\n    private _sessionEventDispatcher: DeviceSessionEventDispatcher,\n    sendCommandFunction: SendCommandFunction,\n  ) {\n    this._sendCommandFunction = sendCommandFunction;\n    this._logger = loggerModuleFactory(\"device-pinger\");\n    this._subscription = this._sessionEventDispatcher\n      .listen()\n      .subscribe(async (event) => await this.mapEventAction(event));\n  }\n\n  public async ping(): Promise<CommandResult<GetAppAndVersionResponse> | null> {\n    try {\n      const result = await this.mapDevicePingAction(\n        this.connectedDevice.deviceModel.id,\n      );\n      return result;\n    } catch (error) {\n      this._logger.error(\"Error while pinging device\", {\n        data: {\n          error,\n        },\n      });\n      throw error;\n    }\n  }\n\n  private mapEventAction = async (event: NewEvent) => {\n    switch (event.eventName) {\n      case SessionEvents.REFRESH_NEEDED:\n        return await this.ping();\n      default:\n        return null;\n    }\n  };\n\n  private async mapDevicePingAction(deviceModelId: DeviceModelId) {\n    switch (deviceModelId) {\n      case DeviceModelId.NANO_S: {\n        const chainPromise: () => Promise<\n          CommandResult<GetAppAndVersionResponse>\n        > = async () => {\n          const appVersionResult = await this._sendCommandFunction(\n            new GetAppAndVersionCommand(),\n            PINGER_TIMEOUT,\n          );\n\n          this._sendCommandFunction(new GetOsVersionCommand(), PINGER_TIMEOUT);\n          return appVersionResult;\n        };\n\n        const timeoutPromise: Promise<null> = new Promise((resolve) => {\n          setTimeout(\n            () => resolve(null),\n            DEVICE_SESSION_REFRESHER_POLLING_INTERVAL * 2 + 100,\n          );\n        });\n\n        const resultOrTimeout: CommandResult<GetAppAndVersionResponse> | null =\n          await Promise.race([chainPromise(), timeoutPromise]);\n\n        if (!resultOrTimeout) {\n          this._sessionEventDispatcher.dispatch({\n            eventName: SessionEvents.DEVICE_STATE_UPDATE_LOCKED,\n          });\n        } else {\n          this._sessionEventDispatcher.dispatch({\n            eventName: SessionEvents.COMMAND_SUCCEEDED,\n            eventData: resultOrTimeout,\n          });\n        }\n        return resultOrTimeout;\n      }\n      default: {\n        const result = await this._sendCommandFunction(\n          new GetAppAndVersionCommand(),\n          PINGER_TIMEOUT,\n        );\n        this._sessionEventDispatcher.dispatch({\n          eventName: SessionEvents.COMMAND_SUCCEEDED,\n          eventData: result,\n        });\n        return result;\n      }\n    }\n  }\n\n  public unsubscribe(): void {\n    this._subscription.unsubscribe();\n  }\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,kBAAAE,IAAA,eAAAC,EAAAH,GAEA,IAAAI,EAA8B,mCAC9BC,EAKO,sBAMPC,EAA+B,2DAC/BC,EAA0D,qEAC1DC,EAIO,uEAOA,MAAMN,CAAa,CAKxB,YACEO,EACQC,EACAC,EACRC,EACA,CAHQ,qBAAAF,EACA,6BAAAC,EAGR,KAAK,qBAAuBC,EAC5B,KAAK,QAAUH,EAAoB,eAAe,EAClD,KAAK,cAAgB,KAAK,wBACvB,OAAO,EACP,UAAU,MAAOI,GAAU,MAAM,KAAK,eAAeA,CAAK,CAAC,CAChE,CAfiB,qBACT,cACA,QAeR,MAAa,MAAgE,CAC3E,GAAI,CAIF,OAHe,MAAM,KAAK,oBACxB,KAAK,gBAAgB,YAAY,EACnC,CAEF,OAASC,EAAO,CACd,WAAK,QAAQ,MAAM,6BAA8B,CAC/C,KAAM,CACJ,MAAAA,CACF,CACF,CAAC,EACKA,CACR,CACF,CAEQ,eAAiB,MAAOD,GAAoB,CAClD,OAAQA,EAAM,UAAW,CACvB,KAAK,gBAAc,eACjB,OAAO,MAAM,KAAK,KAAK,EACzB,QACE,OAAO,IACX,CACF,EAEA,MAAc,oBAAoBE,EAA8B,CAC9D,OAAQA,EAAe,CACrB,KAAK,gBAAc,OAAQ,CACzB,MAAMC,EAEF,SAAY,CACd,MAAMC,EAAmB,MAAM,KAAK,qBAClC,IAAI,0BACJ,gBACF,EAEA,YAAK,qBAAqB,IAAI,sBAAuB,gBAAc,EAC5DA,CACT,EAEMC,EAAgC,IAAI,QAASC,GAAY,CAC7D,WACE,IAAMA,EAAQ,IAAI,EAClB,4CAA4C,EAAI,GAClD,CACF,CAAC,EAEKC,EACJ,MAAM,QAAQ,KAAK,CAACJ,EAAa,EAAGE,CAAc,CAAC,EAErD,OAAKE,EAKH,KAAK,wBAAwB,SAAS,CACpC,UAAW,gBAAc,kBACzB,UAAWA,CACb,CAAC,EAPD,KAAK,wBAAwB,SAAS,CACpC,UAAW,gBAAc,0BAC3B,CAAC,EAOIA,CACT,CACA,QAAS,CACP,MAAMC,EAAS,MAAM,KAAK,qBACxB,IAAI,0BACJ,gBACF,EACA,YAAK,wBAAwB,SAAS,CACpC,UAAW,gBAAc,kBACzB,UAAWA,CACb,CAAC,EACMA,CACT,CACF,CACF,CAEO,aAAoB,CACzB,KAAK,cAAc,YAAY,CACjC,CACF",
  "names": ["DevicePinger_exports", "__export", "DevicePinger", "__toCommonJS", "import_DeviceModel", "import_api", "import_ApduResponseConst", "import_DeviceSessionRefresherConst", "import_DeviceSessionEventDispatcher", "loggerModuleFactory", "connectedDevice", "_sessionEventDispatcher", "sendCommandFunction", "event", "error", "deviceModelId", "chainPromise", "appVersionResult", "timeoutPromise", "resolve", "resultOrTimeout", "result"]
}
