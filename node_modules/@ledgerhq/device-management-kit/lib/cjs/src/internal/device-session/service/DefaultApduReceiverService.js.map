{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/service/DefaultApduReceiverService.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { Either, Just, Left, Maybe, Nothing, Right } from \"purify-ts\";\nimport { v4 } from \"uuid\";\n\nimport { ApduResponse } from \"@api/device-session/ApduResponse\";\nimport {\n  APDU_DATA_LENGTH_LENGTH,\n  CHANNEL_LENGTH,\n  HEAD_TAG_LENGTH,\n  INDEX_LENGTH,\n} from \"@api/device-session/data/FramerConst\";\nimport {\n  type ApduReceiverConstructorArgs,\n  ApduReceiverService,\n} from \"@api/device-session/service/ApduReceiverService\";\nimport { FramerUtils } from \"@api/device-session/utils/FramerUtils\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { APDU_RESPONSE_STATUS_CODE_LENGTH } from \"@internal/device-session/data/ApduResponseConst\";\nimport { ReceiverApduError } from \"@internal/device-session/model/Errors\";\nimport { Frame } from \"@internal/device-session/model/Frame\";\nimport { FrameHeader } from \"@internal/device-session/model/FrameHeader\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\n\n@injectable()\nexport class DefaultApduReceiverService implements ApduReceiverService {\n  private readonly _channel: Maybe<Uint8Array>;\n  private readonly _logger: LoggerPublisherService;\n  private _pendingFrames: Frame[];\n\n  constructor(\n    { channel = Maybe.zero() }: ApduReceiverConstructorArgs,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerModuleFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    this._channel = channel;\n    this._logger = loggerModuleFactory(\"ApduReceiverService\");\n    this._pendingFrames = [];\n  }\n\n  /*\n   * Return\n   * - A complete ApduResponse\n   * - Or a Nothing if not all the data has been received\n   * - Or a ReceiverApduError if the apdu is not formatted correctly\n   *\n   * @param Uint8Array\n   */\n  public handleFrame(\n    frameBytes: Uint8Array,\n  ): Either<ReceiverApduError, Maybe<ApduResponse>> {\n    const frame = this.getFrameFromBytes(frameBytes);\n\n    return frame.map((value) => {\n      this._pendingFrames.push(value);\n      if (!this._pendingFrames[0]) {\n        return Nothing;\n      }\n      const dataSize = this._pendingFrames[0].getHeader().getDataLength();\n      return this.getCompleteFrame(dataSize);\n    });\n  }\n\n  /*\n   * Return\n   * - A complete ApduResponse\n   * - Or a Nothing if not all the data has been received\n   *\n   * @param Maybe<number>\n   */\n  private getCompleteFrame(dataSize: Maybe<number>): Maybe<ApduResponse> {\n    return dataSize.chain((value) => {\n      if (!this.isComplete(value)) {\n        this._logger.debug(\"frame is not complete, waiting for more\");\n        return Nothing;\n      }\n\n      const concatenatedFramesData = FramerUtils.getFirstBytesFrom(\n        this.concatFrames(this._pendingFrames),\n        value,\n      );\n      const data = FramerUtils.getFirstBytesFrom(\n        concatenatedFramesData,\n        concatenatedFramesData.length - APDU_RESPONSE_STATUS_CODE_LENGTH,\n      );\n      const statusCode = FramerUtils.getLastBytesFrom(\n        concatenatedFramesData,\n        APDU_RESPONSE_STATUS_CODE_LENGTH,\n      );\n\n      this._pendingFrames = [];\n\n      return Just(\n        new ApduResponse({\n          data: data,\n          statusCode,\n        }),\n      );\n    });\n  }\n\n  /*\n   * Parse an Uint8Array to a Frame\n   * Return an error if the frame is not formatted correctly\n   *\n   * @param Uint8Array\n   */\n  private getFrameFromBytes(\n    rawFrame: Uint8Array,\n  ): Either<ReceiverApduError, Frame> {\n    const channelSize = this._channel.caseOf({\n      Just: () => CHANNEL_LENGTH,\n      Nothing: () => 0,\n    });\n\n    const headTag = rawFrame.slice(channelSize, channelSize + HEAD_TAG_LENGTH);\n    const index = rawFrame.slice(\n      channelSize + HEAD_TAG_LENGTH,\n      channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH,\n    );\n\n    const isFirstIndex = index.reduce((curr, val) => curr + val, 0) === 0;\n\n    if (!isFirstIndex && this._pendingFrames.length === 0) {\n      return Left(new ReceiverApduError());\n    }\n\n    const dataSizeIndex = channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH;\n    const dataSizeLength = isFirstIndex ? APDU_DATA_LENGTH_LENGTH : 0;\n\n    if (\n      rawFrame.length <\n      channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH + dataSizeLength\n    ) {\n      return Left(new ReceiverApduError(\"Unable to parse header from apdu\"));\n    }\n\n    const dataSize = isFirstIndex\n      ? Just(rawFrame.slice(dataSizeIndex, dataSizeIndex + dataSizeLength))\n      : Nothing;\n\n    const dataIndex = dataSizeIndex + dataSizeLength;\n    const data = rawFrame.slice(dataIndex);\n\n    const frame = new Frame({\n      header: new FrameHeader({\n        uuid: v4(),\n        channel: this._channel,\n        dataSize,\n        headTag,\n        index,\n        length: channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH + dataSizeLength,\n      }),\n      data,\n    });\n\n    return Right(frame);\n  }\n\n  /*\n   * Return true if all the datas has been received\n   *\n   * @param number\n   */\n  private isComplete(dataSize: number): boolean {\n    const totalReceiveLength = this._pendingFrames.reduce(\n      (prev, curr) => prev + curr.getData().length,\n      0,\n    );\n\n    return totalReceiveLength >= dataSize;\n  }\n\n  private concatFrames(frames: Frame[]): Uint8Array {\n    return frames.reduce(\n      (prev: Uint8Array, curr: Frame) =>\n        Uint8Array.from([...prev, ...curr.getData()]),\n      new Uint8Array(0),\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["DefaultApduReceiverService_exports", "__export", "DefaultApduReceiverService", "__toCommonJS", "import_inversify", "import_purify_ts", "import_uuid", "import_ApduResponse", "import_FramerConst", "import_FramerUtils", "import_ApduResponseConst", "import_Errors", "import_Frame", "import_FrameHeader", "import_loggerTypes", "DefaultApduReceiverService", "channel", "loggerModuleFactory", "frameBytes", "value", "dataSize", "concatenatedFramesData", "data", "statusCode", "rawFrame", "channelSize", "headTag", "index", "isFirstIndex", "curr", "val", "dataSizeIndex", "dataSizeLength", "dataIndex", "frame", "prev", "frames", "__decorateClass", "__decorateParam"]
}
