{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/service/DefaultApduSenderService.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { Either, Left, Maybe, Right } from \"purify-ts\";\nimport { v4 } from \"uuid\";\n\nimport {\n  APDU_DATA_LENGTH_LENGTH,\n  CHANNEL_LENGTH,\n  HEAD_TAG,\n  HEAD_TAG_LENGTH,\n  INDEX_LENGTH,\n} from \"@api/device-session/data/FramerConst\";\nimport type {\n  ApduSenderService,\n  ApduSenderServiceConstructorArgs,\n} from \"@api/device-session/service/ApduSenderService\";\nimport { FramerUtils } from \"@api/device-session/utils/FramerUtils\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport {\n  FramerApduError,\n  FramerOverflowError,\n} from \"@internal/device-session/model/Errors\";\nimport { Frame } from \"@internal/device-session/model/Frame\";\nimport { FrameHeader } from \"@internal/device-session/model/FrameHeader\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\nimport { DmkError } from \"@root/src/api/Error\";\n/**\n * Default implementation of ApduSenderService\n *\n * Split APDU in an array of frames readies to send to a TransportConnectedDevice\n */\n@injectable()\nexport class DefaultApduSenderService implements ApduSenderService {\n  protected _frameSize: number;\n  protected _channel: Maybe<Uint8Array>;\n  protected _padding: boolean;\n  private _logger: LoggerPublisherService;\n\n  /**\n   * Constructor\n   *\n   * @param frameSize\n   * @param channel\n   * @param padding\n   * @param loggerServiceFactory\n   */\n  constructor(\n    {\n      frameSize,\n      channel = Maybe.zero(),\n      padding = false,\n    }: ApduSenderServiceConstructorArgs,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerServiceFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    this._frameSize = frameSize;\n    this._channel = channel;\n    this._padding = padding;\n    this._logger = loggerServiceFactory(\"DefaultApduSenderService\");\n  }\n\n  /**\n   * Get frames from apdu\n   *\n   * @param apdu\n   */\n  public getFrames(apdu: Uint8Array): Frame[] {\n    const frames: Frame[] = [];\n    let count = 0;\n    let frame = this.getFrameAtIndex(apdu, count);\n\n    while (frame.isRight()) {\n      frames.push(frame.extract());\n      count += 1;\n      frame = this.getFrameAtIndex(apdu, count).mapLeft((error) => {\n        if (error instanceof FramerOverflowError) {\n          // do nothing\n        } else {\n          this._logger.error(\"Error while parsing frame\", { data: { error } });\n        }\n        return error;\n      });\n    }\n    return frames;\n  }\n\n  /**\n   * Get apdu frame at index\n   * Split every {{PACKET_SIZE - HEADER_SIZE}} bytes of apdu\n   * @param apdu\n   * @param frameIndex\n   * @private\n   */\n  private getFrameAtIndex(\n    apdu: Uint8Array,\n    frameIndex: number,\n  ): Either<DmkError, Frame> {\n    const header = this.getFrameHeaderFrom(frameIndex, apdu.length);\n    const frameOffset =\n      frameIndex === 0\n        ? 0\n        : frameIndex * this._frameSize - this.getHeaderSizeSumFrom(frameIndex);\n\n    if (frameOffset >= apdu.length) {\n      return Left(new FramerOverflowError());\n    }\n    if (header.getLength() > this._frameSize) {\n      return Left(new FramerApduError());\n    }\n    const dataMaxSize = this._frameSize - header.getLength();\n    const data = apdu.slice(\n      frameOffset,\n      frameOffset + this._frameSize - header.getLength(),\n    );\n    const frameData = this._padding\n      ? new Uint8Array(dataMaxSize).fill(0)\n      : new Uint8Array(data.length < dataMaxSize ? data.length : dataMaxSize);\n    frameData.set(data, 0);\n    const frame = new Frame({\n      header,\n      data: frameData,\n    });\n    return Right(frame);\n  }\n\n  /**\n   * Get frame header\n   * @param frameIndex\n   * @param apduSize\n   * @private\n   */\n  private getFrameHeaderFrom(\n    frameIndex: number,\n    apduSize: number,\n  ): FrameHeader {\n    const header = new FrameHeader({\n      uuid: v4(),\n      channel: this._channel.map((channel) =>\n        FramerUtils.getLastBytesFrom(channel, CHANNEL_LENGTH),\n      ),\n      headTag: new Uint8Array([HEAD_TAG]),\n      index: FramerUtils.numberToByteArray(frameIndex, INDEX_LENGTH),\n      length: this.getFrameHeaderSizeFromIndex(frameIndex),\n      dataSize: Maybe.zero(),\n    });\n    if (frameIndex === 0) {\n      header.setDataSize(\n        Maybe.of(\n          FramerUtils.numberToByteArray(apduSize, APDU_DATA_LENGTH_LENGTH),\n        ),\n      );\n    }\n    return header;\n  }\n\n  /**\n   * Get frame offset\n   * First frame has more bytes of header\n   * Padding append means a 0 bytes is added at the end of each frame\n   * @private\n   * @param frameIndex\n   */\n  private getHeaderSizeSumFrom(frameIndex: number): number {\n    let sum = this.getFrameHeaderSizeFromIndex(0);\n    let i = 1;\n    while (i < frameIndex) {\n      sum += this.getFrameHeaderSizeFromIndex(i);\n      i += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Get frame header size\n   * @private\n   * @param frameIndex\n   */\n  private getFrameHeaderSizeFromIndex(frameIndex: number): number {\n    return (\n      this._channel.caseOf({\n        Just: () => CHANNEL_LENGTH,\n        Nothing: () => 0,\n      }) +\n      INDEX_LENGTH +\n      HEAD_TAG_LENGTH +\n      (frameIndex === 0 ? APDU_DATA_LENGTH_LENGTH : 0)\n    );\n  }\n}\n"],
  "mappings": "okBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,8BAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAmC,qBACnCC,EAA2C,qBAC3CC,EAAmB,gBAEnBC,EAMO,gDAKPC,EAA4B,iDAE5BC,EAGO,iDACPC,EAAsB,gDACtBC,EAA4B,sDAC5BC,EAA4B,qDAQrB,IAAMC,EAAN,KAA4D,CACvD,WACA,SACA,SACF,QAUR,YACE,CACE,UAAAC,EACA,QAAAC,EAAU,QAAM,KAAK,EACrB,QAAAC,EAAU,EACZ,EAEAC,EACA,CACA,KAAK,WAAaH,EAClB,KAAK,SAAWC,EAChB,KAAK,SAAWC,EAChB,KAAK,QAAUC,EAAqB,0BAA0B,CAChE,CAOO,UAAUC,EAA2B,CAC1C,MAAMC,EAAkB,CAAC,EACzB,IAAIC,EAAQ,EACRC,EAAQ,KAAK,gBAAgBH,EAAME,CAAK,EAE5C,KAAOC,EAAM,QAAQ,GACnBF,EAAO,KAAKE,EAAM,QAAQ,CAAC,EAC3BD,GAAS,EACTC,EAAQ,KAAK,gBAAgBH,EAAME,CAAK,EAAE,QAASE,IAC7CA,aAAiB,uBAGnB,KAAK,QAAQ,MAAM,4BAA6B,CAAE,KAAM,CAAE,MAAAA,CAAM,CAAE,CAAC,EAE9DA,EACR,EAEH,OAAOH,CACT,CASQ,gBACND,EACAK,EACyB,CACzB,MAAMC,EAAS,KAAK,mBAAmBD,EAAYL,EAAK,MAAM,EACxDO,EACJF,IAAe,EACX,EACAA,EAAa,KAAK,WAAa,KAAK,qBAAqBA,CAAU,EAEzE,GAAIE,GAAeP,EAAK,OACtB,SAAO,QAAK,IAAI,qBAAqB,EAEvC,GAAIM,EAAO,UAAU,EAAI,KAAK,WAC5B,SAAO,QAAK,IAAI,iBAAiB,EAEnC,MAAME,EAAc,KAAK,WAAaF,EAAO,UAAU,EACjDG,EAAOT,EAAK,MAChBO,EACAA,EAAc,KAAK,WAAaD,EAAO,UAAU,CACnD,EACMI,EAAY,KAAK,SACnB,IAAI,WAAWF,CAAW,EAAE,KAAK,CAAC,EAClC,IAAI,WAAWC,EAAK,OAASD,EAAcC,EAAK,OAASD,CAAW,EACxEE,EAAU,IAAID,EAAM,CAAC,EACrB,MAAMN,EAAQ,IAAI,QAAM,CACtB,OAAAG,EACA,KAAMI,CACR,CAAC,EACD,SAAO,SAAMP,CAAK,CACpB,CAQQ,mBACNE,EACAM,EACa,CACb,MAAML,EAAS,IAAI,cAAY,CAC7B,QAAM,MAAG,EACT,QAAS,KAAK,SAAS,IAAKT,GAC1B,cAAY,iBAAiBA,EAAS,gBAAc,CACtD,EACA,QAAS,IAAI,WAAW,CAAC,UAAQ,CAAC,EAClC,MAAO,cAAY,kBAAkBQ,EAAY,cAAY,EAC7D,OAAQ,KAAK,4BAA4BA,CAAU,EACnD,SAAU,QAAM,KAAK,CACvB,CAAC,EACD,OAAIA,IAAe,GACjBC,EAAO,YACL,QAAM,GACJ,cAAY,kBAAkBK,EAAU,yBAAuB,CACjE,CACF,EAEKL,CACT,CASQ,qBAAqBD,EAA4B,CACvD,IAAIO,EAAM,KAAK,4BAA4B,CAAC,EACxCC,EAAI,EACR,KAAOA,EAAIR,GACTO,GAAO,KAAK,4BAA4BC,CAAC,EACzCA,GAAK,EAEP,OAAOD,CACT,CAOQ,4BAA4BP,EAA4B,CAC9D,OACE,KAAK,SAAS,OAAO,CACnB,KAAM,IAAM,iBACZ,QAAS,IAAM,CACjB,CAAC,EACD,eACA,mBACCA,IAAe,EAAI,0BAA0B,EAElD,CACF,EA5JaV,EAANmB,EAAA,IADN,cAAW,EAqBPC,EAAA,eAAO,cAAY,6BAA6B,IApBxCpB",
  "names": ["DefaultApduSenderService_exports", "__export", "DefaultApduSenderService", "__toCommonJS", "import_inversify", "import_purify_ts", "import_uuid", "import_FramerConst", "import_FramerUtils", "import_Errors", "import_Frame", "import_FrameHeader", "import_loggerTypes", "DefaultApduSenderService", "frameSize", "channel", "padding", "loggerServiceFactory", "apdu", "frames", "count", "frame", "error", "frameIndex", "header", "frameOffset", "dataMaxSize", "data", "frameData", "apduSize", "sum", "i", "__decorateClass", "__decorateParam"]
}
