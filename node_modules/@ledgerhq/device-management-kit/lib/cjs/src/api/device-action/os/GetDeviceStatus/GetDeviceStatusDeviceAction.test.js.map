{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction.test.ts"],
  "sourcesContent": ["import { interval, Observable } from \"rxjs\";\n\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport {\n  GLOBAL_ERRORS,\n  GlobalCommandError,\n} from \"@api/command/utils/GlobalCommandError\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport {\n  DeviceLockedError,\n  DeviceNotOnboardedError,\n  UnknownDAError,\n} from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\n\nimport { GetDeviceStatusDeviceAction } from \"./GetDeviceStatusDeviceAction\";\nimport { type GetDeviceStatusDAState } from \"./types\";\n\ndescribe(\"GetDeviceStatusDeviceAction\", () => {\n  const getAppAndVersionMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const waitForDeviceUnlockMock = vi.fn();\n  const setDeviceSessionState = vi.fn();\n  const isDeviceOnboardedMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      getAppAndVersion: getAppAndVersionMock,\n      getDeviceSessionState: getDeviceSessionStateMock,\n      waitForDeviceUnlock: waitForDeviceUnlockMock,\n      setDeviceSessionState: setDeviceSessionState,\n      isDeviceOnboarded: isDeviceOnboardedMock,\n    };\n  }\n\n  const {\n    sendCommand: sendCommandMock,\n    getDeviceSessionState: apiGetDeviceSessionStateMock,\n    getDeviceSessionStateObservable: apiGetDeviceSessionStateObservableMock,\n  } = makeDeviceActionInternalApiMock();\n  beforeEach(() => {\n    vi.resetAllMocks();\n    isDeviceOnboardedMock.mockReturnValue(true);\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should run the device action with an unlocked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          deviceModelId: DeviceModelId.NANO_X,\n        });\n\n        sendCommandMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with a locked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 1500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should timeout with a locked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 200 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new DeviceLockedError(\"Device locked.\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with an old firmware not supporting GetAppAndVersion\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          deviceModelId: DeviceModelId.NANO_X,\n        });\n\n        sendCommandMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new GlobalCommandError({\n              ...GLOBAL_ERRORS[\"6e00\"],\n              errorCode: \"6e00\",\n            }),\n          }),\n        );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"0.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should return the device status if the device is unlocked\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: undefined },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: () => {\n              // Session should be updated with current app\n              expect(setDeviceSessionState).toHaveBeenCalledWith({\n                sessionStateType:\n                  DeviceSessionStateType.ReadyWithoutSecureChannel,\n                deviceStatus: DeviceStatus.CONNECTED,\n                currentApp: {\n                  name: \"BOLOS\",\n                  version: \"1.0.0\",\n                },\n              });\n              resolve();\n            },\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should return the device status and update session if the device is not ready\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: undefined },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: () => {\n              // Session should be set as ready if GetAppAndVersionCommand was successful\n              expect(setDeviceSessionState).toHaveBeenCalledWith({\n                sessionStateType:\n                  DeviceSessionStateType.ReadyWithoutSecureChannel,\n                deviceStatus: DeviceStatus.CONNECTED,\n                currentApp: {\n                  name: \"BOLOS\",\n                  version: \"1.0.0\",\n                },\n                installedApps: [],\n                isSecureConnectionAllowed: false,\n              });\n              resolve();\n            },\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should return the device status if the device is locked and the user unlocks the device\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(50).subscribe({\n                next: (i) => {\n                  if (i > 2) {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.CONNECTED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                    o.complete();\n                  } else {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.LOCKED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                  }\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"errors cases\", () => {\n    it(\"should end in an error if the device is not onboarded\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n        isDeviceOnboardedMock.mockReturnValue(false);\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            error: new DeviceNotOnboardedError(),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the device is locked and the user does not unlock\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new GlobalCommandError({\n              ...GLOBAL_ERRORS[\"5515\"],\n              errorCode: \"5515\",\n            }),\n          }),\n        );\n\n        apiGetDeviceSessionStateObservableMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(200).subscribe({\n                next: () => {\n                  o.next({\n                    sessionStateType:\n                      DeviceSessionStateType.ReadyWithoutSecureChannel,\n                    deviceStatus: DeviceStatus.LOCKED,\n                    currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n                    installedApps: [],\n                    deviceModelId: DeviceModelId.NANO_X,\n                    isSecureConnectionAllowed: false,\n                  });\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new DeviceLockedError(\"Device locked.\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the GetAppAndVersion command fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        const error = new GlobalCommandError({\n          ...GLOBAL_ERRORS[\"5501\"],\n          errorCode: \"5501\",\n        });\n\n        getAppAndVersionMock.mockResolvedValue(CommandResultFactory({ error }));\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(50).subscribe({\n                next: (i) => {\n                  if (i > 2) {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.CONNECTED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                    o.complete();\n                  } else {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.LOCKED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                  }\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error,\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockImplementation(() => {\n          throw new UnknownDAError(\"error\");\n        });\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              o.complete();\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new UnknownDAError(\"error\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  it(\"should emit a stopped state if the action is cancelled\", () =>\n    new Promise<void>((resolve, reject) => {\n      apiGetDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        installedApps: [],\n        deviceModelId: DeviceModelId.NANO_X,\n        isSecureConnectionAllowed: false,\n      });\n\n      sendCommandMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            name: \"BOLOS\",\n            version: \"1.0.0\",\n          },\n        }),\n      );\n\n      const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n        input: { unlockTimeout: 500 },\n      });\n\n      const expectedStates: Array<GetDeviceStatusDAState> = [\n        {\n          status: DeviceActionStatus.Pending, // get app and version\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Stopped,\n        },\n      ];\n\n      const { cancel } = testDeviceActionStates(\n        getDeviceStateDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n      cancel();\n    }));\n});\n"],
  "mappings": "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",
  "names": ["import_rxjs", "import_CommandResult", "import_GlobalCommandError", "import_DeviceModel", "import_DeviceStatus", "import_makeInternalApi", "import_testDeviceActionStates", "import_DeviceActionState", "import_UserInteractionRequired", "import_Errors", "import_DeviceSessionState", "import_GetDeviceStatusDeviceAction", "getAppAndVersionMock", "getDeviceSessionStateMock", "waitForDeviceUnlockMock", "setDeviceSessionState", "isDeviceOnboardedMock", "extractDependenciesMock", "sendCommandMock", "apiGetDeviceSessionStateMock", "apiGetDeviceSessionStateObservableMock", "resolve", "reject", "getDeviceStateDeviceAction", "expectedStates", "o", "inner", "i", "error", "cancel"]
}
