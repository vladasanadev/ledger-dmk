"use strict";var v=require("rxjs"),a=require("../../../command/model/CommandResult"),d=require("../../../command/utils/GlobalCommandError"),O=require("../../../device/DeviceModel"),i=require("../../../device/DeviceStatus"),u=require("../../../device-action/__test-utils__/makeInternalApi"),p=require("../../../device-action/__test-utils__/testDeviceActionStates"),t=require("../../../device-action/model/DeviceActionState"),c=require("../../../device-action/model/UserInteractionRequired"),D=require("../../../device-action/os/Errors"),s=require("../../../device-session/DeviceSessionState"),l=require("./GetDeviceStatusDeviceAction");describe("GetDeviceStatusDeviceAction",()=>{const A=vi.fn(),S=vi.fn(),y=vi.fn(),w=vi.fn(),R=vi.fn();function k(){return{getAppAndVersion:A,getDeviceSessionState:S,waitForDeviceUnlock:y,setDeviceSessionState:w,isDeviceOnboarded:R}}const{sendCommand:h,getDeviceSessionState:V,getDeviceSessionStateObservable:N}=(0,u.makeDeviceActionInternalApiMock)();beforeEach(()=>{vi.resetAllMocks(),R.mockReturnValue(!0)}),describe("without overriding `extractDependencies`",()=>{it("should run the device action with an unlocked device",()=>new Promise((r,o)=>{const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});V.mockReturnValue({sessionStateType:s.DeviceSessionStateType.Connected,deviceStatus:i.DeviceStatus.CONNECTED,deviceModelId:O.DeviceModelId.NANO_X}),h.mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"},status:t.DeviceActionStatus.Completed}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should run the device action with a locked device",()=>new Promise((r,o)=>{const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:1500}});V.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:O.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1}),h.mockResolvedValueOnce((0,a.CommandResultFactory)({error:new d.GlobalCommandError({...d.GLOBAL_ERRORS[5515],errorCode:"5515"})})).mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.UnlockDevice},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"},status:t.DeviceActionStatus.Completed}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should timeout with a locked device",()=>new Promise((r,o)=>{const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:200}});V.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:O.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1}),h.mockResolvedValueOnce((0,a.CommandResultFactory)({error:new d.GlobalCommandError({...d.GLOBAL_ERRORS[5515],errorCode:"5515"})})).mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.UnlockDevice},status:t.DeviceActionStatus.Pending},{error:new D.DeviceLockedError("Device locked."),status:t.DeviceActionStatus.Error}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should run the device action with an old firmware not supporting GetAppAndVersion",()=>new Promise((r,o)=>{const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});V.mockReturnValue({sessionStateType:s.DeviceSessionStateType.Connected,deviceStatus:i.DeviceStatus.CONNECTED,deviceModelId:O.DeviceModelId.NANO_X}),h.mockResolvedValue((0,a.CommandResultFactory)({error:new d.GlobalCommandError({...d.GLOBAL_ERRORS["6e00"],errorCode:"6e00"})}));const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"0.0.0"},status:t.DeviceActionStatus.Completed}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})}))}),describe("success cases",()=>{it("should return the device status if the device is unlocked",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),A.mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:void 0}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{status:t.DeviceActionStatus.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:()=>{expect(w).toHaveBeenCalledWith({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"BOLOS",version:"1.0.0"}}),r()},onError:o})})),it("should return the device status and update session if the device is not ready",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.Connected,deviceStatus:i.DeviceStatus.CONNECTED}),A.mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:void 0}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{status:t.DeviceActionStatus.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:()=>{expect(w).toHaveBeenCalledWith({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"BOLOS",version:"1.0.0"},installedApps:[],isSecureConnectionAllowed:!1}),r()},onError:o})})),it("should return the device status if the device is locked and the user unlocks the device",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),A.mockResolvedValueOnce((0,a.CommandResultFactory)({error:new d.GlobalCommandError({...d.GLOBAL_ERRORS[5515],errorCode:"5515"})})).mockResolvedValueOnce((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}})),y.mockImplementation(()=>new v.Observable(m=>{const C=(0,v.interval)(50).subscribe({next:E=>{E>2?(m.next({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),m.complete()):m.next({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}})}});return()=>{C.unsubscribe()}}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.UnlockDevice},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{status:t.DeviceActionStatus.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})}))}),describe("errors cases",()=>{it("should end in an error if the device is not onboarded",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),R.mockReturnValue(!1);const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{error:new D.DeviceNotOnboardedError,status:t.DeviceActionStatus.Error}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should end in an error if the device is locked and the user does not unlock",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),A.mockResolvedValue((0,a.CommandResultFactory)({error:new d.GlobalCommandError({...d.GLOBAL_ERRORS[5515],errorCode:"5515"})})),N.mockImplementation(()=>new v.Observable(m=>{const C=(0,v.interval)(200).subscribe({next:()=>{m.next({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:O.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1})}});return()=>{C.unsubscribe()}}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.UnlockDevice},status:t.DeviceActionStatus.Pending},{error:new D.DeviceLockedError("Device locked."),status:t.DeviceActionStatus.Error}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should end in an error if the GetAppAndVersion command fails",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}});const e=new d.GlobalCommandError({...d.GLOBAL_ERRORS[5501],errorCode:"5501"});A.mockResolvedValue((0,a.CommandResultFactory)({error:e})),y.mockImplementation(()=>new v.Observable(C=>{const E=(0,v.interval)(50).subscribe({next:T=>{T>2?(C.next({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),C.complete()):C.next({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}})}});return()=>{E.unsubscribe()}}));const n=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});vi.spyOn(n,"extractDependencies").mockReturnValue(k());const m=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{error:e,status:t.DeviceActionStatus.Error}];(0,p.testDeviceActionStates)(n,m,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})})),it("should end in an error if getAppAndVersion actor throws an error",()=>new Promise((r,o)=>{S.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),A.mockImplementation(()=>{throw new D.UnknownDAError("error")}),y.mockImplementation(()=>new v.Observable(m=>{m.complete()}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(k());const n=[{intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None},status:t.DeviceActionStatus.Pending},{error:new D.UnknownDAError("error"),status:t.DeviceActionStatus.Error}];(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o})}))}),it("should emit a stopped state if the action is cancelled",()=>new Promise((r,o)=>{V.mockReturnValue({sessionStateType:s.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:i.DeviceStatus.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:O.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1}),h.mockResolvedValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.0.0"}}));const e=new l.GetDeviceStatusDeviceAction({input:{unlockTimeout:500}}),n=[{status:t.DeviceActionStatus.Pending,intermediateValue:{requiredUserInteraction:c.UserInteractionRequired.None}},{status:t.DeviceActionStatus.Stopped}],{cancel:m}=(0,p.testDeviceActionStates)(e,n,(0,u.makeDeviceActionInternalApiMock)(),{onDone:r,onError:o});m()}))});
//# sourceMappingURL=GetDeviceStatusDeviceAction.test.js.map
