{
  "version": 3,
  "sources": ["../../../../../../src/api/device-action/task/GetFirmwareMetadataTask.test.ts"],
  "sourcesContent": ["import { EitherAsync } from \"purify-ts\";\n\nimport {\n  InvalidGetFirmwareMetadataResponseError,\n  InvalidStatusWordError,\n} from \"@api/command/Errors\";\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { type GetOsVersionResponse } from \"@api/command/os/GetOsVersionCommand\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport {\n  type FinalFirmware,\n  type McuFirmware,\n  type OsuFirmware,\n} from \"@internal/manager-api/model/Firmware\";\nimport { type ManagerApiService } from \"@internal/manager-api/service/ManagerApiService\";\n\nimport { GetFirmwareMetadataTask } from \"./GetFirmwareMetadataTask\";\n\ndescribe(\"GetFirmwareMetadataTask\", () => {\n  const apiMock = makeDeviceActionInternalApiMock();\n  const OS_VERSION = {\n    mcuSephVersion: \"mcu_version\",\n    mcuBootloaderVersion: \"bl_version\",\n    seVersion: \"se_version\",\n  } as GetOsVersionResponse;\n\n  const CUSTOM_IMAGE_SIZE = 97;\n\n  const DEVICE_VERSION = {\n    id: 7,\n  };\n\n  const FIRMWARE_VERSION = {\n    id: 361,\n    version: \"1.6.0\",\n    perso: \"perso_11\",\n  } as FinalFirmware;\n\n  const OSU_VERSION = {\n    id: 362,\n    perso: \"perso_11\",\n  } as OsuFirmware;\n\n  const NEXT_FIRMWARE_VERSION = {\n    id: 363,\n    version: \"1.7.0\",\n    perso: \"perso_11\",\n    mcuVersions: [1],\n  } as FinalFirmware;\n\n  const MCUS = [\n    {\n      id: 3,\n      name: \"other_version\",\n    },\n    {\n      id: 1,\n      name: \"mcu_version\",\n    },\n  ] as McuFirmware[];\n\n  const MANAGER_MOCK = {\n    getDeviceVersion: vi.fn(),\n    getFirmwareVersion: vi.fn(),\n    getLatestFirmwareVersion: vi.fn(),\n    getNextFirmwareVersion: vi.fn(),\n    getMcuList: vi.fn(),\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n\n    apiMock.getManagerApiService.mockReturnValue(\n      MANAGER_MOCK as unknown as ManagerApiService,\n    );\n    MANAGER_MOCK.getDeviceVersion.mockReturnValue(\n      EitherAsync(async () => DEVICE_VERSION),\n    );\n    MANAGER_MOCK.getFirmwareVersion.mockReturnValue(\n      EitherAsync(async () => FIRMWARE_VERSION),\n    );\n    MANAGER_MOCK.getLatestFirmwareVersion.mockReturnValue(\n      EitherAsync(async () => OSU_VERSION),\n    );\n    MANAGER_MOCK.getNextFirmwareVersion.mockReturnValue(\n      EitherAsync(async () => NEXT_FIRMWARE_VERSION),\n    );\n    MANAGER_MOCK.getMcuList.mockReturnValue(EitherAsync(async () => MCUS));\n  });\n\n  it(\"success with no firmware update available\", async () => {\n    // GIVEN\n    apiMock.sendCommand\n      .mockResolvedValueOnce(CommandResultFactory({ data: OS_VERSION }))\n      .mockResolvedValueOnce(CommandResultFactory({ data: CUSTOM_IMAGE_SIZE }));\n    MANAGER_MOCK.getLatestFirmwareVersion.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          deviceVersion: DEVICE_VERSION,\n          firmware: FIRMWARE_VERSION,\n          firmwareVersion: {\n            mcu: \"mcu_version\",\n            bootloader: \"bl_version\",\n            os: \"se_version\",\n            metadata: OS_VERSION,\n          },\n          firmwareUpdateContext: {\n            currentFirmware: FIRMWARE_VERSION,\n            availableUpdate: undefined,\n          },\n          customImage: { size: CUSTOM_IMAGE_SIZE },\n        },\n      }),\n    );\n  });\n\n  it(\"success with a firmware update available\", async () => {\n    // GIVEN\n    apiMock.sendCommand\n      .mockResolvedValueOnce(CommandResultFactory({ data: OS_VERSION }))\n      .mockResolvedValueOnce(\n        CommandResultFactory({ error: new InvalidStatusWordError(\"error\") }),\n      );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          deviceVersion: DEVICE_VERSION,\n          firmware: FIRMWARE_VERSION,\n          firmwareVersion: {\n            mcu: \"mcu_version\",\n            bootloader: \"bl_version\",\n            os: \"se_version\",\n            metadata: OS_VERSION,\n          },\n          firmwareUpdateContext: {\n            currentFirmware: FIRMWARE_VERSION,\n            availableUpdate: {\n              osuFirmware: OSU_VERSION,\n              finalFirmware: NEXT_FIRMWARE_VERSION,\n              mcuUpdateRequired: false,\n            },\n          },\n          customImage: {},\n        },\n      }),\n    );\n    expect(MANAGER_MOCK.getDeviceVersion).toHaveBeenCalledWith(OS_VERSION);\n    expect(MANAGER_MOCK.getFirmwareVersion).toHaveBeenCalledWith(\n      OS_VERSION,\n      DEVICE_VERSION,\n    );\n    expect(MANAGER_MOCK.getLatestFirmwareVersion).toHaveBeenCalledWith(\n      FIRMWARE_VERSION,\n      DEVICE_VERSION,\n    );\n    expect(MANAGER_MOCK.getNextFirmwareVersion).toHaveBeenCalledWith(\n      OSU_VERSION,\n    );\n  });\n\n  it(\"success with a firmware update available and MCU update\", async () => {\n    // GIVEN\n    apiMock.sendCommand\n      .mockResolvedValueOnce(CommandResultFactory({ data: OS_VERSION }))\n      .mockResolvedValueOnce(\n        CommandResultFactory({ error: new InvalidStatusWordError(\"error\") }),\n      );\n    const nextFirmware = {\n      ...NEXT_FIRMWARE_VERSION,\n      mcuVersions: [3],\n    };\n    MANAGER_MOCK.getNextFirmwareVersion.mockReturnValue(\n      EitherAsync(async () => nextFirmware),\n    );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          deviceVersion: DEVICE_VERSION,\n          firmware: FIRMWARE_VERSION,\n          firmwareVersion: {\n            mcu: \"mcu_version\",\n            bootloader: \"bl_version\",\n            os: \"se_version\",\n            metadata: OS_VERSION,\n          },\n          firmwareUpdateContext: {\n            currentFirmware: FIRMWARE_VERSION,\n            availableUpdate: {\n              osuFirmware: OSU_VERSION,\n              finalFirmware: nextFirmware,\n              mcuUpdateRequired: true,\n            },\n          },\n          customImage: {},\n        },\n      }),\n    );\n  });\n\n  it(\"should fail when OS version cannot be retrieved\", async () => {\n    // GIVEN\n    apiMock.sendCommand.mockResolvedValueOnce(\n      CommandResultFactory({ error: new InvalidStatusWordError(\"error\") }),\n    );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({ error: new InvalidStatusWordError(\"error\") }),\n    );\n  });\n\n  it(\"should fail if device version cannot be fetched with InvalidGetFirmwareMetadataResponseError\", async () => {\n    // GIVEN\n    apiMock.sendCommand.mockResolvedValueOnce(\n      CommandResultFactory({ data: OS_VERSION }),\n    );\n    MANAGER_MOCK.getDeviceVersion.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        error: new InvalidGetFirmwareMetadataResponseError(),\n      }),\n    );\n  });\n\n  it(\"should fail if firmware version cannot be fetched with InvalidGetFirmwareMetadataResponseError\", async () => {\n    // GIVEN\n    apiMock.sendCommand.mockResolvedValueOnce(\n      CommandResultFactory({ data: OS_VERSION }),\n    );\n    MANAGER_MOCK.getFirmwareVersion.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetFirmwareMetadataTask(apiMock).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        error: new InvalidGetFirmwareMetadataResponseError(),\n      }),\n    );\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_purify_ts", "import_Errors", "import_CommandResult", "import_makeInternalApi", "import_GetFirmwareMetadataTask", "apiMock", "OS_VERSION", "CUSTOM_IMAGE_SIZE", "DEVICE_VERSION", "FIRMWARE_VERSION", "OSU_VERSION", "NEXT_FIRMWARE_VERSION", "MCUS", "MANAGER_MOCK", "throwE", "result", "nextFirmware"]
}
