{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\nimport {\n  EMPTY,\n  from,\n  interval,\n  mergeMap,\n  type Observable,\n  of,\n  switchMap,\n  take,\n} from \"rxjs\";\nimport { timeout } from \"rxjs/operators\";\nimport { assign, fromObservable, fromPromise, setup } from \"xstate\";\n\nimport { isSuccessCommandResult } from \"@api/command/model/CommandResult\";\nimport {\n  GetAppAndVersionCommand,\n  type GetAppAndVersionCommandResult,\n} from \"@api/command/os/GetAppAndVersionCommand\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { DEFAULT_UNLOCK_TIMEOUT_MS } from \"@api/device-action/os/Const\";\nimport {\n  DeviceLockedError,\n  DeviceNotOnboardedError,\n} from \"@api/device-action/os/Errors\";\nimport { type StateMachineTypes } from \"@api/device-action/xstate-utils/StateMachineTypes\";\nimport {\n  type DeviceActionStateMachine,\n  XStateDeviceAction,\n} from \"@api/device-action/xstate-utils/XStateDeviceAction\";\nimport {\n  type DeviceSessionState,\n  DeviceSessionStateType,\n} from \"@api/device-session/DeviceSessionState\";\n\nimport {\n  type GetDeviceStatusDAError,\n  type GetDeviceStatusDAInput,\n  type GetDeviceStatusDAIntermediateValue,\n  type GetDeviceStatusDAOutput,\n} from \"./types\";\n\ntype GetDeviceStatusMachineInternalState = {\n  readonly onboarded: boolean;\n  readonly locked: boolean;\n  readonly currentApp: string | null;\n  readonly currentAppVersion: string | null;\n  readonly error: GetDeviceStatusDAError | null;\n};\n\nexport type MachineDependencies = {\n  readonly getAppAndVersion: () => Promise<GetAppAndVersionCommandResult>;\n  readonly getDeviceSessionState: () => DeviceSessionState;\n  readonly waitForDeviceUnlock: (args: {\n    input: { unlockTimeout: number };\n  }) => Observable<void>;\n  readonly setDeviceSessionState: (\n    state: DeviceSessionState,\n  ) => DeviceSessionState;\n  readonly isDeviceOnboarded: () => boolean;\n};\n\nexport type ExtractMachineDependencies = (\n  internalApi: InternalApi,\n) => MachineDependencies;\n\nexport class GetDeviceStatusDeviceAction extends XStateDeviceAction<\n  GetDeviceStatusDAOutput,\n  GetDeviceStatusDAInput,\n  GetDeviceStatusDAError,\n  GetDeviceStatusDAIntermediateValue,\n  GetDeviceStatusMachineInternalState\n> {\n  makeStateMachine(\n    internalApi: InternalApi,\n  ): DeviceActionStateMachine<\n    GetDeviceStatusDAOutput,\n    GetDeviceStatusDAInput,\n    GetDeviceStatusDAError,\n    GetDeviceStatusDAIntermediateValue,\n    GetDeviceStatusMachineInternalState\n  > {\n    type types = StateMachineTypes<\n      GetDeviceStatusDAOutput,\n      GetDeviceStatusDAInput,\n      GetDeviceStatusDAError,\n      GetDeviceStatusDAIntermediateValue,\n      GetDeviceStatusMachineInternalState\n    >;\n\n    const {\n      getAppAndVersion,\n      getDeviceSessionState,\n      setDeviceSessionState,\n      waitForDeviceUnlock,\n      isDeviceOnboarded,\n    } = this.extractDependencies(internalApi);\n\n    const unlockTimeout = this.input.unlockTimeout ?? DEFAULT_UNLOCK_TIMEOUT_MS;\n\n    return setup({\n      types: {\n        input: {\n          unlockTimeout,\n        } as types[\"input\"],\n        context: {} as types[\"context\"],\n        output: {} as types[\"output\"],\n      },\n      actors: {\n        getAppAndVersion: fromPromise(getAppAndVersion),\n        waitForDeviceUnlock: fromObservable(waitForDeviceUnlock),\n      },\n      guards: {\n        isDeviceOnboarded: () => isDeviceOnboarded(), // TODO: we don't have this info for now, this can be derived from the \"flags\" obtained in the getVersion command\n        isDeviceLocked: ({ context }) => context._internalState.locked,\n        hasError: ({ context }) => context._internalState.error !== null,\n      },\n      actions: {\n        assignErrorDeviceNotOnboarded: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: new DeviceNotOnboardedError(),\n          }),\n        }),\n        assignErrorDeviceLocked: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: new DeviceLockedError(),\n          }),\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n          },\n        }),\n        assignErrorFromEvent: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: _.event[\"error\"], // NOTE: it should never happen, the error is not typed anymore here\n          }),\n        }),\n        assignNoUserActionNeeded: assign({\n          intermediateValue: (_) =>\n            ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.None,\n            }) satisfies types[\"context\"][\"intermediateValue\"],\n        }),\n        assignUserActionUnlockNeeded: assign({\n          intermediateValue: (_) =>\n            ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            }) satisfies types[\"context\"][\"intermediateValue\"],\n        }),\n      },\n    }).createMachine({\n      /** @xstate-layout N4IgpgJg5mDOIC5QHEwBcAiYBuBLAxmAMpoCGaArrFnoQIL5q4D2AdgHQ0FgBKYpEAJ4BiANoAGALqJQAB2axcTNjJAAPRAFoArAHZx7AIwAmQ7oCcugMyHzANmMAWYwBoQgxI8vsAHOJM+VuLmVj5e2gC+EW6omDjcJORUXPSMLBwA8qwARsykAE4QuKxQAMIAFmD4ANZiUqryisqsqhoImo4O7OGhPj4h5n6Obh4IunZ2RoZ+ena6nYaGUTHoKcRklNTxqc3sWbkFRSUVVbWihtJIII1K6a1aVtoGTxOOjtbv84YjiObik7ofPM7GFDP9jNofMsQLE1olNmsGLsADLMGrFMqVGp1S5yBS3FRXNqaOzadjiHx2KyORbzcRBczmH4IbTOdjaabaKmdGy6XSRaIw1bbdZJLa0MBI9LsVHo45Ys4XBr45r3dps-n0ubaGxgx6PZlWULkkLBGmDCzGYzQ2Ei+HJEVStjsACqsDA+SdrBdrAANmjqmthBA2GB2MVsMxqmG3R6vT7-TU1hJcdcVXciYgglZycYQiYqRTQoZtMynDmbM4aW8rHYzD4BSs4hL7eLuF7Xe7PWk2AmA0GPflmPl2LJfeQAGbDgC2nbjPe9fv7IpTyqaGdAbXmxnZPkMNNM820VuZ+8M7Dsb3MznpwW31sFtpbGwdEo7dFksjorAgADUPYobAnNiIasGGEZRmGT4JC+bY7NKH5fj+-75IBrDAdUCAQfg5DpCmq5XDcqqZmMjgGDY-yGJeejjFRzJ2P47DZoEJb+Hyx42sKz5ioiC7sIh35-gB6QYcIg7DqO45oFO+SztBhCtrxuwCchwlAQqWGsJGOHNPh9SEemhKbogdLsIMTjmPuNF1nYZaOBW+5OPu9l1oCjZCs2ME8Y6fGIb6BC4WwdDYKQuDjtkvq8HAFC+mgokEXi65GeoiBguYZJOPSJa6Hm1hGsyuglkxxiUjYVjXlq7nyaKCI+cpn7+Tp6TBaF4WRXwsAxXFCpiEqBlJS0JFAo4vg+BCe55e8-QFUVVglVShjlWRtZ2FEgqsMwEBwKo1WKXVG5pgNaokmRZmQg4fyLHR7ieCNpjGPyx7aNo6UNo4nGeQpsFKdKax8AIoyJQSg3Ge0L07q9F3+Istk3Qg1IjUaZ7GNS-LlU4H1wt9+3OvseSFBiGFrsDx01mZ15mHooReFaVj0fZ5Jci5zissYIKY3a2NvnxsrVITCrE8RoMdDucxWgx1jpZCELDHDgKTC9jg6mNXKLDSHPcbV3O7LG3bNH2SYioLB3EmCI1-HuVL6Cj4hU6eNjsIVD3UrWfKXVCj5cV5Wvtr5n6CShaFE-1JMkWzPgXpCjh+Faw3Mjq5jdOlJhGvo-RzRr3uvr79VjgFzQtWFpARVFnWxcHQNCylCBm+eKPjJL4jWMEdNww4O46vSFVsfyD5Nlj3na9KRAUPghCwPAIdV20QIR7e-RzOYbNK98cN7ndgR-BSzgo+YmdfYPOfSgAovkQ75MbyVtItehmSrJgcijz2uHD+pmXyQSQnyVLs2tQA */\n      id: \"GetDeviceStatusDeviceAction\",\n      initial: \"DeviceReady\",\n      context: (_) => {\n        const sessionState = getDeviceSessionState();\n        const { sessionStateType } = sessionState;\n        return {\n          input: {\n            unlockTimeout: _.input.unlockTimeout,\n          },\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n          _internalState: {\n            onboarded: false, // we don't know how to check yet\n            locked: false,\n            currentApp:\n              sessionStateType ===\n              DeviceSessionStateType.ReadyWithoutSecureChannel\n                ? sessionState.currentApp.name\n                : null,\n            currentAppVersion: null,\n            error: null,\n          },\n        };\n      },\n      states: {\n        DeviceReady: {\n          always: {\n            target: \"OnboardingCheck\",\n          },\n        },\n        OnboardingCheck: {\n          // TODO: we don't have this info for now\n          always: [\n            {\n              guard: {\n                type: \"isDeviceOnboarded\",\n              },\n              target: \"AppAndVersionCheck\",\n              actions: assign({\n                _internalState: (_) => ({\n                  ..._.context._internalState,\n                  onboarded: true,\n                }),\n              }),\n            },\n            {\n              target: \"Error\",\n              actions: \"assignErrorDeviceNotOnboarded\",\n            },\n          ],\n        },\n        UserActionUnlockDevice: {\n          // we wait for the device to be unlocked (default timeout is 15s)\n          entry: \"assignUserActionUnlockNeeded\",\n          exit: \"assignNoUserActionNeeded\",\n          invoke: {\n            id: \"UserActionUnlockDevice\",\n            src: \"waitForDeviceUnlock\",\n            input: (_) => ({\n              unlockTimeout,\n            }),\n            onDone: {\n              target: \"AppAndVersionCheck\",\n              actions: assign({\n                _internalState: (_) => ({\n                  ..._.context._internalState,\n                  locked: false,\n                }),\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorDeviceLocked\",\n            },\n          },\n        },\n        AppAndVersionCheck: {\n          // We check the current app and version using the getAppAndVersion command\n          invoke: {\n            src: \"getAppAndVersion\",\n            onDone: {\n              target: \"ApplicationAvailableResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (isSuccessCommandResult(_.event.output)) {\n                    const state: DeviceSessionState = getDeviceSessionState();\n                    if (\n                      state.sessionStateType !==\n                      DeviceSessionStateType.Connected\n                    ) {\n                      // Update the current app\n                      setDeviceSessionState({\n                        ...state,\n                        currentApp: _.event.output.data,\n                      });\n                    } else {\n                      // The device can be set to Ready if GetAppAndVersionCommand was successful\n                      setDeviceSessionState({\n                        deviceModelId: state.deviceModelId,\n                        sessionStateType:\n                          DeviceSessionStateType.ReadyWithoutSecureChannel,\n                        deviceStatus: DeviceStatus.CONNECTED,\n                        currentApp: _.event.output.data,\n                        installedApps: [],\n                        isSecureConnectionAllowed: false,\n                      });\n                    }\n                    return {\n                      ..._.context._internalState,\n                      locked: false,\n                      currentApp: _.event.output.data.name,\n                      currentAppVersion: _.event.output.data.version,\n                    };\n                  }\n                  if (\"errorCode\" in _.event.output.error) {\n                    if (_.event.output.error.errorCode === \"5515\") {\n                      // Locked device error\n                      return {\n                        ..._.context._internalState,\n                        locked: true,\n                      };\n                    } else if (_.event.output.error.errorCode === \"6e00\") {\n                      // CLA not supported\n                      // GetAppAndVersion should always be supported by the firmware or any app.\n                      // But on old firmware versions, that APDU was not supported in the dashboard.\n                      // On those firmwares, it fails with CLA_NOT_SUPPORTED in BOLOS, and INS_NOT_SUPPORTED\n                      // in applications. Therefore if CLA is not supported, we can consider we're on the\n                      // dashboard on an old firmware. We should therefore return that information to\n                      // ensure the user can still update his firmware and is not blocked at this step.\n                      return {\n                        ..._.context._internalState,\n                        locked: false,\n                        currentApp: \"BOLOS\",\n                        currentAppVersion: \"0.0.0\",\n                      };\n                    }\n                  }\n                  return {\n                    ..._.context._internalState,\n                    error: _.event.output.error,\n                  };\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        ApplicationAvailableResultCheck: {\n          always: [\n            {\n              guard: \"hasError\",\n              target: \"Error\",\n            },\n            {\n              target: \"UserActionUnlockDevice\",\n              guard: \"isDeviceLocked\",\n            },\n            {\n              target: \"Success\",\n            },\n          ],\n        },\n        Success: {\n          type: \"final\",\n        },\n        Error: {\n          type: \"final\",\n        },\n      },\n      output: (args) => {\n        // TODO: instead we should rely on the current state (\"Success\" or \"Error\")\n        const { context } = args;\n        const { error, currentApp, currentAppVersion } = context._internalState;\n        if (error) {\n          return Left(error);\n        }\n        return Right<GetDeviceStatusDAOutput>({\n          currentApp: currentApp!,\n          currentAppVersion: currentAppVersion!,\n        });\n      },\n    });\n  }\n\n  extractDependencies(internalApi: InternalApi): MachineDependencies {\n    const getAppAndVersion = () => {\n      return internalApi.sendCommand(new GetAppAndVersionCommand());\n    };\n\n    const waitForDeviceUnlock = ({\n      input,\n    }: {\n      input: { unlockTimeout: number };\n    }) =>\n      interval(1000).pipe(\n        switchMap(() =>\n          from(internalApi.sendCommand(new GetAppAndVersionCommand())),\n        ),\n        mergeMap((output) => {\n          const isLocked =\n            !isSuccessCommandResult(output) &&\n            \"errorCode\" in output.error &&\n            output.error.errorCode === \"5515\";\n          if (isLocked) {\n            return EMPTY; // Continue the polling\n          }\n          return of(undefined); // Complete the observable\n        }),\n        take(1),\n        timeout(input.unlockTimeout),\n      );\n\n    return {\n      getAppAndVersion,\n      waitForDeviceUnlock,\n      getDeviceSessionState: () => internalApi.getDeviceSessionState(),\n      setDeviceSessionState: (state: DeviceSessionState) =>\n        internalApi.setDeviceSessionState(state),\n      isDeviceOnboarded: () => true, // TODO: we don't have this info for now\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["GetDeviceStatusDeviceAction_exports", "__export", "GetDeviceStatusDeviceAction", "__toCommonJS", "import_purify_ts", "import_rxjs", "import_operators", "import_xstate", "import_CommandResult", "import_GetAppAndVersionCommand", "import_DeviceStatus", "import_UserInteractionRequired", "import_Const", "import_Errors", "import_XStateDeviceAction", "import_DeviceSessionState", "internalApi", "getAppAndVersion", "getDeviceSessionState", "setDeviceSessionState", "waitForDeviceUnlock", "isDeviceOnboarded", "unlockTimeout", "context", "_", "sessionState", "sessionStateType", "state", "args", "error", "currentApp", "currentAppVersion", "input", "output"]
}
