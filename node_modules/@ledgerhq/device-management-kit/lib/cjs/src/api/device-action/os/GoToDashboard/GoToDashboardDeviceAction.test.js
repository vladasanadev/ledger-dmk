"use strict";var a=require("../../../command/model/CommandResult"),h=require("../../../command/utils/GlobalCommandError"),S=require("../../../device/DeviceModel"),c=require("../../../device/DeviceStatus"),s=require("../../../device-action/__test-utils__/makeInternalApi"),d=require("../../../device-action/__test-utils__/setupTestMachine"),u=require("../../../device-action/__test-utils__/testDeviceActionStates"),e=require("../../../device-action/model/DeviceActionState"),t=require("../../../device-action/model/UserInteractionRequired"),V=require("../../../device-action/os/Errors"),p=require("../../../device-session/DeviceSessionState"),N=require("../../../../../src"),l=require("./GoToDashboardDeviceAction");vi.mock("@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction");describe("GoToDashboardDeviceAction",()=>{const v=vi.fn(),D=vi.fn(),m=vi.fn(),T=vi.fn();function A(){return{closeApp:v,getAppAndVersion:D,getDeviceSessionState:m,setDeviceSessionState:T}}const{sendCommand:f,getDeviceSessionState:k}=(0,s.makeDeviceActionInternalApiMock)();beforeEach(()=>{vi.resetAllMocks()}),describe("without overriding `extractDependencies`",()=>{it("should run the device action with device already on dashboard",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)();const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});k.mockReturnValue({sessionStateType:p.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:{name:"BOLOS",version:"1.5.0"},installedApps:[],deviceModelId:S.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1});const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{output:void 0,status:e.DeviceActionStatus.Completed}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})})),it("should run the device action with device not on dashboard",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]);const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});k.mockReturnValue({sessionStateType:p.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:{name:"Bitcoin",version:"1.0.0"},installedApps:[],deviceModelId:S.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1}),f.mockResolvedValueOnce((0,a.CommandResultFactory)({data:void 0})).mockResolvedValueOnce((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.5.0"}}));const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{output:void 0,status:e.DeviceActionStatus.Completed}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})}))}),describe("success cases",()=>{it("should success if the device is already on dashboard",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)();const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});m.mockReturnValue({sessionStateType:p.DeviceSessionStateType.Connected,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:{name:"BOLOS",version:"1.5.0"}}),D.mockReturnValue({app:"BOLOS",version:"1.5.0"}),vi.spyOn(n,"extractDependencies").mockReturnValue(A());const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{output:void 0,status:e.DeviceActionStatus.Completed}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})})),it("should success if the device is not on dashboard",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)();const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});vi.spyOn(n,"extractDependencies").mockReturnValue(A()),m.mockReturnValue({sessionStateType:p.DeviceSessionStateType.Connected,deviceStatus:c.DeviceStatus.CONNECTED}),v.mockResolvedValue((0,a.CommandResultFactory)({data:void 0})),D.mockReturnValue((0,a.CommandResultFactory)({data:{name:"BOLOS",version:"1.5.0"}}));const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{output:void 0,status:e.DeviceActionStatus.Completed}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})}))}),describe("error cases",()=>{it("should return an error if GetDeviceStatus return an error",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)([new V.UnknownDAError("Unknown error")]);const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});k.mockReturnValue({sessionStateType:p.DeviceSessionStateType.ReadyWithoutSecureChannel,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:{name:"BOLOS",version:"1.5.0"},installedApps:[],deviceModelId:S.DeviceModelId.NANO_X,isSecureConnectionAllowed:!1});const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{status:e.DeviceActionStatus.Error,error:new V.UnknownDAError("Unknown error")}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})})),describe("not on dashboard",()=>{it("should return an error if closeApp fails",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]);const n=new l.GoToDashboardDeviceAction({input:{}});vi.spyOn(n,"extractDependencies").mockReturnValue(A()),m.mockReturnValue({sessionStateType:p.DeviceSessionStateType.Connected,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:"Bitcoin"}),v.mockReturnValue((0,a.CommandResultFactory)({error:new N.UnknownDeviceExchangeError("Close app failed")}));const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{status:e.DeviceActionStatus.Error,error:new N.UnknownDeviceExchangeError("Close app failed")}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})})),it("should return an error if getAppAndVersion fails",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]);const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}}),o=new h.GlobalCommandError({...h.GLOBAL_ERRORS[5501],errorCode:"5501"});vi.spyOn(n,"extractDependencies").mockReturnValue(A()),m.mockReturnValue({sessionStateType:p.DeviceSessionStateType.Connected,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:"Bitcoin"}),v.mockResolvedValue((0,a.CommandResultFactory)({data:void 0})),D.mockResolvedValue((0,a.CommandResultFactory)({error:o}));const g=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{status:e.DeviceActionStatus.Error,error:o}];(0,u.testDeviceActionStates)(n,g,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})})),it("should return an error if getAppAndVersion does not return an app name",()=>new Promise((r,i)=>{(0,d.setupGetDeviceStatusMock)([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]);const n=new l.GoToDashboardDeviceAction({input:{unlockTimeout:500}});vi.spyOn(n,"extractDependencies").mockReturnValue(A()),m.mockReturnValue({sessionStateType:p.DeviceSessionStateType.Connected,deviceStatus:c.DeviceStatus.CONNECTED,currentApp:"Bitcoin"}),v.mockResolvedValue((0,a.CommandResultFactory)({data:void 0})),D.mockResolvedValue((0,a.CommandResultFactory)({data:{name:null,version:"1.0.0"}}));const o=[{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{intermediateValue:{requiredUserInteraction:t.UserInteractionRequired.None},status:e.DeviceActionStatus.Pending},{status:e.DeviceActionStatus.Error,error:new V.UnknownDAError("currentApp === null")}];(0,u.testDeviceActionStates)(n,o,(0,s.makeDeviceActionInternalApiMock)(),{onDone:r,onError:i})}))})})});
//# sourceMappingURL=GoToDashboardDeviceAction.test.js.map
