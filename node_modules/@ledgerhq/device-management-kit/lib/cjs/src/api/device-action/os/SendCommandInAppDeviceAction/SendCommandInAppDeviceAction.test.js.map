{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/SendCommandInAppDeviceAction/SendCommandInAppDeviceAction.test.ts"],
  "sourcesContent": ["/* eslint @typescript-eslint/consistent-type-imports:0 */\nimport { Left, Right } from \"purify-ts\";\nimport { type Mock } from \"vitest\";\nimport { assign, createMachine } from \"xstate\";\n\nimport { type Apdu } from \"@api/apdu/model/Apdu\";\nimport { ApduBuilder } from \"@api/apdu/utils/ApduBuilder\";\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport {\n  type DeviceActionState,\n  DeviceActionStatus,\n} from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport { OpenAppDeviceAction } from \"@api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction\";\nimport { type Command } from \"@api/types\";\nimport { UnknownDeviceExchangeError } from \"@root/src\";\n\nimport { SendCommandInAppDeviceAction } from \"./SendCommandInAppDeviceAction\";\nimport {\n  type SendCommandInAppDAError,\n  type SendCommandInAppDAIntermediateValue,\n  type SendCommandInAppDAOutput,\n} from \"./SendCommandInAppDeviceActionTypes\";\n\nvi.mock(\n  \"@api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction\",\n  async (importOriginal) => {\n    const original =\n      await importOriginal<\n        typeof import(\"../OpenAppDeviceAction/OpenAppDeviceAction\")\n      >();\n\n    return {\n      ...original,\n      OpenAppDeviceAction: vi.fn(() => ({\n        makeStateMachine: vi.fn(),\n      })),\n    };\n  },\n);\n\nconst setupOpenAppDAMock = (error?: unknown) => {\n  (OpenAppDeviceAction as Mock).mockImplementation(() => ({\n    makeStateMachine: vi.fn().mockImplementation(() =>\n      createMachine({\n        initial: \"pending\",\n        states: {\n          pending: {\n            entry: assign({\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n              },\n            }),\n            after: {\n              0: \"done\",\n            },\n          },\n          done: {\n            type: \"final\",\n          },\n        },\n        output: () => (error ? Left(error) : Right(undefined)),\n      }),\n    ),\n  }));\n};\n\ndescribe(\"SendCommandInAppDeviceAction\", () => {\n  const sendMyCommand = vi.fn();\n\n  const extractDependenciesMock = () => ({\n    sendCommand: sendMyCommand,\n  });\n\n  const { sendCommand: apiSendCommandMock } = makeDeviceActionInternalApiMock();\n\n  const commandParams = {\n    paramString: \"aParameter\",\n    paramNumber: 1234,\n  };\n  const mockedCommandResponse = {\n    aNumber: 5678,\n    aString: \"mockedResponseString\",\n  };\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  describe(\"without mocking extractDependencies\", () => {\n    it(\"should call sendCommand on internalApi with the correct parameters\", async () => {\n      setupOpenAppDAMock();\n      apiSendCommandMock.mockResolvedValue(\n        CommandResultFactory({ data: undefined }),\n      );\n\n      const deviceAction = new SendCommandInAppDeviceAction({\n        input: {\n          command: new TestCommand(commandParams),\n          appName: \"MyApp\",\n          requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n          skipOpenApp: false,\n        },\n      });\n      await new Promise<void>((resolve, reject) => {\n        deviceAction\n          ._execute(makeDeviceActionInternalApiMock())\n          .observable.subscribe({\n            error: () => reject(),\n            complete: () => resolve(),\n            next: () => {},\n          });\n      });\n\n      expect(apiSendCommandMock).toHaveBeenCalledWith(\n        new TestCommand(commandParams),\n      );\n    });\n  });\n\n  describe(\"error cases\", () => {\n    it(\"should error and output the error if the open app fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupOpenAppDAMock(new UnknownDAError(\"Mocked error\"));\n\n        const expectedStates: MyCommandSendCommandDAState[] = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          new SendCommandInAppDeviceAction({\n            input: {\n              command: new TestCommand(commandParams),\n              appName: \"MyApp\",\n              requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n              skipOpenApp: false,\n            },\n          }),\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should error and output an error if the send command fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupOpenAppDAMock();\n\n        sendMyCommand.mockResolvedValue(\n          CommandResultFactory({\n            error: new UnknownDeviceExchangeError(\"Mocked error\"),\n          }),\n        );\n\n        const deviceAction = new SendCommandInAppDeviceAction({\n          input: {\n            command: new TestCommand(commandParams),\n            appName: \"MyApp\",\n            requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            skipOpenApp: false,\n          },\n        });\n\n        vi.spyOn(deviceAction, \"extractDependencies\").mockImplementation(\n          extractDependenciesMock,\n        );\n\n        const expectedStates: MyCommandSendCommandDAState[] = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDeviceExchangeError(\"Mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          deviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should succeed and output the command result if the send command succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupOpenAppDAMock();\n\n        sendMyCommand.mockResolvedValue(\n          CommandResultFactory({ data: mockedCommandResponse }),\n        );\n\n        const deviceAction = new SendCommandInAppDeviceAction({\n          input: {\n            command: new TestCommand(commandParams),\n            appName: \"MyApp\",\n            requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            skipOpenApp: false,\n          },\n        });\n\n        vi.spyOn(deviceAction, \"extractDependencies\").mockImplementation(\n          extractDependenciesMock,\n        );\n\n        const expectedStates: MyCommandSendCommandDAState[] = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: mockedCommandResponse,\n          },\n        ];\n\n        testDeviceActionStates(\n          deviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should succeed while skipping OpenApp\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupOpenAppDAMock();\n\n        sendMyCommand.mockResolvedValue(\n          CommandResultFactory({ data: mockedCommandResponse }),\n        );\n\n        const deviceAction = new SendCommandInAppDeviceAction({\n          input: {\n            command: new TestCommand(commandParams),\n            appName: \"MyApp\",\n            requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            skipOpenApp: true,\n          },\n        });\n\n        vi.spyOn(deviceAction, \"extractDependencies\").mockImplementation(\n          extractDependenciesMock,\n        );\n\n        const expectedStates: MyCommandSendCommandDAState[] = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.VerifyAddress,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: mockedCommandResponse,\n          },\n        ];\n\n        testDeviceActionStates(\n          deviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n});\n\ntype MyCommandResponse = {\n  aNumber: number;\n  aString: string;\n};\n\ntype MyCommandParams = {\n  paramString: string;\n  paramNumber: number;\n};\n\nclass TestCommand implements Command<MyCommandResponse, MyCommandParams> {\n  readonly name = \"testCommand\";\n\n  params: MyCommandParams;\n  constructor(params: MyCommandParams) {\n    this.params = params;\n  }\n  getApdu(): Apdu {\n    return new ApduBuilder({ cla: 0x00, ins: 0x01, p1: 0x02, p2: 0x03 })\n      .add32BitUIntToData(this.params.paramNumber)\n      .addAsciiStringToData(this.params.paramString)\n      .build();\n  }\n  parseResponse() {\n    return CommandResultFactory({ data: { aNumber: 1, aString: \"aString\" } });\n  }\n}\n\ntype MyCommandSendCommandDAState = DeviceActionState<\n  SendCommandInAppDAOutput<MyCommandResponse>,\n  SendCommandInAppDAError<UnknownDAError>,\n  SendCommandInAppDAIntermediateValue<\n    UserInteractionRequired.None | UserInteractionRequired.VerifyAddress\n  >\n>;\n"],
  "mappings": "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",
  "names": ["import_purify_ts", "import_xstate", "import_ApduBuilder", "import_CommandResult", "import_makeInternalApi", "import_testDeviceActionStates", "import_DeviceActionState", "import_UserInteractionRequired", "import_Errors", "import_OpenAppDeviceAction", "import_src", "import_SendCommandInAppDeviceAction", "importOriginal", "setupOpenAppDAMock", "error", "sendMyCommand", "extractDependenciesMock", "apiSendCommandMock", "commandParams", "mockedCommandResponse", "deviceAction", "TestCommand", "resolve", "reject", "expectedStates", "params"]
}
