{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GoToDashboard/GoToDashboardDeviceAction.test.ts"],
  "sourcesContent": ["import { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport {\n  GLOBAL_ERRORS,\n  GlobalCommandError,\n} from \"@api/command/utils/GlobalCommandError\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGetDeviceStatusMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { UnknownDeviceExchangeError } from \"@root/src\";\n\nimport { GoToDashboardDeviceAction } from \"./GoToDashboardDeviceAction\";\nimport { type GoToDashboardDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction\");\n\ndescribe(\"GoToDashboardDeviceAction\", () => {\n  const closeAppMock = vi.fn();\n  const getAppAndVersionMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      closeApp: closeAppMock,\n      getAppAndVersion: getAppAndVersionMock,\n      getDeviceSessionState: getDeviceSessionStateMock,\n      setDeviceSessionState: setDeviceSessionStateMock,\n    };\n  }\n\n  const {\n    sendCommand: sendCommandMock,\n    getDeviceSessionState: apiGetDeviceSessionStateMock,\n  } = makeDeviceActionInternalApiMock();\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should run the device action with device already on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // GetDeviceStatus events (mocked for tests)\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with device not on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(CommandResultFactory({ data: undefined }))\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.5.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should success if the device is already on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n        });\n\n        getAppAndVersionMock.mockReturnValue({\n          app: \"BOLOS\",\n          version: \"1.5.0\",\n        });\n\n        vi.spyOn(\n          goToDashboardDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should success if the device is not on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          goToDashboardDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n        });\n\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        getAppAndVersionMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.5.0\",\n            },\n          }),\n        );\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"error cases\", () => {\n    it(\"should return an error if GetDeviceStatus return an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock([new UnknownDAError(\"Unknown error\")]);\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    describe(\"not on dashboard\", () => {\n      it(\"should return an error if closeApp fails\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: {},\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockReturnValue(\n            CommandResultFactory({\n              error: new UnknownDeviceExchangeError(\"Close app failed\"),\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error: new UnknownDeviceExchangeError(\"Close app failed\"),\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n\n      it(\"should return an error if getAppAndVersion fails\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: { unlockTimeout: 500 },\n          });\n          const error = new GlobalCommandError({\n            ...GLOBAL_ERRORS[\"5501\"],\n            errorCode: \"5501\",\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockResolvedValue(\n            CommandResultFactory({ data: undefined }),\n          );\n          getAppAndVersionMock.mockResolvedValue(\n            CommandResultFactory({\n              error,\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error,\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n\n      it(\"should return an error if getAppAndVersion does not return an app name\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: { unlockTimeout: 500 },\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockResolvedValue(\n            CommandResultFactory({ data: undefined }),\n          );\n          getAppAndVersionMock.mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: null,\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error: new UnknownDAError(\"currentApp === null\"),\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_CommandResult", "import_GlobalCommandError", "import_DeviceModel", "import_DeviceStatus", "import_makeInternalApi", "import_setupTestMachine", "import_testDeviceActionStates", "import_DeviceActionState", "import_UserInteractionRequired", "import_Errors", "import_DeviceSessionState", "import_src", "import_GoToDashboardDeviceAction", "closeAppMock", "getAppAndVersionMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "extractDependenciesMock", "sendCommandMock", "apiGetDeviceSessionStateMock", "resolve", "reject", "goToDashboardDeviceAction", "expectedStates", "error"]
}
