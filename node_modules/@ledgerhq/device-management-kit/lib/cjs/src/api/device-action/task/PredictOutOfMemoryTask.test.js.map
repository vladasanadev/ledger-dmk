{
  "version": 3,
  "sources": ["../../../../../../src/api/device-action/task/PredictOutOfMemoryTask.test.ts"],
  "sourcesContent": ["import semver from \"semver\";\n\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport type { TransportDeviceModel } from \"@api/device-model/model/DeviceModel\";\nimport type { DeviceSessionState } from \"@api/device-session/DeviceSessionState\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport type { Application } from \"@internal/manager-api/model/Application\";\nimport type { FinalFirmware } from \"@internal/manager-api/model/Firmware\";\n\nimport { PredictOutOfMemoryTask } from \"./PredictOutOfMemoryTask\";\n\ndescribe(\"PredictOutOfMemoryTask\", () => {\n  const apiMock = makeDeviceActionInternalApiMock();\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    apiMock.getDeviceModel.mockReturnValue({\n      memorySize: 1569792,\n      getBlockSize: () => 32,\n    } as unknown as TransportDeviceModel);\n  });\n\n  it(\"Success enough memory\", () => {\n    // GIVEN\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      firmwareUpdateContext: {\n        currentFirmware: { bytes: 397824 } as FinalFirmware,\n      },\n      customImage: { size: 51893 },\n      installedApps: [\n        { bytes: 305442 },\n        { bytes: 514598 },\n        { bytes: 271583 },\n      ] as unknown as Application[],\n      installedLanguages: [{ id: 1, size: 20480 }],\n      firmwareVersion: { os: \"2.0.0\" },\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [\n        { bytes: 1324 },\n        { bytes: 6559 },\n      ] as unknown as Application[],\n    }).run();\n\n    // THEN\n    expect(result).toStrictEqual({\n      outOfMemory: false,\n    });\n  });\n\n  it(\"Success not enough memory\", () => {\n    // GIVEN\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      firmwareUpdateContext: {\n        currentFirmware: { bytes: 397824 } as FinalFirmware,\n      },\n      customImage: { size: 51893 },\n      installedApps: [\n        { bytes: 305442 },\n        { bytes: 514598 },\n        { bytes: 271583 },\n      ] as unknown as Application[],\n      installedLanguages: [{ id: 1, size: 20480 }],\n      firmwareVersion: { os: \"2.0.0\" },\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [\n        { bytes: 1324 },\n        { bytes: 6559 },\n        { bytes: 1 },\n      ] as unknown as Application[],\n    }).run();\n\n    // THEN\n    expect(result).toStrictEqual({\n      outOfMemory: true,\n    });\n  });\n\n  it(\"Success enough memory (recent Nano S, 2kB block size)\", () => {\n    // GIVEN\n    apiMock.getDeviceModel.mockReturnValueOnce({\n      memorySize: 12 * 1024,\n      getBlockSize: ({ firmwareVersion }: { firmwareVersion: string }) => {\n        return semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\")\n          ? 4 * 1024\n          : 2 * 1024;\n      },\n    } as unknown as TransportDeviceModel);\n\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      firmwareUpdateContext: {\n        currentFirmware: { bytes: 6 * 1024 } as FinalFirmware,\n      },\n      customImage: { size: 0 },\n      installedApps: [],\n      installedLanguages: [],\n      firmwareVersion: { os: \"2.0.0\" },\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [{ bytes: 6 * 1024 }] as unknown as Application[],\n    }).run();\n\n    // THEN\n    // 6x2kB blocks of total memory (12kB total)\n    //  -3*2kB block for firmware (to fit 6kB)\n    //  -3*2kB block for install plan (to fit 6kB)\n    //  = 0 blocks left, enough memory\n    expect(result).toStrictEqual({\n      outOfMemory: false,\n    });\n  });\n\n  it(\"Success not enough memory (old Nano S, 4kB block size)\", () => {\n    // GIVEN\n    apiMock.getDeviceModel.mockReturnValueOnce({\n      memorySize: 12 * 1024,\n      getBlockSize: ({ firmwareVersion }: { firmwareVersion: string }) => {\n        return semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\")\n          ? 4 * 1024\n          : 2 * 1024;\n      },\n    } as unknown as TransportDeviceModel);\n\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      firmwareUpdateContext: {\n        currentFirmware: { bytes: 6 * 1024 } as FinalFirmware,\n      },\n      customImage: { size: 0 },\n      installedApps: [],\n      installedLanguages: [],\n      firmwareVersion: { os: \"1.0.0\" },\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [{ bytes: 6 * 1024 }] as unknown as Application[],\n    }).run();\n\n    // THEN\n    // 3x4kB blocks of total memory (12kB total)\n    //  -2x4kB block for firmware (to fit 6kB)\n    //  -2x4kB blocks for install plan (to fit 6kB)\n    //  = -1 block left, not enough memory\n    expect(result).toStrictEqual({\n      outOfMemory: true,\n    });\n  });\n\n  it(\"Success undefined sizes\", () => {\n    // GIVEN\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      firmwareUpdateContext: {\n        currentFirmware: { bytes: 397824 } as FinalFirmware,\n      },\n      customImage: {},\n      installedApps: [\n        { bytes: 305442 },\n        { bytes: null },\n        { bytes: 271583 },\n      ] as unknown as Application[],\n      installedLanguages: [],\n      firmwareVersion: { os: \"2.0.0\" },\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [\n        { bytes: 1324 },\n        { bytes: 6559 },\n      ] as unknown as Application[],\n    }).run();\n\n    // THEN\n    expect(result).toStrictEqual({\n      outOfMemory: false,\n    });\n  });\n\n  it(\"Error when device is in incorrect state\", () => {\n    // GIVEN\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.Connected,\n      deviceStatus: DeviceStatus.CONNECTED,\n    } as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [{ bytes: 1324 }] as unknown as Application[],\n    }).run();\n\n    // THEN\n    expect(result).toStrictEqual({\n      error: new UnknownDAError(\"Invalid device state\"),\n    });\n  });\n\n  it(\"Error when device session was not populated\", () => {\n    // GIVEN\n    apiMock.getDeviceSessionState.mockReturnValueOnce({\n      sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n      deviceStatus: DeviceStatus.CONNECTED,\n      installedApps: [],\n    } as unknown as DeviceSessionState);\n\n    // WHEN\n    const result = new PredictOutOfMemoryTask(apiMock, {\n      installPlan: [{ bytes: 1324 }] as unknown as Application[],\n    }).run();\n\n    // THEN\n    expect(result).toStrictEqual({\n      error: new UnknownDAError(\"Device metadata not fetched\"),\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_semver", "import_DeviceStatus", "import_makeInternalApi", "import_Errors", "import_DeviceSessionState", "import_PredictOutOfMemoryTask", "apiMock", "result", "firmwareVersion", "semver"]
}
