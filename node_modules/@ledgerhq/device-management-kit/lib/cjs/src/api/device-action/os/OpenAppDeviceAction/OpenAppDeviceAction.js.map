{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\nimport { assign, fromPromise, setup } from \"xstate\";\n\nimport { isSuccessCommandResult } from \"@api/command/model/CommandResult\";\nimport {\n  CloseAppCommand,\n  type CloseAppCommandResult,\n} from \"@api/command/os/CloseAppCommand\";\nimport {\n  OpenAppCommand,\n  type OpenAppCommandResult,\n} from \"@api/command/os/OpenAppCommand\";\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { DEFAULT_UNLOCK_TIMEOUT_MS } from \"@api/device-action/os/Const\";\nimport { DeviceNotOnboardedError } from \"@api/device-action/os/Errors\";\nimport { GetDeviceStatusDeviceAction } from \"@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction\";\nimport { type StateMachineTypes } from \"@api/device-action/xstate-utils/StateMachineTypes\";\nimport {\n  type DeviceActionStateMachine,\n  XStateDeviceAction,\n} from \"@api/device-action/xstate-utils/XStateDeviceAction\";\nimport {\n  type DeviceSessionState,\n  DeviceSessionStateType,\n} from \"@api/device-session/DeviceSessionState\";\nimport { DeviceDisconnectedWhileSendingError } from \"@api/transport/model/Errors\";\nimport { isDashboardName } from \"@api/utils/AppName\";\n\nimport {\n  type OpenAppDAError,\n  type OpenAppDAInput,\n  type OpenAppDAIntermediateValue,\n  type OpenAppDAOutput,\n} from \"./types\";\n\ntype OpenAppStateMachineInternalState = {\n  readonly currentlyRunningApp: string | null;\n  readonly error: OpenAppDAError | null;\n};\n\nexport type MachineDependencies = {\n  readonly closeApp: () => Promise<CloseAppCommandResult>;\n  readonly openApp: (arg0: {\n    input: { appName: string };\n  }) => Promise<OpenAppCommandResult>;\n  readonly getDeviceSessionState: () => DeviceSessionState;\n  readonly setDeviceSessionState: (state: DeviceSessionState) => void;\n  readonly isDeviceOnboarded: () => boolean;\n};\n\nexport type ExtractMachineDependencies = (\n  internalApi: InternalApi,\n) => MachineDependencies;\n\n/**\n * Opens a given app on the device.\n *\n * It checks if the device is onboarded, unlocked, and which app is currently open.\n * If the current app is the dashboard, it will directly open the requested app.\n * If another app is opened, it will close the current app and open the requested app.\n *\n * Example of usage:\n *\n * ```ts\n * const deviceAction = new OpenAppDeviceAction({\n *    input: {\n *      appName: \"MyApp\",\n *    },\n *  });\n * dmk.executeDeviceAction({ sessionId: \"mySessionId\", deviceAction });\n * ```\n */\nexport class OpenAppDeviceAction extends XStateDeviceAction<\n  OpenAppDAOutput,\n  OpenAppDAInput,\n  OpenAppDAError,\n  OpenAppDAIntermediateValue,\n  OpenAppStateMachineInternalState\n> {\n  makeStateMachine(\n    internalApi: InternalApi,\n  ): DeviceActionStateMachine<\n    OpenAppDAOutput,\n    OpenAppDAInput,\n    OpenAppDAError,\n    OpenAppDAIntermediateValue,\n    OpenAppStateMachineInternalState\n  > {\n    type types = StateMachineTypes<\n      OpenAppDAOutput,\n      OpenAppDAInput,\n      OpenAppDAError,\n      OpenAppDAIntermediateValue,\n      OpenAppStateMachineInternalState\n    >;\n\n    const {\n      closeApp,\n      openApp,\n      getDeviceSessionState,\n      isDeviceOnboarded,\n      setDeviceSessionState,\n    } = this.extractDependencies(internalApi);\n\n    const unlockTimeout = this.input.unlockTimeout ?? DEFAULT_UNLOCK_TIMEOUT_MS;\n\n    const getDeviceStatusMachine = new GetDeviceStatusDeviceAction({\n      input: {\n        unlockTimeout,\n      },\n    }).makeStateMachine(internalApi);\n\n    return setup({\n      types: {\n        input: {} as types[\"input\"],\n        context: {} as types[\"context\"],\n        output: {} as types[\"output\"],\n      },\n      actors: {\n        closeApp: fromPromise(closeApp),\n        openApp: fromPromise(openApp),\n        getDeviceStatus: getDeviceStatusMachine,\n      },\n      guards: {\n        isDeviceOnboarded: () => isDeviceOnboarded(), // TODO: we don't have this info for now, this can be derived from the \"flags\" obtained in the getVersion command\n        isRequestedAppOpen: ({ context }: { context: types[\"context\"] }) => {\n          if (context._internalState.currentlyRunningApp === null) return false;\n          return (\n            context._internalState.currentlyRunningApp === context.input.appName\n          );\n        },\n        isDashboardOpen: ({ context }: { context: types[\"context\"] }) => {\n          if (context._internalState.currentlyRunningApp === null)\n            throw new Error(\"context.currentlyRunningApp === null\");\n          return isDashboardName(context._internalState.currentlyRunningApp);\n        },\n        hasDisconnectedWhileSending: ({ context }) =>\n          context._internalState.error !== null &&\n          context._internalState.error instanceof\n            DeviceDisconnectedWhileSendingError,\n        hasError: ({ context }) => context._internalState.error !== null,\n      },\n      actions: {\n        assignErrorDeviceNotOnboarded: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: new DeviceNotOnboardedError(),\n          }),\n        }),\n        assignUserActionNeededOpenApp: assign({\n          intermediateValue: (_) =>\n            ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            }) satisfies types[\"context\"][\"intermediateValue\"],\n        }),\n        assignNoUserActionNeeded: assign({\n          intermediateValue: (_) =>\n            ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.None,\n            }) satisfies types[\"context\"][\"intermediateValue\"],\n        }),\n        assignErrorFromEvent: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: _.event[\"error\"], // FIXME: add a typeguard\n          }),\n        }),\n        assignNoError: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: null,\n          }),\n        }),\n      },\n    }).createMachine({\n      /** @xstate-layout N4IgpgJg5mDOIC5QHkAOYB2BBVqAiYAbgJYDGYWpALsQPYYB0BJ5ASmAIYQCeAxANoAGALqJQqWrGI16YkAA9EARhWCGADgAsAZm1b1SwUoDspgDQhuiAEzX1DbQE5tJlQDYlm414CsAXz8LNEwcfCIyCmo6RmQMACNaDgAnCGIMKABhAAswUgBrARE5CSkZDDlFBCUPbQYfZx91H0FtTRNjCysEbWM1bTdHAzcfH2q9awCg9GxcZgjKMoZYhOTU9Ozcgv4lUSQQEuloiuUauoamlrbzSxtBNTu7pW1BEe1rJUmQYJmwlkjFgAytHyaUyOXyhV24kkh1ke0q7w8DDcxmqjkM1l6Kh8nUQzR8DEEjjcz3UxKUjiMbk+31Cc3IC2iDCBIPW4K2O2KMLKxwQiKUyNRAwxWKUOJu3TaDFsw28bkExmsgnU-Rp0zp4QZUXoDFCABsyBwylhCBxiHqOHE9WBeBB6GAGGlCLQ8g7abNNf8mfrDcbTebLdaEE7gUbokJhBGuaUjvCbCSCdZNI5UQqhg1cQhNOprAxND4XP0xZTHI01SEPX9GTqfaQw-QTWaLVabWAkklaEkGKgLVQAGadgC2S3Vlfm2sYtfr2H9zaDIbrZQjUb2Bx5cb5CelydTxnT2nFXTcmjUBYTzlazkcE0CX1Hv3HiynfqbgbA7FgAFc9VQNhCV9CMZwqAlQuAWZwHiqbStI0mY+PmdRKNYxLZmKgjvDeUwVg+WpPrgBqLtEjYBi2H7fr+7ICJyq7crGIGIK0LwME8dzJuizzNNYmZeLmAysZ4Ph2KYmiaOWPz0l6Nb4b60R-lsRQ0UB5Qbq0pgMM4FJ8dYx4KpomaOJo6k9G4yHvEhBmYmJGpVhOurSYR9ByVRUL7LRwEKAxYq1PUkGtE8+ZaJmBh1A8hieMh17vFZY64UyeAcLAWQrCkTkAa5Sm8tY-TIkmlJvFojjXuocHysiegvB4JJ6P4t7ujhkmMPFiXJRAqXUYBsLKfRfLZSZyYtHYbF2JmQoaMeIweEmJjHtF9XVowGR6pIFD2dOtr2o6GDOq6I7YRJ80MIty3PtEwZbaGS4iGla50R5CBVYSJkFncbzGC4mYoo4zHlfUCo+KieizfttlHbAK09jJ9C8G2HZdj2RoDkkw51cDiyg+DBHTmdzoORgy4KR167dQ9ghPc8A1vUomZIQqeZksmTw9JoJlA56B3oyd9BkT+qUE+lnW8iohgaDoeioUYpgdBKQu5sz8rEgYxjwaJtX3qjTIc6tZTcxRmzOdGAsbqoagmM8Yr-aTTyOCNpXWAW-TGIMfmO6zNmLHVmNlOtGAOiGO0o2ztke5DGDYxd4ZXXzN3uZU1RPBBjTNM7UtdAWxjqQZ6gqv0LyO9oruPkywe49D7adt2vaI8jauB+796e6dC7TvjLnR11d1x955xJ1cKeIAZ6dGEJqJKk4qqq3ttdF-XIc67zrdue3CLVG4gqZyMpbGG4bhBeoq9b-mB7jaTZYT+JU86sX05z5R2wLxlG78oKYpNKW16mx9x6EkhWdGKTSvXgLrFKSENcbsC4Hwa6i9eQHgQgmCkIlBjKmcEFUY24ejaSTMeCkHxPgYFoBAOAcgA5u1um3XkABaHeEoKEEkKvQwQJ4XjKl6ErIBDUmCenATwA2RM7rknUm4FUhV-oiTJFTCUth05j0xJVFUTxt7sIOssRIKRQRyV4bdWOTNkTqDekqAwbxNDIUzFIhwzhZHVHkf0akZ9rKFx1CyPI6j2SaJjsoUsBIBimB8MMeUZJqFdH6PYDwKYBjwQaEYpRtlOYzlfC2NxS8bB6HsM4RUIwiSH0VNxAy6lkL1EEjTYUtisLn1ISAhuDZZxvhvpsRJmVX51FJFlZ4-Qk5wUYcxR2BTTIGUKtEvCoDpwaMUobbqugUzIg8PmEwIiTJ9yqAMaUW90IngCaIgZcUEpJVUa1Vxoy+GVGMbvZiuVf5IM8CoTZOpNZDL4eQjcIlDLIRRH5FhoxDyIGFMiASe8IoFlGNchaS0waxNqfkepG4tACiMGeQw6IiQeBGncMaMycxEl8eoIFu0fiVPbg87qSE3q6MVBpehPQ4K6G+uoZUJIVB7laNiq+2s4DkRGYTLRygs6GSQtmO4iIaWljgvUBgip-K5RErofOdiYocLBZwHhBzOWSkKqKz6Lw3i6U+QgPchlTB7xTPBeCWVHDYoAMqflIOQWA8AlXuO6KMQylImipgMi4BZzhDIKkpM0FEypRimplXNWyABRMuSRIXjNaKvHQ3h0Q0reCYT+3khGNEKgqIRxgAgBCAA */\n      id: \"OpenAppDeviceAction\",\n      initial: \"DeviceReady\",\n      context: ({ input }) => {\n        const sessionState = getDeviceSessionState();\n        const { sessionStateType } = sessionState;\n        return {\n          input,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n          _internalState: {\n            error: null,\n            currentlyRunningApp:\n              sessionStateType ===\n              DeviceSessionStateType.ReadyWithoutSecureChannel\n                ? sessionState.currentApp.name\n                : null,\n          },\n        };\n      },\n      states: {\n        DeviceReady: {\n          // check device capabilities & status known\n          always: {\n            target: \"OnboardingCheck\",\n          },\n        },\n\n        OnboardingCheck: {\n          // check onboarding status provided by device session\n          always: [\n            {\n              target: \"GetDeviceStatus\",\n              guard: {\n                type: \"isDeviceOnboarded\",\n              },\n            },\n            {\n              target: \"Error\",\n              actions: \"assignErrorDeviceNotOnboarded\",\n            },\n          ],\n        },\n\n        GetDeviceStatus: {\n          // We run the GetDeviceStatus flow to get information about the device state\n          invoke: {\n            id: \"deviceStatus\",\n            src: \"getDeviceStatus\",\n            input: (_) => ({\n              unlockTimeout: _.context.input.unlockTimeout,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) =>\n                  _.event.snapshot.context.intermediateValue,\n              }),\n            },\n            onDone: {\n              target: \"CheckDeviceStatus\",\n              actions: assign({\n                _internalState: (_) => {\n                  return _.event.output.caseOf<OpenAppStateMachineInternalState>(\n                    {\n                      Right: (output) => {\n                        const state: DeviceSessionState =\n                          getDeviceSessionState();\n\n                        if (\n                          state.sessionStateType !==\n                          DeviceSessionStateType.Connected\n                        ) {\n                          setDeviceSessionState({\n                            ...state,\n                            currentApp: {\n                              name: output.currentApp,\n                              version: output.currentAppVersion,\n                            },\n                          });\n                        }\n                        return {\n                          ..._.context._internalState,\n                          currentlyRunningApp: output.currentApp,\n                        };\n                      },\n                      Left: (error) => ({\n                        ..._.context._internalState,\n                        currentlyRunningApp: null,\n                        error,\n                      }),\n                    },\n                  );\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: [\n                assign({\n                  _internalState: (_) => ({\n                    ..._.context._internalState,\n                    currentlyRunningApp: null,\n                  }),\n                }),\n                \"assignErrorFromEvent\",\n              ],\n            },\n          },\n        },\n        CheckDeviceStatus: {\n          // We check the device status to see if we can have an error\n          always: [\n            {\n              target: \"ApplicationReady\",\n              guard: \"isRequestedAppOpen\",\n              // If target app is currently opened, we can ignore errors\n              actions: \"assignNoError\",\n            },\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"DashboardCheck\",\n            },\n          ],\n        },\n\n        DashboardCheck: {\n          // Is the current application the dashboard\n          always: [\n            {\n              target: \"OpenApplication\",\n              guard: \"isDashboardOpen\",\n            },\n            \"CloseApplication\",\n          ],\n        },\n\n        OpenApplication: {\n          // execute openApp command,\n          entry: \"assignUserActionNeededOpenApp\",\n          exit: \"assignNoUserActionNeeded\",\n          invoke: {\n            src: \"openApp\",\n            input: ({ context }) => ({ appName: context.input.appName }),\n            onDone: {\n              target: \"OpenApplicationResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (isSuccessCommandResult(_.event.output)) {\n                    return {\n                      ..._.context._internalState,\n                      currentlyRunningApp: _.context.input.appName,\n                    };\n                  } else {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.output.error,\n                    };\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"OpenApplicationResultCheck\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n\n        OpenApplicationResultCheck: {\n          always: [\n            {\n              // When an APDU triggers a disconnection, some transports may possibly\n              // be closed on device side before the APDU response could be received,\n              // especially on BLE transports.\n              // Therefore when a disconnection occurs while sending, we should verify\n              // the device status because it may have been successfully executed.\n              target: \"GetDeviceStatus\",\n              guard: \"hasDisconnectedWhileSending\",\n            },\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            { target: \"GetDeviceStatus\" },\n          ],\n        },\n\n        CloseApplication: {\n          invoke: {\n            src: \"closeApp\",\n            onDone: {\n              target: \"CloseApplicationResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (isSuccessCommandResult(_.event.output)) {\n                    return {\n                      ..._.context._internalState,\n                      currentlyRunningApp: \"BOLOS\",\n                    };\n                  } else {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.output.error,\n                    };\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        CloseApplicationResultCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            { target: \"OpenApplication\" },\n          ],\n        },\n\n        ApplicationReady: {\n          // application is ready to be used\n          always: \"Success\",\n        },\n\n        // success state\n        Success: {\n          type: \"final\",\n          actions: \"assignNoError\", // TODO, we should not need this\n        },\n\n        // error state\n        Error: {\n          type: \"final\",\n        },\n      },\n      output: ({ context }) =>\n        context._internalState.error // TODO: instead we should rely on the current state (\"Success\" or \"Error\")\n          ? Left(context._internalState.error)\n          : Right(undefined),\n    });\n  }\n\n  extractDependencies(internalApi: InternalApi): MachineDependencies {\n    const closeApp = async () => internalApi.sendCommand(new CloseAppCommand());\n    const openApp = async (arg0: { input: { appName: string } }) =>\n      internalApi.sendCommand(\n        new OpenAppCommand({ appName: arg0.input.appName }),\n      );\n\n    return {\n      closeApp,\n      openApp,\n      getDeviceSessionState: () => internalApi.getDeviceSessionState(),\n      setDeviceSessionState: (state: DeviceSessionState) =>\n        internalApi.setDeviceSessionState(state),\n      isDeviceOnboarded: () => true, // TODO: we don't have this info for now, this can be derived from the \"flags\" obtained in the getVersion command\n    };\n  }\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,yBAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA4B,qBAC5BC,EAA2C,kBAE3CC,EAAuC,4CACvCC,EAGO,2CACPC,EAGO,0CAEPC,EAAwC,4DACxCC,EAA0C,uCAC1CC,EAAwC,wCACxCC,EAA4C,6EAE5CC,EAGO,8DACPC,EAGO,kDACPH,EAAoD,uCACpDI,EAAgC,8BA8CzB,MAAMb,UAA4B,oBAMvC,CACA,iBACEc,EAOA,CASA,KAAM,CACJ,SAAAC,EACA,QAAAC,EACA,sBAAAC,EACA,kBAAAC,EACA,sBAAAC,CACF,EAAI,KAAK,oBAAoBL,CAAW,EAElCM,EAAgB,KAAK,MAAM,eAAiB,4BAE5CC,EAAyB,IAAI,8BAA4B,CAC7D,MAAO,CACL,cAAAD,CACF,CACF,CAAC,EAAE,iBAAiBN,CAAW,EAE/B,SAAO,SAAM,CACX,MAAO,CACL,MAAO,CAAC,EACR,QAAS,CAAC,EACV,OAAQ,CAAC,CACX,EACA,OAAQ,CACN,YAAU,eAAYC,CAAQ,EAC9B,WAAS,eAAYC,CAAO,EAC5B,gBAAiBK,CACnB,EACA,OAAQ,CACN,kBAAmB,IAAMH,EAAkB,EAC3C,mBAAoB,CAAC,CAAE,QAAAI,CAAQ,IACzBA,EAAQ,eAAe,sBAAwB,KAAa,GAE9DA,EAAQ,eAAe,sBAAwBA,EAAQ,MAAM,QAGjE,gBAAiB,CAAC,CAAE,QAAAA,CAAQ,IAAqC,CAC/D,GAAIA,EAAQ,eAAe,sBAAwB,KACjD,MAAM,IAAI,MAAM,sCAAsC,EACxD,SAAO,mBAAgBA,EAAQ,eAAe,mBAAmB,CACnE,EACA,4BAA6B,CAAC,CAAE,QAAAA,CAAQ,IACtCA,EAAQ,eAAe,QAAU,MACjCA,EAAQ,eAAe,iBACrB,sCACJ,SAAU,CAAC,CAAE,QAAAA,CAAQ,IAAMA,EAAQ,eAAe,QAAU,IAC9D,EACA,QAAS,CACP,iCAA+B,UAAO,CACpC,eAAiBC,IAAO,CACtB,GAAGA,EAAE,QAAQ,eACb,MAAO,IAAI,yBACb,EACF,CAAC,EACD,iCAA+B,UAAO,CACpC,kBAAoBA,IACjB,CACC,GAAGA,EAAE,QAAQ,kBACb,wBAAyB,0BAAwB,cACnD,EACJ,CAAC,EACD,4BAA0B,UAAO,CAC/B,kBAAoBA,IACjB,CACC,GAAGA,EAAE,QAAQ,kBACb,wBAAyB,0BAAwB,IACnD,EACJ,CAAC,EACD,wBAAsB,UAAO,CAC3B,eAAiBA,IAAO,CACtB,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,KACjB,EACF,CAAC,EACD,iBAAe,UAAO,CACpB,eAAiBA,IAAO,CACtB,GAAGA,EAAE,QAAQ,eACb,MAAO,IACT,EACF,CAAC,CACH,CACF,CAAC,EAAE,cAAc,CAEf,GAAI,sBACJ,QAAS,cACT,QAAS,CAAC,CAAE,MAAAC,CAAM,IAAM,CACtB,MAAMC,EAAeR,EAAsB,EACrC,CAAE,iBAAAS,CAAiB,EAAID,EAC7B,MAAO,CACL,MAAAD,EACA,kBAAmB,CACjB,wBAAyB,0BAAwB,IACnD,EACA,eAAgB,CACd,MAAO,KACP,oBACEE,IACA,yBAAuB,0BACnBD,EAAa,WAAW,KACxB,IACR,CACF,CACF,EACA,OAAQ,CACN,YAAa,CAEX,OAAQ,CACN,OAAQ,iBACV,CACF,EAEA,gBAAiB,CAEf,OAAQ,CACN,CACE,OAAQ,kBACR,MAAO,CACL,KAAM,mBACR,CACF,EACA,CACE,OAAQ,QACR,QAAS,+BACX,CACF,CACF,EAEA,gBAAiB,CAEf,OAAQ,CACN,GAAI,eACJ,IAAK,kBACL,MAAQF,IAAO,CACb,cAAeA,EAAE,QAAQ,MAAM,aACjC,GACA,WAAY,CACV,WAAS,UAAO,CACd,kBAAoBA,GAClBA,EAAE,MAAM,SAAS,QAAQ,iBAC7B,CAAC,CACH,EACA,OAAQ,CACN,OAAQ,oBACR,WAAS,UAAO,CACd,eAAiBA,GACRA,EAAE,MAAM,OAAO,OACpB,CACE,MAAQI,GAAW,CACjB,MAAMC,EACJX,EAAsB,EAExB,OACEW,EAAM,mBACN,yBAAuB,WAEvBT,EAAsB,CACpB,GAAGS,EACH,WAAY,CACV,KAAMD,EAAO,WACb,QAASA,EAAO,iBAClB,CACF,CAAC,EAEI,CACL,GAAGJ,EAAE,QAAQ,eACb,oBAAqBI,EAAO,UAC9B,CACF,EACA,KAAOE,IAAW,CAChB,GAAGN,EAAE,QAAQ,eACb,oBAAqB,KACrB,MAAAM,CACF,EACF,CACF,CAEJ,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,IACP,UAAO,CACL,eAAiBN,IAAO,CACtB,GAAGA,EAAE,QAAQ,eACb,oBAAqB,IACvB,EACF,CAAC,EACD,sBACF,CACF,CACF,CACF,EACA,kBAAmB,CAEjB,OAAQ,CACN,CACE,OAAQ,mBACR,MAAO,qBAEP,QAAS,eACX,EACA,CACE,OAAQ,QACR,MAAO,UACT,EACA,CACE,OAAQ,gBACV,CACF,CACF,EAEA,eAAgB,CAEd,OAAQ,CACN,CACE,OAAQ,kBACR,MAAO,iBACT,EACA,kBACF,CACF,EAEA,gBAAiB,CAEf,MAAO,gCACP,KAAM,2BACN,OAAQ,CACN,IAAK,UACL,MAAO,CAAC,CAAE,QAAAD,CAAQ,KAAO,CAAE,QAASA,EAAQ,MAAM,OAAQ,GAC1D,OAAQ,CACN,OAAQ,6BACR,WAAS,UAAO,CACd,eAAiBC,MACX,0BAAuBA,EAAE,MAAM,MAAM,EAChC,CACL,GAAGA,EAAE,QAAQ,eACb,oBAAqBA,EAAE,QAAQ,MAAM,OACvC,EAEO,CACL,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,OAAO,KACxB,CAGN,CAAC,CACH,EACA,QAAS,CACP,OAAQ,6BACR,QAAS,sBACX,CACF,CACF,EAEA,2BAA4B,CAC1B,OAAQ,CACN,CAME,OAAQ,kBACR,MAAO,6BACT,EACA,CACE,OAAQ,QACR,MAAO,UACT,EACA,CAAE,OAAQ,iBAAkB,CAC9B,CACF,EAEA,iBAAkB,CAChB,OAAQ,CACN,IAAK,WACL,OAAQ,CACN,OAAQ,8BACR,WAAS,UAAO,CACd,eAAiBA,MACX,0BAAuBA,EAAE,MAAM,MAAM,EAChC,CACL,GAAGA,EAAE,QAAQ,eACb,oBAAqB,OACvB,EAEO,CACL,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,OAAO,KACxB,CAGN,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,4BAA6B,CAC3B,OAAQ,CACN,CACE,OAAQ,QACR,MAAO,UACT,EACA,CAAE,OAAQ,iBAAkB,CAC9B,CACF,EAEA,iBAAkB,CAEhB,OAAQ,SACV,EAGA,QAAS,CACP,KAAM,QACN,QAAS,eACX,EAGA,MAAO,CACL,KAAM,OACR,CACF,EACA,OAAQ,CAAC,CAAE,QAAAD,CAAQ,IACjBA,EAAQ,eAAe,SACnB,QAAKA,EAAQ,eAAe,KAAK,KACjC,SAAM,MAAS,CACvB,CAAC,CACH,CAEA,oBAAoBR,EAA+C,CAOjE,MAAO,CACL,SAPe,SAAYA,EAAY,YAAY,IAAI,iBAAiB,EAQxE,QAPc,MAAOgB,GACrBhB,EAAY,YACV,IAAI,iBAAe,CAAE,QAASgB,EAAK,MAAM,OAAQ,CAAC,CACpD,EAKA,sBAAuB,IAAMhB,EAAY,sBAAsB,EAC/D,sBAAwBc,GACtBd,EAAY,sBAAsBc,CAAK,EACzC,kBAAmB,IAAM,EAC3B,CACF,CACF",
  "names": ["OpenAppDeviceAction_exports", "__export", "OpenAppDeviceAction", "__toCommonJS", "import_purify_ts", "import_xstate", "import_CommandResult", "import_CloseAppCommand", "import_OpenAppCommand", "import_UserInteractionRequired", "import_Const", "import_Errors", "import_GetDeviceStatusDeviceAction", "import_XStateDeviceAction", "import_DeviceSessionState", "import_AppName", "internalApi", "closeApp", "openApp", "getDeviceSessionState", "isDeviceOnboarded", "setDeviceSessionState", "unlockTimeout", "getDeviceStatusMachine", "context", "_", "input", "sessionState", "sessionStateType", "output", "state", "error", "arg0"]
}
