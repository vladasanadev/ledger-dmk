"use strict";var s=require("purify-ts"),g=require("../../command/Errors"),e=require("../../command/model/CommandResult"),c=require("../../device-action/__test-utils__/data"),d=require("../../device-action/__test-utils__/makeInternalApi"),o=require("./GetApplicationsMetadataTask");describe("GetApplicationsMetadataTask",()=>{const t=(0,d.makeDeviceActionInternalApiMock)(),m={id:7},h={id:361,version:"1.6.0",perso:"perso_11"},A={mcu:"mcu_version",bootloader:"bl_version",os:"se_version",metadata:"metadata"},w=[{name:"Ethereum",hash:"hash2",hashCode:"hashCode"},{name:"Language",hash:"hash3",hashCode:"0000000000000000000000000000000000000000000000000000000000000000"}],u=[c.ETH_APP_METADATA],p=[c.BTC_APP_METADATA,c.ETH_APP_METADATA],l=["fr","eng","it"],i={deviceVersion:m,firmware:h,firmwareVersion:A,installedApps:w},n={getAppsByHash:vi.fn(),getAppList:vi.fn(),getLanguagePackages:vi.fn()};beforeEach(()=>{vi.clearAllMocks(),t.sendCommand.mockResolvedValue((0,e.CommandResultFactory)({data:void 0})),t.getManagerApiService.mockReturnValue(n),n.getAppsByHash.mockReturnValue((0,s.EitherAsync)(async()=>u)),n.getAppList.mockReturnValue((0,s.EitherAsync)(async()=>p)),n.getLanguagePackages.mockReturnValue((0,s.EitherAsync)(async()=>l))}),it("Success without updates",async()=>{const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({data:{applications:u,applicationsUpdates:[],installedLanguages:[],catalog:{applications:p,languagePackages:l}}}))}),it("Success without languages",async()=>{t.sendCommand.mockResolvedValueOnce((0,e.CommandResultFactory)({data:{id:1,size:15}})).mockResolvedValueOnce((0,e.CommandResultFactory)({data:{id:2,size:17}}));const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({data:{applications:u,applicationsUpdates:[],installedLanguages:[{id:1,size:15},{id:2,size:17}],catalog:{applications:p,languagePackages:l}}}))}),it("Success with an available update",async()=>{const a={...c.BTC_APP_METADATA,version:"1.0.0"};n.getAppsByHash.mockReturnValue((0,s.EitherAsync)(async()=>[a]));const r=await new o.GetApplicationsMetadataTask(t,i).run();expect(r).toStrictEqual((0,e.CommandResultFactory)({data:{applications:[a],applicationsUpdates:[c.BTC_APP_METADATA],installedLanguages:[],catalog:{applications:p,languagePackages:l}}})),expect(n.getAppsByHash).toHaveBeenCalledWith(["hash2"])}),it("Success with app hash not found",async()=>{n.getAppsByHash.mockReturnValue((0,s.EitherAsync)(async()=>[null]));const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({data:{applications:u,applicationsUpdates:[],installedLanguages:[],catalog:{applications:p,languagePackages:l}}}))}),it("should fail when apps hash cannot by retrieved",async()=>{n.getAppsByHash.mockReturnValueOnce((0,s.EitherAsync)(async({throwE:r})=>{r(new Error("error"))}));const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({error:new g.InvalidStatusWordError("Cannot get the application catalog")}))}),it("should fail when apps list cannot by retrieved",async()=>{n.getAppList.mockReturnValueOnce((0,s.EitherAsync)(async({throwE:r})=>{r(new Error("error"))}));const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({error:new g.InvalidStatusWordError("Cannot get the application catalog")}))}),it("should fail when languages cannot by retrieved",async()=>{n.getLanguagePackages.mockReturnValueOnce((0,s.EitherAsync)(async({throwE:r})=>{r(new Error("error"))}));const a=await new o.GetApplicationsMetadataTask(t,i).run();expect(a).toStrictEqual((0,e.CommandResultFactory)({error:new g.InvalidStatusWordError("Cannot get the languages catalog")}))})});
//# sourceMappingURL=GetApplicationsMetadataTask.test.js.map
