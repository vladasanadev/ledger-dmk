{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction.test.ts"],
  "sourcesContent": ["import { lastValueFrom } from \"rxjs\";\n\nimport { InvalidStatusWordError } from \"@api/command/Errors\";\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGetDeviceStatusMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport {\n  DeviceLockedError,\n  DeviceNotOnboardedError,\n  UnknownDAError,\n} from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { DeviceDisconnectedWhileSendingError } from \"@api/transport/model/Errors\";\n\nimport { OpenAppDeviceAction } from \"./OpenAppDeviceAction\";\nimport type { OpenAppDAError, OpenAppDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction\");\n\ndescribe(\"OpenAppDeviceAction\", () => {\n  const getAppAndVersionMock = vi.fn();\n  const openAppMock = vi.fn();\n  const closeAppMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n  const isDeviceOnboardedMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      getDeviceSessionState: getDeviceSessionStateMock,\n      setDeviceSessionState: setDeviceSessionStateMock,\n      getAppAndVersion: getAppAndVersionMock,\n      openApp: openAppMock,\n      closeApp: closeAppMock,\n      isDeviceOnboarded: isDeviceOnboardedMock,\n    };\n  }\n\n  const { getDeviceSessionState: apiGetDeviceSessionStateMock } =\n    makeDeviceActionInternalApiMock();\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n    isDeviceOnboardedMock.mockReturnValue(true);\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should end if the required application is opened\", () =>\n      new Promise<void>((resolve, reject) => {\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarding status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should end in a success if the app is already opened\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\", unlockTimeout: undefined },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarding status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if the dashboard is open and open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        const { observable } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n\n        lastValueFrom(observable).then(() => {\n          expect(setDeviceSessionStateMock).toHaveBeenCalledWith({\n            deviceStatus: DeviceStatus.CONNECTED,\n            sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n            currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          });\n        });\n      }));\n\n    it(\"should end in a success if disconnection occurs while open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockRejectedValue(\n          new DeviceDisconnectedWhileSendingError(),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if another app is open, close app succeeds and open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n          { currentApp: \"Bitcoin\", currentAppVersion: \"1.0.0\" },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        const { observable } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n\n        lastValueFrom(observable).then(() => {\n          expect(setDeviceSessionStateMock).toHaveBeenCalledWith({\n            currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n            deviceStatus: DeviceStatus.CONNECTED,\n            sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          });\n        });\n      }));\n  });\n\n  describe(\"errors cases\", () => {\n    it(\"should end in an error if the device is not onboarded\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n        isDeviceOnboardedMock.mockReturnValue(false);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            error: new DeviceNotOnboardedError(),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the device is locked\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new DeviceLockedError()]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new DeviceLockedError(),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new InvalidStatusWordError(\"mocked error\")]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the dashboard is open and open app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if disconnection occurs while open app failed\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockRejectedValue(\n          new DeviceDisconnectedWhileSendingError(),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new DeviceDisconnectedWhileSendingError() as OpenAppDAError,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if another app is open, and close app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if another app is open, close app succeeds but open app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new UnknownDAError(\"Unknown error\")]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if openApp actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockImplementation(() => {\n          throw new UnknownDAError(\"Unknown error\");\n        });\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get device onboarded\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if closeApp actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"anApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockImplementation(() => {\n          throw new UnknownDAError(\"Unknown error\");\n        });\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should emit a stopped state if the action is cancelled\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get device onboarded\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Stopped,\n          },\n        ];\n\n        const { cancel } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n        cancel();\n      }));\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_rxjs", "import_Errors", "import_CommandResult", "import_DeviceModel", "import_DeviceStatus", "import_makeInternalApi", "import_setupTestMachine", "import_testDeviceActionStates", "import_DeviceActionState", "import_UserInteractionRequired", "import_DeviceSessionState", "import_OpenAppDeviceAction", "getAppAndVersionMock", "openAppMock", "closeAppMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "isDeviceOnboardedMock", "extractDependenciesMock", "apiGetDeviceSessionStateMock", "resolve", "reject", "openAppDeviceAction", "expectedStates", "observable", "cancel"]
}
