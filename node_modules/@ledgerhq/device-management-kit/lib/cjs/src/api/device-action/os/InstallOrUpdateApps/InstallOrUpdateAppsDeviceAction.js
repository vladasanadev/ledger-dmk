"use strict";var A=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var U=Object.prototype.hasOwnProperty;var V=(i,t)=>{for(var l in t)A(i,l,{get:t[l],enumerable:!0})},T=(i,t,l,c)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of E(t))!U.call(i,o)&&o!==l&&A(i,o,{get:()=>t[o],enumerable:!(c=P(t,o))||c.enumerable});return i};var k=i=>T(A({},"__esModule",{value:!0}),i);var w={};V(w,{InstallOrUpdateAppsDeviceAction:()=>b});module.exports=k(w);var u=require("purify-ts"),n=require("xstate"),s=require("../../../device-action/model/UserInteractionRequired"),x=require("../../../device-action/os/Const"),y=require("../../../device-action/os/Errors"),g=require("../../../device-action/os/GetDeviceMetadata/GetDeviceMetadataDeviceAction"),v=require("../../../device-action/os/GoToDashboard/GoToDashboardDeviceAction"),O=require("../../../device-action/task/BuildAppsInstallPlanTask"),D=require("../../../device-action/task/PredictOutOfMemoryTask"),f=require("../../../device-action/xstate-utils/XStateDeviceAction"),h=require("../../../device-session/DeviceSessionState"),M=require("../../../secure-channel/task/ConnectToSecureChannelTask"),p=require("../../../secure-channel/task/types");class b extends f.XStateDeviceAction{makeStateMachine(t){const{buildInstallPlan:l,predictOutOfMemory:c,installApp:o}=this.extractDependencies(t),r=this.input.unlockTimeout??x.DEFAULT_UNLOCK_TIMEOUT_MS,d=new g.GetDeviceMetadataDeviceAction({input:{unlockTimeout:r,useSecureChannel:!0,forceUpdate:!1}}).makeStateMachine(t),m=new v.GoToDashboardDeviceAction({input:{unlockTimeout:r}}).makeStateMachine(t);return(0,n.setup)({types:{input:{unlockTimeout:r},context:{},output:{}},actors:{updateMetadata:d,buildInstallPlan:(0,n.fromPromise)(l),predictOutOfMemory:(0,n.fromPromise)(c),goToDashboard:m,installApp:(0,n.fromObservable)(o)},guards:{hasError:({context:e})=>e._internalState.error!==null,hasInstallPlan:e=>e.context.intermediateValue.installPlan!==null,hasMoreApps:e=>e.context._internalState.currentIndex<e.context.intermediateValue.installPlan.installPlan.length},actions:{assignErrorFromEvent:(0,n.assign)({_internalState:e=>({...e.context._internalState,error:e.event.error})}),nextAppIndex:(0,n.assign)({_internalState:e=>({...e.context._internalState,currentIndex:e.context._internalState.currentIndex+1})}),cleanupDeviceState:()=>{const e=t.getDeviceSessionState();e.sessionStateType!==h.DeviceSessionStateType.Connected&&t.setDeviceSessionState({...e,installedApps:[],appsUpdates:void 0})}}}).createMachine({id:"InstallOrUpdateAppsDeviceAction",initial:"DeviceReady",context:e=>({input:{applications:e.input.applications,allowMissingApplication:e.input.allowMissingApplication,unlockTimeout:e.input.unlockTimeout},intermediateValue:{requiredUserInteraction:s.UserInteractionRequired.None,installPlan:null},_internalState:{error:null,osVersion:null,currentIndex:0}}),states:{DeviceReady:{always:[{target:"UpdateDeviceMetadata"}]},UpdateDeviceMetadata:{exit:(0,n.assign)({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:s.UserInteractionRequired.None})}),invoke:{id:"updateMetadata",src:"updateMetadata",input:e=>({unlockTimeout:e.context.input.unlockTimeout,useSecureChannel:!0,forceUpdate:!1}),onSnapshot:{actions:(0,n.assign)({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:e.event.snapshot.context.intermediateValue.requiredUserInteraction,deviceId:e.event.snapshot.context.intermediateValue.deviceId??e.context.intermediateValue.deviceId})})},onDone:{target:"UpdateDeviceMetadataCheck",actions:(0,n.assign)({_internalState:e=>e.event.output.caseOf({Right:a=>({...e.context._internalState,osVersion:a.firmwareVersion.metadata}),Left:a=>({...e.context._internalState,error:a})})})},onError:{target:"Error",actions:"assignErrorFromEvent"}}},UpdateDeviceMetadataCheck:{always:[{target:"Error",guard:"hasError"},{target:"Success",guard:"hasInstallPlan"},{target:"BuildInstallPlan"}]},BuildInstallPlan:{invoke:{src:"buildInstallPlan",input:e=>({applications:e.context.input.applications,allowMissingApplication:e.context.input.allowMissingApplication}),onDone:{target:"BuildInstallPlanCheck",actions:(0,n.assign)({_internalState:e=>"error"in e.event.output?{...e.context._internalState,error:e.event.output.error}:e.context._internalState,intermediateValue:e=>"error"in e.event.output?e.context.intermediateValue:{...e.context.intermediateValue,installPlan:{installPlan:e.event.output.installPlan,alreadyInstalled:e.event.output.alreadyInstalled,missingApplications:e.event.output.missingApplications,currentIndex:0,currentProgress:0}}})},onError:{target:"Error",actions:"assignErrorFromEvent"}}},BuildInstallPlanCheck:{always:[{guard:"hasError",target:"Error"},{target:"PredictOutOfMemory",guard:"hasMoreApps"},{target:"Success"}]},PredictOutOfMemory:{invoke:{src:"predictOutOfMemory",input:e=>({installPlan:e.context.intermediateValue.installPlan.installPlan}),onDone:{target:"PredictOutOfMemoryCheck",actions:(0,n.assign)({_internalState:e=>"error"in e.event.output?{...e.context._internalState,error:e.event.output.error}:e.event.output.outOfMemory?{...e.context._internalState,error:new y.OutOfMemoryDAError("Not enough memory for those applications")}:e.context._internalState})},onError:{target:"Error",actions:"assignErrorFromEvent"}}},PredictOutOfMemoryCheck:{always:[{guard:"hasError",target:"Error"},{target:"GoToDashboard"}]},GoToDashboard:{invoke:{id:"goToDashboard",src:"goToDashboard",input:e=>({unlockTimeout:e.context.input.unlockTimeout}),onSnapshot:{actions:(0,n.assign)({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:e.event.snapshot.context.intermediateValue.requiredUserInteraction})})},onDone:{target:"GoToDashboardCheck",actions:(0,n.assign)({_internalState:e=>e.event.output.caseOf({Right:()=>e.context._internalState,Left:a=>({...e.context._internalState,error:a})})})},onError:{target:"Error",actions:"assignErrorFromEvent"}}},GoToDashboardCheck:{always:[{target:"Error",guard:"hasError"},{target:"InstallApp",actions:"cleanupDeviceState"}]},InstallApp:{exit:(0,n.assign)({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:s.UserInteractionRequired.None})}),invoke:{id:"installApp",src:"installApp",input:e=>({osVersion:e.context._internalState.osVersion,application:e.context.intermediateValue.installPlan.installPlan[e.context._internalState.currentIndex]}),onSnapshot:{actions:(0,n.assign)({intermediateValue:e=>{switch(e.event.snapshot.context?.type){case p.SecureChannelEventType.DeviceId:return{...e.context.intermediateValue,deviceId:e.event.snapshot.context.payload.deviceId};case p.SecureChannelEventType.PermissionRequested:return{...e.context.intermediateValue,requiredUserInteraction:s.UserInteractionRequired.AllowSecureConnection};case p.SecureChannelEventType.PermissionGranted:{const a=t.getDeviceSessionState();return a.sessionStateType!==h.DeviceSessionStateType.Connected&&t.setDeviceSessionState({...a,isSecureConnectionAllowed:!0}),{...e.context.intermediateValue,requiredUserInteraction:s.UserInteractionRequired.None}}case p.SecureChannelEventType.Progress:return{...e.context.intermediateValue,installPlan:{...e.context.intermediateValue.installPlan,currentIndex:e.context._internalState.currentIndex,currentProgress:e.event.snapshot.context.payload.progress}};default:return e.context.intermediateValue}},_internalState:e=>e.event.snapshot.context?.type===p.SecureChannelEventType.Error?{...e.context._internalState,error:e.event.snapshot.context.error.mapInstallDAErrors()}:e.context._internalState})},onDone:{target:"InstallAppCheck",actions:"nextAppIndex"},onError:{target:"Error",actions:"assignErrorFromEvent"}}},InstallAppCheck:{always:[{target:"Error",guard:"hasError"},{target:"InstallApp",guard:"hasMoreApps"},{target:"UpdateDeviceMetadata"}]},Success:{type:"final"},Error:{type:"final"}},output:e=>{const{context:a}=e,{error:S}=a._internalState,{installPlan:I}=a.intermediateValue;return S?(0,u.Left)(S):(0,u.Right)({successfullyInstalled:I.installPlan,alreadyInstalled:I.alreadyInstalled,missingApplications:I.missingApplications})}})}extractDependencies(t){return{buildInstallPlan:r=>Promise.resolve(new O.BuildAppsInstallPlanTask(t,{applications:r.input.applications,allowMissingApplication:r.input.allowMissingApplication}).run()),predictOutOfMemory:r=>Promise.resolve(new D.PredictOutOfMemoryTask(t,{installPlan:r.input.installPlan}).run()),installApp:r=>{const{osVersion:d,application:m}=r.input,e=t.getSecureChannelService().installApp(d,m);return new M.ConnectToSecureChannelTask(t,{connection:e}).run()}}}}0&&(module.exports={InstallOrUpdateAppsDeviceAction});
//# sourceMappingURL=InstallOrUpdateAppsDeviceAction.js.map
