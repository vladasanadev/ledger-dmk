{
  "version": 3,
  "sources": ["../../../../../src/api/utils/HexaString.test.ts"],
  "sourcesContent": ["import {\n  bufferToHexaString,\n  hexaStringToBuffer,\n  isHexaString,\n} from \"./HexaString\";\n\ndescribe(\"HexaString\", () => {\n  describe(\"isHexaString function\", () => {\n    it(\"should return true if the value is a valid hex string\", () => {\n      // GIVEN\n      const value = \"0x1234abc\";\n\n      // WHEN\n      const result = isHexaString(value);\n\n      // THEN\n      expect(result).toBeTruthy();\n    });\n\n    it(\"should return true if no data\", () => {\n      // GIVEN\n      const value = \"0x\";\n\n      // WHEN\n      const result = isHexaString(value);\n\n      // THEN\n      expect(result).toBeTruthy();\n    });\n\n    it(\"should return false if the value contain an invalid letter\", () => {\n      // GIVEN\n      const value = \"0x1234z\";\n\n      // WHEN\n      const result = isHexaString(value);\n\n      // THEN\n      expect(result).toBeFalsy();\n    });\n\n    it(\"should return false if the value does not start with 0x\", () => {\n      // GIVEN\n      const value = \"1234abc\";\n\n      // WHEN\n      const result = isHexaString(value);\n\n      // THEN\n      expect(result).toBeFalsy();\n    });\n\n    it(\"should return false for an epmty string\", () => {\n      // GIVEN\n      const value = \"\";\n\n      // WHEN\n      const result = isHexaString(value);\n\n      // THEN\n      expect(result).toBeFalsy();\n    });\n\n    it.each([123, [], {}, null, undefined, true])(\n      \"should return false for invalid input %p\",\n      (value) => {\n        // WHEN\n        const result = isHexaString(value);\n\n        // THEN\n        expect(result).toBeFalsy();\n      },\n    );\n  });\n\n  describe(\"hexaStringToBuffer function\", () => {\n    it(\"should convert empty input to empty buffer\", () => {\n      // GIVEN\n      const value = \"\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(new Uint8Array());\n    });\n\n    it(\"should fail on invalid string\", () => {\n      // GIVEN\n      const value = \"bonjour\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(null);\n    });\n\n    it(\"should fail on invalid string with valid numbers\", () => {\n      // GIVEN\n      const value = \"0x012n34\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(null);\n    });\n\n    it(\"should convert correct hexadecimal string\", () => {\n      // GIVEN\n      const value = \"1a35669f0100\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(\n        new Uint8Array([0x1a, 0x35, 0x66, 0x9f, 0x01, 0x00]),\n      );\n    });\n\n    it(\"should support 0x prefix\", () => {\n      // GIVEN\n      const value = \"0x1a35\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(new Uint8Array([0x1a, 0x35]));\n    });\n\n    it(\"should be case insensitive\", () => {\n      // GIVEN\n      const value = \"0xcCDd\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(new Uint8Array([0xcc, 0xdd]));\n    });\n\n    it(\"should pad with 0\", () => {\n      // GIVEN\n      const value = \"0xa35\";\n\n      // WHEN\n      const result = hexaStringToBuffer(value);\n\n      // THEN\n      expect(result).toStrictEqual(new Uint8Array([0x0a, 0x35]));\n    });\n  });\n\n  describe(\"bufferToHexaString function\", () => {\n    it(\"should convert a buffer into a hexa string\", () => {\n      // GIVEN\n      const value = Uint8Array.from([0, 1, 2, 0xff, 0xfe]);\n\n      // WHEN\n      const result = bufferToHexaString(value);\n\n      // THEN\n      expect(result).toStrictEqual(\"0x000102fffe\");\n    });\n\n    it(\"should convert a buffer into a hexa string without prefix\", () => {\n      // GIVEN\n      const value = Uint8Array.from([0, 1, 2, 0xff, 0xfe]);\n\n      // WHEN\n      const result = bufferToHexaString(value, false);\n\n      // THEN\n      expect(result).toStrictEqual(\"000102fffe\");\n    });\n  });\n});\n"],
  "mappings": "aAAA,IAAAA,EAIO,wBAEP,SAAS,aAAc,IAAM,CAC3B,SAAS,wBAAyB,IAAM,CACtC,GAAG,wDAAyD,IAAM,CAKhE,MAAMC,KAAS,gBAHD,WAGmB,EAGjC,OAAOA,CAAM,EAAE,WAAW,CAC5B,CAAC,EAED,GAAG,gCAAiC,IAAM,CAKxC,MAAMA,KAAS,gBAHD,IAGmB,EAGjC,OAAOA,CAAM,EAAE,WAAW,CAC5B,CAAC,EAED,GAAG,6DAA8D,IAAM,CAKrE,MAAMA,KAAS,gBAHD,SAGmB,EAGjC,OAAOA,CAAM,EAAE,UAAU,CAC3B,CAAC,EAED,GAAG,0DAA2D,IAAM,CAKlE,MAAMA,KAAS,gBAHD,SAGmB,EAGjC,OAAOA,CAAM,EAAE,UAAU,CAC3B,CAAC,EAED,GAAG,0CAA2C,IAAM,CAKlD,MAAMA,KAAS,gBAHD,EAGmB,EAGjC,OAAOA,CAAM,EAAE,UAAU,CAC3B,CAAC,EAED,GAAG,KAAK,CAAC,IAAK,CAAC,EAAG,CAAC,EAAG,KAAM,OAAW,EAAI,CAAC,EAC1C,2CACCC,GAAU,CAET,MAAMD,KAAS,gBAAaC,CAAK,EAGjC,OAAOD,CAAM,EAAE,UAAU,CAC3B,CACF,CACF,CAAC,EAED,SAAS,8BAA+B,IAAM,CAC5C,GAAG,6CAA8C,IAAM,CAKrD,MAAMA,KAAS,sBAHD,EAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,UAAY,CAC/C,CAAC,EAED,GAAG,gCAAiC,IAAM,CAKxC,MAAMA,KAAS,sBAHD,SAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,CACnC,CAAC,EAED,GAAG,mDAAoD,IAAM,CAK3D,MAAMA,KAAS,sBAHD,UAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,CACnC,CAAC,EAED,GAAG,4CAA6C,IAAM,CAKpD,MAAMA,KAAS,sBAHD,cAGyB,EAGvC,OAAOA,CAAM,EAAE,cACb,IAAI,WAAW,CAAC,GAAM,GAAM,IAAM,IAAM,EAAM,CAAI,CAAC,CACrD,CACF,CAAC,EAED,GAAG,2BAA4B,IAAM,CAKnC,MAAMA,KAAS,sBAHD,QAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,WAAW,CAAC,GAAM,EAAI,CAAC,CAAC,CAC3D,CAAC,EAED,GAAG,6BAA8B,IAAM,CAKrC,MAAMA,KAAS,sBAHD,QAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,WAAW,CAAC,IAAM,GAAI,CAAC,CAAC,CAC3D,CAAC,EAED,GAAG,oBAAqB,IAAM,CAK5B,MAAMA,KAAS,sBAHD,OAGyB,EAGvC,OAAOA,CAAM,EAAE,cAAc,IAAI,WAAW,CAAC,GAAM,EAAI,CAAC,CAAC,CAC3D,CAAC,CACH,CAAC,EAED,SAAS,8BAA+B,IAAM,CAC5C,GAAG,6CAA8C,IAAM,CAErD,MAAMC,EAAQ,WAAW,KAAK,CAAC,EAAG,EAAG,EAAG,IAAM,GAAI,CAAC,EAG7CD,KAAS,sBAAmBC,CAAK,EAGvC,OAAOD,CAAM,EAAE,cAAc,cAAc,CAC7C,CAAC,EAED,GAAG,4DAA6D,IAAM,CAEpE,MAAMC,EAAQ,WAAW,KAAK,CAAC,EAAG,EAAG,EAAG,IAAM,GAAI,CAAC,EAG7CD,KAAS,sBAAmBC,EAAO,EAAK,EAG9C,OAAOD,CAAM,EAAE,cAAc,YAAY,CAC3C,CAAC,CACH,CAAC,CACH,CAAC",
  "names": ["import_HexaString", "result", "value"]
}
