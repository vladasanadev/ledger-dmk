{
  "version": 3,
  "sources": ["../../../../../../src/api/apdu/utils/ByteArrayParser.ts"],
  "sourcesContent": ["import { bufferToHexaString, type HexaString } from \"@api/utils/HexaString\";\n\nexport type TaggedField = {\n  readonly tag: number;\n  readonly value: Uint8Array;\n  readonly tlv: Uint8Array;\n};\n\n/**\n * ByteArrayParser is a utility class to help parse a byte array.\n *\n * It provides methods to extract fields of different types from the buffer.\n *\n * @example\n * ```\n * const parser = new ByteArrayParser(buffer);\n * const targetId = parser.encodeToHexaString(parser.extractFieldByLength(4));\n * const seVersion = parser.encodeToString(parser.extractFieldLVEncoded());\n * ```\n */\nexport class ByteArrayParser {\n  private index: number = 0;\n\n  constructor(private readonly buffer: Uint8Array) {}\n\n  // ==========\n  // Public API\n  // ==========\n\n  /**\n   * Test if the length is greater than the response length\n   * @param length: number\n   * @returns {boolean} - Returns false if the length is greater than the response length\n   */\n  testMinimalLength(length: number): boolean {\n    return length <= this.buffer.length - this.index;\n  }\n\n  /**\n   * Extract a single byte from the response\n   * @returns {number | undefined} - Returns the byte extracted from the response\n   */\n  extract8BitUInt(): number | undefined {\n    if (this.outOfRange(1)) return;\n    return this.buffer[this.index++];\n  }\n\n  /**\n   * Extract a 16-bit unsigned integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 16-bit unsigned integer extracted from the response\n   */\n  extract16BitUInt(bigEndian: boolean = true): number | undefined {\n    const value = this.extractNumber(16n, false, bigEndian);\n    return value === undefined ? undefined : Number(value);\n  }\n\n  /**\n   * Extract a 16-bit signed integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 16-bit signed integer extracted from the response\n   */\n  extract16BitInt(bigEndian: boolean = true): number | undefined {\n    const value = this.extractNumber(16n, true, bigEndian);\n    return value === undefined ? undefined : Number(value);\n  }\n\n  /**\n   * Extract a 32-bit unsigned integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 32-bit unsigned integer extracted from the response\n   */\n  extract32BitUInt(bigEndian: boolean = true): number | undefined {\n    const value = this.extractNumber(32n, false, bigEndian);\n    return value === undefined ? undefined : Number(value);\n  }\n\n  /**\n   * Extract a 32-bit signed integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 32-bit signed integer extracted from the response\n   */\n  extract32BitInt(bigEndian: boolean = true): number | undefined {\n    const value = this.extractNumber(32n, true, bigEndian);\n    return value === undefined ? undefined : Number(value);\n  }\n\n  /**\n   * Extract a 64-bit unsigned integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 64-bit unsigned integer extracted from the response\n   */\n  extract64BitUInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(64n, false, bigEndian);\n  }\n\n  /**\n   * Extract a 64-bit signed integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 64-bit signed integer extracted from the response\n   */\n  extract64BitInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(64n, true, bigEndian);\n  }\n\n  /**\n   * Extract a 128-bit unsigned integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 128-bit unsigned integer extracted from the response\n   */\n  extract128BitUInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(128n, false, bigEndian);\n  }\n\n  /**\n   * Extract a 128-bit signed integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 128-bit signed integer extracted from the response\n   */\n  extract128BitInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(128n, true, bigEndian);\n  }\n\n  /**\n   * Extract a 256-bit unsigned integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 256-bit unsigned integer extracted from the response\n   */\n  extract256BitUInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(256n, false, bigEndian);\n  }\n\n  /**\n   * Extract a 256-bit signed integer from the response\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {number | undefined} - Returns the 256-bit signed integer extracted from the response\n   */\n  extract256BitInt(bigEndian: boolean = true): bigint | undefined {\n    return this.extractNumber(256n, true, bigEndian);\n  }\n\n  /**\n   * Extract a field of a specified length from the response\n   * @param length: number - The length of the field to extract\n   * @returns {Uint8Array | undefined} - Returns the field extracted from the response\n   */\n  extractFieldByLength(length: number): Uint8Array | undefined {\n    if (this.outOfRange(length)) return;\n    if (length === 0) return new Uint8Array();\n    const field = this.buffer.slice(this.index, this.index + length);\n    this.index += length;\n    return field;\n  }\n\n  /**\n   * Extract a field from the response that is length-value encoded\n   * @returns {Uint8Array | undefined} - Returns the field extracted from the response\n   */\n  extractFieldLVEncoded(): Uint8Array | undefined {\n    // extract Length field\n    const length = this.extract8BitUInt();\n    if (length === undefined) return;\n    else if (length === 0) return new Uint8Array();\n    const field = this.extractFieldByLength(length);\n    // if the field is inconsistent then roll back to the initial point\n    if (field === undefined) this.index--;\n    return field;\n  }\n\n  /**\n   * Extract a field from the response that is tag-length-value encoded\n   * @returns {TaggedField | undefined} - Returns the field extracted from the response\n   */\n  extractFieldTLVEncoded(): TaggedField | undefined {\n    if (this.outOfRange(2)) return;\n\n    const startIndex = this.index;\n    const tag = this.extract8BitUInt();\n    const value = this.extractFieldLVEncoded();\n\n    if (tag === undefined || value === undefined) {\n      this.index--;\n      return;\n    }\n    const endIndex = this.index;\n    return { tag, value, tlv: this.buffer.slice(startIndex, endIndex) };\n  }\n\n  /**\n   * Encode a value to a hexadecimal string\n   * @param value {Uint8Array} - The value to encode\n   * @param prefix {boolean} - Whether to add a prefix to the encoded value\n   * @returns {string} - The encoded value as a hexadecimal string\n   */\n  encodeToHexaString(value?: Uint8Array, prefix?: false): string;\n  encodeToHexaString(value?: Uint8Array, prefix?: true): HexaString;\n  encodeToHexaString(\n    value?: Uint8Array,\n    prefix: boolean = false,\n  ): HexaString | string {\n    if (value === undefined || value.length === 0) return \"\";\n    const result = bufferToHexaString(value);\n    return prefix ? result : result.slice(2);\n  }\n\n  /**\n   * Encode a value to an ASCII string\n   * @param value {Uint8Array} - The value to encode\n   * @returns {string} - The encoded value as an ASCII string\n   */\n  encodeToString(value?: Uint8Array): string {\n    let result = \"\";\n    let index = 0;\n\n    if (!value) return result;\n\n    while (index <= value.length) {\n      const item = value[index];\n      if (item) result += String.fromCharCode(item);\n      index++;\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the current index of the parser\n   * @returns {number} - The current index of the parser\n   */\n  getCurrentIndex(): number {\n    return this.index;\n  }\n\n  /**\n   * Reset the index of the parser to 0\n   */\n  resetIndex() {\n    this.index = 0;\n  }\n\n  /**\n   * Get the remaining length of the response\n   * @returns {number} - The remaining length of the response\n   */\n  getUnparsedRemainingLength(): number {\n    return this.buffer.length - this.index;\n  }\n\n  // ===========\n  // Private API\n  // ===========\n\n  /**\n   * Check whether the expected length is out of range\n   * @param length: number\n   * @returns {boolean} - Returns true if the expected length is out of range\n   */\n  private outOfRange(length: number): boolean {\n    return this.index + length > this.buffer.length;\n  }\n\n  /**\n   * Extract a number from the buffer\n   * @param sizeInBits: bigint - The number size in bits, for example 16 for a uint16\n   * @param signed: boolean - True is the number can be signed and converted to two's compliment\n   * @param bigEndian: boolean - True to decode in big endian, false for little endian\n   * @returns {bigint | undefined} - Returns the number extracted from the buffer\n   */\n  private extractNumber(\n    sizeInBits: bigint,\n    signed: boolean,\n    bigEndian: boolean,\n  ): bigint | undefined {\n    // Check the range\n    const sizeInBytes: number = Number(sizeInBits) / 8;\n    if (this.outOfRange(sizeInBytes)) return;\n\n    // Compute the number\n    let value: bigint = 0n;\n    if (bigEndian) {\n      for (let i = 0; i < sizeInBytes; i++) {\n        value = (value << 8n) | BigInt(this.buffer[i + this.index]!);\n      }\n    } else {\n      for (let i = sizeInBytes - 1; i >= 0; i--) {\n        value = (value << 8n) | BigInt(this.buffer[i + this.index]!);\n      }\n    }\n\n    // Convert the value to two's complement if it is negative\n    // https://en.wikipedia.org/wiki/Two%27s_complement\n    if (signed) {\n      const limit = 1n << (sizeInBits - 1n);\n      if (value & limit) {\n        value -= limit << 1n;\n      }\n    }\n\n    this.index += sizeInBytes;\n    return value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["ByteArrayParser_exports", "__export", "ByteArrayParser", "__toCommonJS", "import_HexaString", "buffer", "length", "bigEndian", "value", "field", "startIndex", "tag", "endIndex", "prefix", "result", "index", "item", "sizeInBits", "signed", "sizeInBytes", "limit"]
}
