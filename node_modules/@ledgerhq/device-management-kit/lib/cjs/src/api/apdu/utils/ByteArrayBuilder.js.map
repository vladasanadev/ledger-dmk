{
  "version": 3,
  "sources": ["../../../../../../src/api/apdu/utils/ByteArrayBuilder.ts"],
  "sourcesContent": ["import { hexaStringToBuffer } from \"@api/utils/HexaString\";\n\nimport {\n  type AppBuilderError,\n  DataOverflowError,\n  HexaStringEncodeError,\n  ValueOverflowError,\n} from \"./AppBuilderError\";\n\nconst MAX_32_BIT_UINT = 0xffffffff;\n\n/**\n * ByteArrayBuilder is a utility class to help build APDU payloads.\n * It allows to easily add data to the payload of an APDU command\n * and to encode this data in different formats.\n *\n * @example\n * ```\n * const builder = new ByteArrayBuilder(255)\n *  .add8BitUIntToData(0x05)\n *  .add16BitUIntToData(0x0607)\n *  .addHexaStringToData(\"0x0809\")\n *  .addAsciiStringToData(\"hello\")\n *\n * const payload = builder.build();\n * const builderErrors = builder.getErrors();\n * ```\n */\nexport class ByteArrayBuilder {\n  private data: Uint8Array = new Uint8Array();\n  private readonly errors: AppBuilderError[] = []; // Custom Error\n\n  constructor(private maxPayloadSize: number = MAX_32_BIT_UINT) {}\n\n  // ==========\n  // Public API\n  // ==========\n\n  /**\n   * Build a new payload instance with the current state of the builder\n   * @returns {payload} - Returns a new payload instance\n   */\n  build = (): Uint8Array => this.data;\n\n  /**\n   * Try to build a new payload instance with the current state of the builder\n   * if the builder don't contain any error.\n   * @returns {payload | undefined} - Returns a new payload instance or undefined\n   */\n  tryBuild = (): Uint8Array | undefined => {\n    return this.hasErrors() ? undefined : this.data;\n  };\n\n  /**\n   * Add a 8-bit unsigned integer to the payload (max value 0xff = 255)\n   * @param value: number | bigint - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add8BitUIntToData = (value: number | bigint): ByteArrayBuilder => {\n    return this.addNumberToData(value, 8n, false, false);\n  };\n\n  /**\n   * Add a 16-bit unsigned integer to the payload (max value 0xffff = 65535)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add16BitUIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 16n, false, bigEndian);\n  };\n\n  /**\n   * Add a 32-bit unsigned integer to the payload (max value 0xffffffff = 4294967295)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add32BitUIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 32n, false, bigEndian);\n  };\n\n  /**\n   * Add a 64-bit unsigned integer to the payload (max value 0xffffffffffffffff = 18446744073709551615)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add64BitUIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 64n, false, bigEndian);\n  };\n\n  /**\n   * Add a 128-bit unsigned integer to the payload\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add128BitUIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 128n, false, bigEndian);\n  };\n\n  /**\n   * Add a 256-bit unsigned integer to the payload\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add256BitUIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 256n, false, bigEndian);\n  };\n\n  /**\n   * Add a 16-bit signed integer to the payload (value between -0x8000 to 0x7fff)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add16BitIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 16n, true, bigEndian);\n  };\n\n  /**\n   * Add a 32-bit signed integer to the payload (value between -0x80000000 to 0x7fffffff)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add32BitIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 32n, true, bigEndian);\n  };\n\n  /**\n   * Add a 64-bit signed integer to the payload (value between -0x8000000000000000 to 0x7fffffffffffffff)\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add64BitIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 64n, true, bigEndian);\n  };\n\n  /**\n   * Add a 128-bit signed integer to the payload\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add128BitIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 128n, true, bigEndian);\n  };\n\n  /**\n   * Add a 256-bit signed integer to the payload\n   * @param value: number | bigint - The value to add to the data\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  add256BitIntToData = (\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    return this.addNumberToData(value, 256n, true, bigEndian);\n  };\n\n  /**\n   * Add a Uint8Array to the payload if it has enough remaining space\n   * @param value: Uint8Array - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  addBufferToData = (value: Uint8Array): ByteArrayBuilder => {\n    if (!this.hasEnoughLengthRemaining(value)) {\n      this.errors.push(new DataOverflowError(value.toString()));\n      return this;\n    }\n\n    this.data = Uint8Array.from([...this.data, ...value]);\n    return this;\n  };\n\n  /**\n   * Add a string to the payload if it has enough remaining space\n   * and it can be formatted as a hexadecimal string\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  addHexaStringToData = (value: string): ByteArrayBuilder => {\n    const result = hexaStringToBuffer(value);\n    if (result === null || result.length === 0) {\n      this.errors.push(new HexaStringEncodeError(value));\n      return this;\n    }\n    this.addBufferToData(result);\n    return this;\n  };\n\n  /**\n   * Add an ascii string to the data field if it has enough remaining space\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  addAsciiStringToData = (value: string): ByteArrayBuilder => {\n    const bytes = new TextEncoder().encode(value);\n    this.addBufferToData(bytes);\n    return this;\n  };\n\n  /**\n   * Add a Length-Value encoded hexadecimal string to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInLVFromHexa = (value: string): ByteArrayBuilder => {\n    const result = hexaStringToBuffer(value);\n    if (result === null || result.length === 0) {\n      this.errors.push(new HexaStringEncodeError(value));\n      return this;\n    }\n\n    if (!this.hasEnoughLengthRemaining(result, true)) {\n      this.errors.push(new DataOverflowError(value));\n      return this;\n    }\n    // values are always being well formatted at this point\n    // therefore no status test is needed\n    this.add8BitUIntToData(result.length);\n    this.addBufferToData(result);\n    return this;\n  };\n\n  /**\n   * Add a Length-Value encoded buffer to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param value: Uint8Array - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInLVFromBuffer = (value: Uint8Array): ByteArrayBuilder => {\n    if (!this.hasEnoughLengthRemaining(value, true)) {\n      this.errors.push(new DataOverflowError(value.toString()));\n      return this;\n    }\n\n    this.add8BitUIntToData(value.length);\n    this.addBufferToData(value);\n    return this;\n  };\n\n  /**\n   * Add a Length-Value encoded ascii string to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInLVFromAscii = (value: string): ByteArrayBuilder => {\n    if (!this.hasEnoughLengthRemaining(value, true)) {\n      this.errors.push(new DataOverflowError(value));\n      return this;\n    }\n\n    this.add8BitUIntToData(value.length);\n    this.addAsciiStringToData(value);\n    return this;\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded ascii string to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromAscii = (tag: number, value: string): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    return this.encodeInLVFromAscii(value);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded hexadecimal string to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: string - The value to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromHexa = (tag: number, value: string): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    return this.encodeInLVFromHexa(value);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded hexadecimal string to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: Uint8Array - The buffer to add to the data\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromBuffer = (\n    tag: number,\n    value: Uint8Array,\n  ): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    return this.encodeInLVFromBuffer(value);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded uint8 to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: number - The number to add\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromUInt8 = (tag: number, value: number): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    this.add8BitUIntToData(1);\n    return this.add8BitUIntToData(value);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded uint16 to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: number | bigint - The number to add\n   * @param bigEndian: boolean - Endianness used to encode the number\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromUInt16 = (\n    tag: number,\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    this.add8BitUIntToData(2);\n    return this.add16BitUIntToData(value, bigEndian);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded uint32 to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: number | bigint - The number to add\n   * @param bigEndian: boolean - Endianness used to encode the number\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromUInt32 = (\n    tag: number,\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    this.add8BitUIntToData(4);\n    return this.add32BitUIntToData(value, bigEndian);\n  };\n\n  /**\n   * Add a Tag-Length-Value encoded uint64 to the data field if it has enough remaining space\n   * Length-Value encoding is a way to encode data in a binary format with the first byte\n   * being the length of the data and the following bytes being the data itself\n   * @param tag: number - The tag to add to the data\n   * @param value: number | bigint - The number to add\n   * @param bigEndian: boolean - Endianness used to encode the number\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  encodeInTLVFromUInt64 = (\n    tag: number,\n    value: number | bigint,\n    bigEndian: boolean = true,\n  ): ByteArrayBuilder => {\n    this.add8BitUIntToData(tag);\n    this.add8BitUIntToData(8);\n    return this.add64BitUIntToData(value, bigEndian);\n  };\n\n  /**\n   * Returns the remaining payload length\n   * @returns {number}\n   */\n  getAvailablePayloadLength = (): number => {\n    return this.maxPayloadSize - this.data.length;\n  };\n\n  /**\n   * Returns the current errors\n   * @returns {AppBuilderError[]} - Returns an array of errors\n   */\n  getErrors = (): AppBuilderError[] => this.errors;\n\n  /**\n   * Verifies if the builder contains errors\n   * @returns {boolean} - Returns wether the builder contains errors or not\n   */\n  hasErrors = (): boolean => this.errors.length !== 0;\n\n  // ===========\n  // Private API\n  // ===========\n\n  /**\n   * Check if there is enough space to add a value to the data field\n   * @param value {string | Uint8Array | number[]} - Value to add to the data\n   * @param hasLv {boolean} - Length-Value encoding flag\n   * @returns {boolean} - Returns true if there is enough space to add the value\n   */\n  private hasEnoughLengthRemaining = (\n    value: string | Uint8Array | number[],\n    hasLv: boolean = false,\n  ): boolean => {\n    return (\n      this.data.length + value.length + (hasLv ? 1 : 0) <= this.maxPayloadSize\n    );\n  };\n\n  /**\n   * Add a number to the payload\n   * @param value: number | bigint - The value to add to the data\n   * @param sizeInBits: bigint - The number size in bits, for example 16 for a uint16\n   * @param signed: boolean - Whether the value is signed or unsigned.\n   * @param bigEndian: boolean - True to encode in big endian, false for little endian\n   * @returns {ByteArrayBuilder} - Returns the current instance of ByteArrayBuilder\n   */\n  private addNumberToData(\n    value: number | bigint,\n    sizeInBits: bigint,\n    signed: boolean,\n    bigEndian: boolean,\n  ): ByteArrayBuilder {\n    // Convert the number to two's complement and check its bounds\n    let converted = this.checkBoundsAndConvert(value, sizeInBits, signed);\n    if (converted === undefined) {\n      return this;\n    }\n\n    // Compute the buffer\n    const sizeInBytes = Number(sizeInBits) / 8;\n    const buffer = new Uint8Array(sizeInBytes);\n    if (bigEndian) {\n      for (let i = sizeInBytes - 1; i >= 0; i--) {\n        buffer[i] = Number(converted & 0xffn);\n        converted >>= 8n;\n      }\n    } else {\n      for (let i = 0; i < sizeInBytes; i++) {\n        buffer[i] = Number(converted & 0xffn);\n        converted >>= 8n;\n      }\n    }\n    return this.addBufferToData(buffer);\n  }\n\n  /**\n   * Checks the bounds of a signed or unsigned integer value and converts it to two's complement if it is signed and negative.\n   * @param value The value to check and convert.\n   * @param sizeInBits The size of the value in bits.\n   * @param signed Whether the value is signed or unsigned.\n   * @returns The converted value, or null if the value is out of bounds.\n   */\n  private checkBoundsAndConvert(\n    value: number | bigint,\n    sizeInBits: bigint,\n    signed: boolean,\n  ): bigint | undefined {\n    // Normalize the value to a bigint\n    if (typeof value === \"number\") {\n      if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER) {\n        this.errors.push(new ValueOverflowError(value.toString()));\n        return;\n      }\n      value = BigInt(value);\n    }\n\n    if (!signed) {\n      // Check if the value is within the bounds of an unsigned integer\n      const limit = 1n << sizeInBits;\n      if (value < 0 || value >= limit) {\n        this.errors.push(new ValueOverflowError(value.toString(), limit - 1n));\n        return;\n      }\n    } else {\n      // Check if the value is within the bounds of a signed integer\n      const limit = 1n << (sizeInBits - 1n);\n      if (value >= limit || value < -limit) {\n        this.errors.push(new ValueOverflowError(value.toString(), limit - 1n));\n        return;\n      }\n\n      // Convert the value to two's complement if it is negative\n      // https://en.wikipedia.org/wiki/Two%27s_complement\n      if (value < 0n) {\n        const mask = (1n << sizeInBits) - 1n;\n        value = -value;\n        value = (~value & mask) + 1n;\n      }\n    }\n    return value;\n  }\n}\n"],
  "mappings": "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",
  "names": ["ByteArrayBuilder_exports", "__export", "ByteArrayBuilder", "__toCommonJS", "import_HexaString", "import_AppBuilderError", "MAX_32_BIT_UINT", "maxPayloadSize", "value", "bigEndian", "result", "bytes", "tag", "hasLv", "sizeInBits", "signed", "converted", "sizeInBytes", "buffer", "i", "limit", "mask"]
}
