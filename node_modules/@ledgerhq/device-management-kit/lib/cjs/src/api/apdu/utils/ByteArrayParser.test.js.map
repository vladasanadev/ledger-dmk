{
  "version": 3,
  "sources": ["../../../../../../src/api/apdu/utils/ByteArrayParser.test.ts"],
  "sourcesContent": ["import { hexaStringToBuffer } from \"@api/utils/HexaString\";\n\nimport { ByteArrayParser } from \"./ByteArrayParser\";\n\nconst RESPONSE_ONE_BYTE = new Uint8Array([0x01]);\nconst RESPONSE_LV_ZERO = new Uint8Array([0x00]);\nconst RESPONSE_TWO_BYTES = new Uint8Array([0x01, 0x01]);\nconst RESPONSE_TLV_ZERO = new Uint8Array([0xab, 0x00]);\nconst RESPONSE_ALL_BYTES = new Uint8Array([\n  0x01,\n  0x02,\n  0x03,\n  ...Array<number>(253).fill(0xaa),\n]);\n\n/*\nType : 33 00 00 04 -> nanoX\nVersion SE (LV): 2.2.3\nFlag: E600000000\n  PIN OK\n  Factory init Ok\n  Onboarding done\nVersion MCU(LV): 2.30\nVersion BootLoader(LV): 1.16\nHW rev: 0\nLanguage(LV): Fra & Eng\nRecover state (LV): 1\n*/\nconst DEVICE_TYPE = \"33000004\";\nconst DEVICE_FLAGS = \"0xe6000000\";\nconst NUMERIC_FLAGS = 0xe6000000;\nconst VERSION_FW_SE = \"2.2.3\";\nconst VERSION_FW_MCU = \"2.30\";\nconst VERSION_FW_BL = \"1.16\";\nconst HARDWARE_REV = 0;\nconst LANGUAGE_PACK = 1;\nconst RECOVER_STATE = 0;\nconst RESPONSE_GET_VERSION = new Uint8Array([\n  0x33, 0x00, 0x00, 0x04, 0x05, 0x32, 0x2e, 0x32, 0x2e, 0x33, 0x04, 0xe6, 0x00,\n  0x00, 0x00, 0x04, 0x32, 0x2e, 0x33, 0x30, 0x04, 0x31, 0x2e, 0x31, 0x36, 0x01,\n  0x00, 0x01, 0x01, 0x01, 0x00,\n]);\n\n/*\nFormat version: 1\nName: BOLOS\nVersion: 2.2.3\n*/\nconst DASHBOARD_HEX = new Uint8Array([0x42, 0x4f, 0x4c, 0x4f, 0x53]);\nconst DASHBOARD_NAME = \"BOLOS\";\nconst RESPONSE_GET_APP_VERSION = new Uint8Array([\n  0x01, 0x05, 0x42, 0x4f, 0x4c, 0x4f, 0x53, 0x05, 0x32, 0x2e, 0x32, 0x2e, 0x33,\n]);\n\nlet parser: ByteArrayParser;\nlet response = RESPONSE_ONE_BYTE;\n\ndescribe(\"ByteArrayParser\", () => {\n  const parserExtractNumber = (\n    bigEndian: boolean,\n    sizeInBits: number,\n    signed: boolean,\n  ): bigint | number | undefined => {\n    if (signed) {\n      switch (sizeInBits) {\n        case 2:\n          return parser.extract16BitInt(bigEndian);\n        case 4:\n          return parser.extract32BitInt(bigEndian);\n        case 8:\n          return parser.extract64BitInt(bigEndian);\n        case 16:\n          return parser.extract128BitInt(bigEndian);\n        case 32:\n          return parser.extract256BitInt(bigEndian);\n      }\n    } else {\n      switch (sizeInBits) {\n        case 2:\n          return parser.extract16BitUInt(bigEndian);\n        case 4:\n          return parser.extract32BitUInt(bigEndian);\n        case 8:\n          return parser.extract64BitUInt(bigEndian);\n        case 16:\n          return parser.extract128BitUInt(bigEndian);\n        case 32:\n          return parser.extract256BitUInt(bigEndian);\n      }\n    }\n    return undefined;\n  };\n\n  describe(\"clean\", () => {\n    beforeEach(() => {\n      vi.resetAllMocks();\n    });\n\n    it(\"should create an instance\", () => {\n      parser = new ByteArrayParser(response);\n      expect(parser).toBeDefined();\n      expect(parser).toBeInstanceOf(ByteArrayParser);\n    });\n\n    it(\"Extract a single byte\", () => {\n      parser = new ByteArrayParser(response);\n      expect(parser.extract8BitUInt()).toBe(0x01);\n      expect(parser.getCurrentIndex()).toBe(1);\n      expect(parser.getUnparsedRemainingLength()).toBe(0);\n    });\n\n    it(\"Extract one byte\", () => {\n      response = RESPONSE_ALL_BYTES;\n      parser = new ByteArrayParser(response);\n      let index = 0;\n      let length = RESPONSE_ALL_BYTES.length;\n\n      expect(length).toBe(256);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n      index++;\n      length--;\n\n      expect(parser.extract8BitUInt()).toBe(0x01);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n      index++;\n      length--;\n\n      expect(parser.extract8BitUInt()).toBe(0x02);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n      index++;\n      length--;\n\n      expect(parser.extract8BitUInt()).toBe(0x03);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n      index++;\n      length--;\n\n      while (length != 0) {\n        expect(parser.extract8BitUInt()).toBe(0xaa);\n        expect(parser.getCurrentIndex()).toBe(index);\n        expect(parser.getUnparsedRemainingLength()).toBe(length);\n        index++;\n        length--;\n      }\n    });\n\n    it.each([\n      [2, false, true, \"ffff\", 0xffff],\n      [2, true, true, \"7fff\", 0x7fff],\n      [2, true, true, \"8000\", -0x8000],\n      [4, false, true, \"ffffffff\", 0xffffffff],\n      [4, true, true, \"7fffffff\", 0x7fffffff],\n      [4, true, true, \"80000000\", -0x80000000],\n      [8, false, true, \"ffffffffffffffff\", 0xffffffffffffffffn],\n      [8, true, true, \"7fffffffffffffff\", 0x7fffffffffffffffn],\n      [8, true, true, \"8000000000000000\", -0x8000000000000000n],\n      [\n        16,\n        false,\n        true,\n        \"ffffffffffffffffffffffffffffffff\",\n        0xffffffffffffffffffffffffffffffffn,\n      ],\n      [\n        16,\n        true,\n        true,\n        \"7fffffffffffffffffffffffffffffff\",\n        0x7fffffffffffffffffffffffffffffffn,\n      ],\n      [\n        16,\n        true,\n        true,\n        \"80000000000000000000000000000000\",\n        -0x80000000000000000000000000000000n,\n      ],\n      [\n        32,\n        false,\n        true,\n        \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,\n      ],\n      [\n        32,\n        true,\n        true,\n        \"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,\n      ],\n      [\n        32,\n        true,\n        true,\n        \"8000000000000000000000000000000000000000000000000000000000000000\",\n        -0x8000000000000000000000000000000000000000000000000000000000000000n,\n      ],\n    ])(\n      \"Extract a number to the limit: size %i, signed %s, bigEndian %s, buffer %s, expected %i\",\n      (sizeInBits, signed, bigEndian, input, output) => {\n        parser = new ByteArrayParser(hexaStringToBuffer(input)!);\n        const result = parserExtractNumber(bigEndian, sizeInBits, signed);\n        expect(result).toStrictEqual(output);\n      },\n    );\n\n    it.each([\n      [2, false, true, \"3302\", 0x3302],\n      [2, false, false, \"0233\", 0x3302],\n      [2, true, true, \"1068\", 4200],\n      [2, true, true, \"ef98\", -4200],\n      [2, true, false, \"6810\", 4200],\n      [2, true, false, \"98ef\", -4200],\n      [4, false, true, \"01234567\", 0x01234567],\n      [4, false, false, \"67452301\", 0x01234567],\n      [4, true, true, \"075bcd15\", 123456789],\n      [4, true, true, \"f8a432eb\", -123456789],\n      [4, true, false, \"15cd5b07\", 123456789],\n      [4, true, false, \"eb32a4f8\", -123456789],\n      [8, false, true, \"0032435442584447\", 14147778004927559n],\n      [8, false, false, \"4744584254433200\", 14147778004927559n],\n      [8, true, true, \"0032435442584447\", 14147778004927559n],\n      [8, true, true, \"ffcdbcabbda7bbb9\", -14147778004927559n],\n      [8, true, false, \"4744584254433200\", 14147778004927559n],\n      [8, true, false, \"b9bba7bdabbccdff\", -14147778004927559n],\n      [\n        16,\n        false,\n        true,\n        \"00324354425844470032435442584447\",\n        0x00324354425844470032435442584447n,\n      ],\n      [\n        16,\n        false,\n        false,\n        \"47445842544332004744584254433200\",\n        0x00324354425844470032435442584447n,\n      ],\n      [\n        16,\n        true,\n        true,\n        \"00324354425844470032435442584447\",\n        0x00324354425844470032435442584447n,\n      ],\n      [\n        16,\n        true,\n        true,\n        \"ffcdbcabbda7bbb8ffcdbcabbda7bbb9\",\n        -0x00324354425844470032435442584447n,\n      ],\n      [\n        16,\n        true,\n        false,\n        \"47445842544332004744584254433200\",\n        0x00324354425844470032435442584447n,\n      ],\n      [\n        16,\n        true,\n        false,\n        \"b9bba7bdabbccdffb8bba7bdabbccdff\",\n        -0x00324354425844470032435442584447n,\n      ],\n      [\n        32,\n        false,\n        true,\n        \"0032435442584447003243544258444700324354425844470032435442584447\",\n        0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n      [\n        32,\n        false,\n        false,\n        \"4744584254433200474458425443320047445842544332004744584254433200\",\n        0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n      [\n        32,\n        true,\n        true,\n        \"0032435442584447003243544258444700324354425844470032435442584447\",\n        0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n      [\n        32,\n        true,\n        true,\n        \"ffcdbcabbda7bbb8ffcdbcabbda7bbb8ffcdbcabbda7bbb8ffcdbcabbda7bbb9\",\n        -0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n      [\n        32,\n        true,\n        false,\n        \"4744584254433200474458425443320047445842544332004744584254433200\",\n        0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n      [\n        32,\n        true,\n        false,\n        \"b9bba7bdabbccdffb8bba7bdabbccdffb8bba7bdabbccdffb8bba7bdabbccdff\",\n        -0x0032435442584447003243544258444700324354425844470032435442584447n,\n      ],\n    ])(\n      \"Extract the following number: size %i, signed %s, bigEndian %s, buffer %s, expected %i\",\n      (sizeInBits, signed, bigEndian, input, output) => {\n        parser = new ByteArrayParser(hexaStringToBuffer(input)!);\n        const result = parserExtractNumber(bigEndian, sizeInBits, signed);\n        expect(result).toStrictEqual(output);\n      },\n    );\n\n    it(\"Extract 16-bit & 32-bit number\", () => {\n      response = RESPONSE_ALL_BYTES;\n      parser = new ByteArrayParser(response);\n      let index = 0;\n      let length = RESPONSE_ALL_BYTES.length;\n\n      expect(length).toBe(256);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract16BitUInt()).toBe(0x0102);\n      index += 2;\n      length -= 2;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract16BitUInt()).toBe(0x03aa);\n      index += 2;\n      length -= 2;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      parser.resetIndex();\n      index = 0;\n      length = RESPONSE_ALL_BYTES.length;\n\n      expect(parser.extract32BitUInt()).toBe(0x010203aa);\n      index += 4;\n      length -= 4;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract32BitUInt()).toBe(0xaaaaaaaa);\n      index += 4;\n      length -= 4;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n    });\n\n    it(\"Parse a GetAppVersion response\", () => {\n      response = RESPONSE_GET_APP_VERSION;\n      parser = new ByteArrayParser(response);\n      let index = 0;\n      let length = RESPONSE_GET_APP_VERSION.length;\n\n      // Parse the response considering the first field to be the format field\n      expect(length).toBe(13);\n\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      const value = parser.extract8BitUInt();\n      index++;\n      length--;\n      expect(value).toBe(1);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      let array = parser.extractFieldLVEncoded();\n      expect(array).toStrictEqual(DASHBOARD_HEX);\n      expect(parser.encodeToString(array)).toBe(DASHBOARD_NAME);\n      index += 6;\n      length -= 6;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.encodeToString(array)).toBe(VERSION_FW_SE);\n      index += 6;\n      length -= 6;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      // Reparse the response considering the first field to be the TLV formatted\n      parser.resetIndex();\n      index = 0;\n      length = RESPONSE_GET_APP_VERSION.length;\n\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      const field = parser.extractFieldTLVEncoded();\n      expect(field?.tag).toBe(0x01);\n      expect(field?.value).toStrictEqual(DASHBOARD_HEX);\n      expect(parser.encodeToString(field?.value)).toBe(DASHBOARD_NAME);\n      index += 7;\n      length -= 7;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.encodeToString(array)).toBe(VERSION_FW_SE);\n      index += 6;\n      length -= 6;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n    });\n\n    it(\"Parse a GetVersion response\", () => {\n      response = RESPONSE_GET_VERSION;\n      parser = new ByteArrayParser(response);\n      let index = 0;\n      let length = RESPONSE_GET_VERSION.length;\n\n      expect(length).toBe(31);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n      expect(parser.testMinimalLength(25)).toBe(true);\n\n      let array = parser.extractFieldByLength(4);\n      expect(parser.encodeToHexaString(array)).toBe(DEVICE_TYPE);\n      index += 4;\n      length -= 4;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.encodeToString(array)).toBe(VERSION_FW_SE);\n      index += 6;\n      length -= 6;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      const flags = parser.encodeToHexaString(array, true);\n      expect(flags).toBe(DEVICE_FLAGS);\n      expect(parseInt(flags, 16)).toBe(NUMERIC_FLAGS);\n      index += 5;\n      length -= 5;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.encodeToString(array)).toBe(VERSION_FW_MCU);\n      index += 5;\n      length -= 5;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.encodeToString(array)).toBe(VERSION_FW_BL);\n      index += 5;\n      length -= 5;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(array?.at(0)).toBe(HARDWARE_REV);\n      index += 2;\n      length -= 2;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(array?.at(0)).toBe(LANGUAGE_PACK);\n      index += 2;\n      length -= 2;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(array?.at(0)).toBe(RECOVER_STATE);\n      index += 2;\n      length -= 2;\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n    });\n  });\n\n  describe(\"errors\", () => {\n    it(\"no response\", () => {\n      response = new Uint8Array();\n      parser = new ByteArrayParser(response);\n      const index = 0;\n      const length = 0;\n\n      expect(parser.testMinimalLength(1)).toBe(false);\n\n      expect(parser.extract8BitUInt()).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract16BitUInt()).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract32BitUInt()).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      let array = parser.extractFieldByLength(2);\n      expect(array).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(array).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      const field = parser.extractFieldTLVEncoded();\n      expect(field).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n    });\n\n    it(\"length error\", () => {\n      response = RESPONSE_ONE_BYTE;\n      parser = new ByteArrayParser(response);\n      const index = 0;\n      const length = RESPONSE_ONE_BYTE.length;\n\n      expect(length).toBe(1);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract16BitUInt()).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      expect(parser.extract32BitUInt()).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      let array = parser.extractFieldByLength(2);\n      expect(array).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(array).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      let field = parser.extractFieldTLVEncoded();\n      expect(field).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      response = RESPONSE_TWO_BYTES;\n      parser = new ByteArrayParser(response);\n\n      field = parser.extractFieldTLVEncoded();\n      expect(field).toBeUndefined();\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(\n        RESPONSE_TWO_BYTES.length,\n      );\n    });\n\n    it(\"Test zero length\", () => {\n      response = RESPONSE_LV_ZERO;\n      parser = new ByteArrayParser(response);\n      const zero = new Uint8Array();\n\n      const index = 0;\n      let length = RESPONSE_LV_ZERO.length;\n\n      expect(length).toBe(1);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      const value = parser.extract8BitUInt();\n      expect(value).toBe(0);\n      expect(parser.getCurrentIndex()).toBe(1);\n      expect(parser.getUnparsedRemainingLength()).toBe(0);\n\n      parser.resetIndex();\n\n      let array = parser.extractFieldByLength(0);\n      expect(array).toStrictEqual(zero);\n      expect(parser.encodeToString(array)).toBe(\"\");\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      array = parser.extractFieldLVEncoded();\n      expect(parser.getCurrentIndex()).toBe(1);\n      expect(parser.getUnparsedRemainingLength()).toBe(0);\n      expect(array).toStrictEqual(zero);\n      expect(parser.encodeToString(array)).toBe(\"\");\n\n      response = RESPONSE_TLV_ZERO;\n      parser = new ByteArrayParser(response);\n      length = RESPONSE_TLV_ZERO.length;\n\n      expect(length).toBe(2);\n      expect(parser.getCurrentIndex()).toBe(index);\n      expect(parser.getUnparsedRemainingLength()).toBe(length);\n\n      const field = parser.extractFieldTLVEncoded();\n      expect(field?.tag).toBe(0xab);\n      expect(field?.value).toStrictEqual(zero);\n      expect(parser.encodeToString(field?.value)).toBe(\"\");\n      expect(parser.getCurrentIndex()).toBe(2);\n      expect(parser.getUnparsedRemainingLength()).toBe(0);\n\n      expect(parser.encodeToHexaString()).toBe(\"\");\n      expect(parser.encodeToString()).toBe(\"\");\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["import_HexaString", "import_ByteArrayParser", "RESPONSE_ONE_BYTE", "RESPONSE_LV_ZERO", "RESPONSE_TWO_BYTES", "RESPONSE_TLV_ZERO", "RESPONSE_ALL_BYTES", "DEVICE_TYPE", "DEVICE_FLAGS", "NUMERIC_FLAGS", "VERSION_FW_SE", "VERSION_FW_MCU", "VERSION_FW_BL", "HARDWARE_REV", "LANGUAGE_PACK", "RECOVER_STATE", "RESPONSE_GET_VERSION", "DASHBOARD_HEX", "DASHBOARD_NAME", "RESPONSE_GET_APP_VERSION", "parser", "response", "parserExtractNumber", "bigEndian", "sizeInBits", "signed", "index", "length", "input", "output", "result", "value", "array", "field", "flags", "zero"]
}
