"use strict";var R=Object.create;var C=Object.defineProperty;var D=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames;var P=Object.getPrototypeOf,U=Object.prototype.hasOwnProperty;var W=(s,e)=>{for(var i in e)C(s,i,{get:e[i],enumerable:!0})},A=(s,e,i,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let l of N(e))!U.call(s,l)&&l!==i&&C(s,l,{get:()=>e[l],enumerable:!(r=D(e,l))||r.enumerable});return s};var q=(s,e,i)=>(i=s!=null?R(P(s)):{},A(e||!s||!s.__esModule?C(i,"default",{value:s,enumerable:!0}):i,s)),$=s=>A(C({},"__esModule",{value:!0}),s);var L={};W(L,{ConnectToSecureChannelTask:()=>G});module.exports=$(L);var M=q(require("isomorphic-ws")),k=require("rxjs"),g=require("../../command/utils/CommandUtils"),t=require("../../secure-channel/task/types"),S=require("../../secure-channel/utils"),m=require("../../utils/HexaString"),I=require("../../../internal/crypto/NobleCryptoService"),n=require("../../../internal/secure-channel/model/Errors");class G{constructor(e,i){this._api=e;this._args=i;if(this._args.connection.isRight())this._connection=this._args.connection.extract();else throw new n.SecureChannelError(`Invalid WebSocket connection: ${String(this._args.connection.extract())}`);this._cryptoService=this._args.cryptoService??new I.NobleCryptoService}_connection;_cryptoService;_deviceIdCaptured=!1;run(){const e=this._api.disableRefresher("connectToSecureChannel");return new k.Observable(r=>{let l=!1,u=!1,E=!1;const p=h=>{r.next({type:t.SecureChannelEventType.Error,error:h}),r.complete(),u=!0};return this._connection.onopen=()=>{r.next({type:t.SecureChannelEventType.Opened})},this._connection.onerror=h=>{u||(r.next({type:t.SecureChannelEventType.Error,error:new n.SecureChannelError({url:this._connection.url,errorMessage:h.message})}),r.complete())},this._connection.onclose=()=>{u||(E?r.next({type:t.SecureChannelEventType.Closed}):r.next({type:t.SecureChannelEventType.Error,error:new n.SecureChannelError({url:this._connection.url,errorMessage:"Connection closed unexpectedly"})}),r.complete())},this._connection.onmessage=async h=>{if(l)return;let a;try{const o=JSON.parse(String(h.data));if(this.isInMessageType(o))a=o;else throw new Error("Data does not match InMessageType")}catch{p(new n.SecureChannelError({url:this._connection.url,errorMessage:`Invalid message received: ${String(h.data)}`}));return}switch(a.query){case t.InMessageQueryEnum.EXCHANGE:{const{nonce:o,data:d}=a;if(typeof d!="string"){p(new n.SecureChannelError(`${t.InMessageQueryEnum.EXCHANGE} data type should be an APDU`));return}const c=(0,m.hexaStringToBuffer)(d);if(c===null||c.length<5){p(new n.SecureChannelError(`Received invalid APDU data: ${d}`));return}r.next({type:t.SecureChannelEventType.PreExchange,payload:{nonce:o,apdu:c}});let y=!1;(0,S.willRequestPermission)(c)&&!this.isSecureConnectionAllowed()&&(y=!0,r.next({type:t.SecureChannelEventType.PermissionRequested}));const v=await this._api.sendApdu(c);if(l)return;v.caseOf({Left:f=>{p(new n.SecureChannelError(f))},Right:f=>{let _;const w=this.mapDeviceError(f);if(w===null){if(_=t.OutMessageResponseEnum.SUCCESS,!this._deviceIdCaptured&&(0,S.isGetCertificateApdu)(c)){this._deviceIdCaptured=!0;const x=(0,S.extractPublicKey)(f);if(x){const O=this._cryptoService.sha3_256(x);r.next({type:t.SecureChannelEventType.DeviceId,payload:{deviceId:O}})}}r.next({type:t.SecureChannelEventType.Exchange,payload:{nonce:o,apdu:c,data:f.data,status:f.statusCode}}),y&&r.next({type:t.SecureChannelEventType.PermissionGranted})}else _=t.OutMessageResponseEnum.ERROR,p(w);const T={nonce:o,response:_,data:(0,m.bufferToHexaString)(f.data,!1)};this._connection.send(JSON.stringify(T))}});break}case t.InMessageQueryEnum.BULK:{if(u=!0,this._connection.close(),!Array.isArray(a.data)||a.data.length===0||!a.data.every(o=>typeof o=="string")){p(new n.SecureChannelError("Invalid bulk data received"));return}for(let o=0,d=a.data.length;o<d;o++){const c=(0,m.hexaStringToBuffer)(a.data[o]);if(c===null||c.length<5){p(new n.SecureChannelError(`Received invalid APDU bulk data: ${a.data[o]}`));return}const y=await this._api.sendApdu(c);if(l)return;if(y.isLeft()){p(new n.SecureChannelError(y.extract()));return}else if(y.isRight()){const v=this.mapDeviceError(y.extract());if(v===null)r.next({type:t.SecureChannelEventType.Progress,payload:{progress:+Number((o+1)/d).toFixed(2),index:o,total:d}});else{p(v);return}}}E=!0,r.complete();break}case t.InMessageQueryEnum.SUCCESS:{if(u)break;const o=a.result??a.data;o&&r.next({type:t.SecureChannelEventType.Result,payload:o??""}),E=!0,r.complete();break}case t.InMessageQueryEnum.WARNING:{if(u)break;r.next({type:t.SecureChannelEventType.Warning,payload:{message:String(a.data)}});break}case t.InMessageQueryEnum.ERROR:{if(u)break;p(new n.SecureChannelError({url:this._connection.url,errorMessage:String(a.data)}))}}},()=>{e(),l=!0,this._connection.readyState===M.default.OPEN&&this._connection.close()}})}isSecureConnectionAllowed(){const e=this._api.getDeviceSessionState();return"isSecureConnectionAllowed"in e&&e.isSecureConnectionAllowed}isInMessageType(e){if(typeof e!="object"||!e)return!1;const i=e;return typeof i.uuid=="string"&&typeof i.session=="string"&&typeof i.query=="string"&&Object.values(t.InMessageQueryEnum).includes(i.query)&&typeof i.nonce=="number"}mapDeviceError(e){return g.CommandUtils.isSuccessResponse(e)?null:g.CommandUtils.isLockedDeviceResponse(e)?new n.SecureChannelError({url:this._connection.url,errorMessage:"Device is locked"},n.SecureChannelErrorType.DeviceLocked):g.CommandUtils.isRefusedByUser(e)?new n.SecureChannelError({url:this._connection.url,errorMessage:"User refused on the device"},n.SecureChannelErrorType.RefusedByUser):g.CommandUtils.isAppAlreadyInstalled(e)?new n.SecureChannelError({url:this._connection.url,errorMessage:"App already installed"},n.SecureChannelErrorType.AppAlreadyInstalled):g.CommandUtils.isOutOfMemory(e)?new n.SecureChannelError({url:this._connection.url,errorMessage:"Out of memory"},n.SecureChannelErrorType.OutOfMemory):new n.SecureChannelError({url:this._connection.url,errorMessage:`Invalid status code: ${(0,m.bufferToHexaString)(e.statusCode)}`})}}0&&(module.exports={ConnectToSecureChannelTask});
//# sourceMappingURL=ConnectToSecureChannelTask.js.map
