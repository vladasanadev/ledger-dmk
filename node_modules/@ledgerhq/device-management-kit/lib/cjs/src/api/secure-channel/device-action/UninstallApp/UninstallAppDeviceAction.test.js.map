{
  "version": 3,
  "sources": ["../../../../../../../src/api/secure-channel/device-action/UninstallApp/UninstallAppDeviceAction.test.ts"],
  "sourcesContent": ["import { Right } from \"purify-ts\";\nimport { of, throwError } from \"rxjs\";\n\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { type GetOsVersionResponse } from \"@api/command/os/GetOsVersionCommand\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport {\n  setupGoToDashboardMock,\n  setupListInstalledAppsMock,\n} from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport {\n  type DeviceSessionState,\n  DeviceSessionStateType,\n} from \"@api/device-session/DeviceSessionState\";\nimport { type InstalledApp } from \"@api/secure-channel/device-action/ListInstalledApps/types\";\nimport {\n  type SecureChannelEvent,\n  SecureChannelEventType,\n} from \"@api/secure-channel/task/types\";\nimport { type Application } from \"@internal/manager-api/model/Application\";\nimport { SecureChannelError } from \"@internal/secure-channel/model/Errors\";\n\nimport { type UninstallAppDAState } from \"./types\";\nimport { UninstallAppDeviceAction } from \"./UninstallAppDeviceAction\";\n\nvi.mock(\n  \"@api/secure-channel/device-action/ListInstalledApps/ListInstalledAppsDeviceAction\",\n);\nvi.mock(\"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\");\n\ndescribe(\"UninstallAppDeviceAction\", () => {\n  const getOsVersionMock = vi.fn();\n  const getAppsByHashMock = vi.fn();\n  const uninstallAppMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n  const extractDependenciesMock = () => ({\n    getOsVersion: getOsVersionMock,\n    getAppsByHash: getAppsByHashMock,\n    uninstallApp: uninstallAppMock,\n    getDeviceSessionState: getDeviceSessionStateMock,\n    setDeviceSessionState: setDeviceSessionStateMock,\n  });\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  it(\"should finish successfully when the app is not installed on the device\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Completed,\n          output: undefined,\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Ethereum\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish successfully when the app is installed on the device\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n        { installedApps: [] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      getAppsByHashMock.mockResolvedValue(\n        Right([\n          {\n            versionName: \"Bitcoin\",\n            perso: \"test_perso\",\n            firmware: \"test_firmware_for_bitcoin\",\n            firmwareKey: \"test_firmware_key_for_bitcoin\",\n            hash: \"test_hash_for_bitcoin\",\n          } as Application,\n        ]),\n      );\n      uninstallAppMock.mockReturnValue(\n        of({\n          type: SecureChannelEventType.Exchange,\n        } as SecureChannelEvent),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Completed,\n          output: undefined,\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when the app is a dependency of other installed apps\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        {\n          installedApps: [\n            { name: \"Bitcoin\" },\n            { name: \"Testcoin\" },\n          ] as InstalledApp[],\n        },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      getAppsByHashMock.mockResolvedValue(\n        Right([\n          {\n            versionName: \"Testcoin\",\n            parentName: \"Bitcoin\",\n          },\n          {\n            versionName: \"Bitcoin\",\n          },\n        ] as Application[]),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new UnknownDAError(\n            \"App to uninstall is a dependency of another installed app\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when the app is not found in manager API\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({} as DeviceSessionState);\n      getAppsByHashMock.mockResolvedValueOnce(Right([]));\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new UnknownDAError(\n            \"App to uninstall not found in manager API\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when there is error in uninstallApp\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({} as DeviceSessionState);\n      getAppsByHashMock.mockResolvedValueOnce(\n        Right([{ versionName: \"Bitcoin\" } as Application]),\n      );\n      uninstallAppMock.mockReturnValue(\n        throwError(\n          () => new SecureChannelError(\"Uninstall app error in secure channel\"),\n        ),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new SecureChannelError(\n            \"Uninstall app error in secure channel\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n});\n"],
  "mappings": "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",
  "names": ["import_purify_ts", "import_rxjs", "import_CommandResult", "import_DeviceStatus", "import_makeInternalApi", "import_setupTestMachine", "import_testDeviceActionStates", "import_DeviceActionState", "import_UserInteractionRequired", "import_Errors", "import_DeviceSessionState", "import_types", "import_UninstallAppDeviceAction", "getOsVersionMock", "getAppsByHashMock", "uninstallAppMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "extractDependenciesMock", "resolve", "reject", "expectedStates", "uninstallAppDeviceAction"]
}
