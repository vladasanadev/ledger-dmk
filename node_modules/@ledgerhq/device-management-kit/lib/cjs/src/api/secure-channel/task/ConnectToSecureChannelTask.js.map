{
  "version": 3,
  "sources": ["../../../../../../src/api/secure-channel/task/ConnectToSecureChannelTask.ts"],
  "sourcesContent": ["import WebSocket from \"isomorphic-ws\";\nimport { type Either } from \"purify-ts\";\nimport { Observable } from \"rxjs\";\n\nimport { CommandUtils } from \"@api/command/utils/CommandUtils\";\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { type ApduResponse } from \"@api/device-session/ApduResponse\";\nimport {\n  InMessageQueryEnum,\n  type InMessageType,\n  OutMessageResponseEnum,\n  type OutMessageType,\n  type SecureChannelEvent,\n  SecureChannelEventType,\n} from \"@api/secure-channel/task/types\";\nimport {\n  extractPublicKey,\n  isGetCertificateApdu,\n  willRequestPermission,\n} from \"@api/secure-channel/utils\";\nimport { bufferToHexaString, hexaStringToBuffer } from \"@api/utils/HexaString\";\nimport { type CryptoService } from \"@internal/crypto/CryptoService\";\nimport { NobleCryptoService } from \"@internal/crypto/NobleCryptoService\";\nimport {\n  SecureChannelError,\n  SecureChannelErrorType,\n  type WebSocketConnectionError,\n} from \"@internal/secure-channel/model/Errors\";\n\nexport type ConnectToSecureChannelTaskArgs = {\n  connection: Either<WebSocketConnectionError, WebSocket>;\n  cryptoService?: CryptoService;\n};\n\nexport class ConnectToSecureChannelTask {\n  private readonly _connection: WebSocket;\n  private readonly _cryptoService: CryptoService;\n  private _deviceIdCaptured: boolean = false;\n  constructor(\n    private readonly _api: InternalApi,\n    private readonly _args: ConnectToSecureChannelTaskArgs,\n  ) {\n    if (this._args.connection.isRight()) {\n      this._connection = this._args.connection.extract();\n    } else {\n      throw new SecureChannelError(\n        `Invalid WebSocket connection: ${String(this._args.connection.extract())}`,\n      );\n    }\n    this._cryptoService = this._args.cryptoService ?? new NobleCryptoService();\n  }\n\n  run(): Observable<SecureChannelEvent> {\n    const reenableRefresher = this._api.disableRefresher(\n      \"connectToSecureChannel\",\n    );\n\n    const obs = new Observable<SecureChannelEvent>((subscriber) => {\n      let unsubscribed: boolean = false;\n      let ignoreNetworkEvents = false;\n      let communicationFinished = false;\n\n      const notifyError = (error: SecureChannelError) => {\n        subscriber.next({\n          type: SecureChannelEventType.Error,\n          error,\n        });\n        subscriber.complete();\n\n        // Netowrks events can be ignored once the obervable has been completed\n        ignoreNetworkEvents = true;\n      };\n\n      this._connection.onopen = () => {\n        subscriber.next({\n          type: SecureChannelEventType.Opened,\n        });\n      };\n\n      this._connection.onerror = (error) => {\n        if (ignoreNetworkEvents) {\n          return;\n        }\n\n        subscriber.next({\n          type: SecureChannelEventType.Error,\n          error: new SecureChannelError({\n            url: this._connection.url,\n            errorMessage: error.message,\n          }),\n        });\n        subscriber.complete();\n      };\n\n      this._connection.onclose = () => {\n        if (ignoreNetworkEvents) {\n          return;\n        }\n\n        if (communicationFinished) {\n          subscriber.next({\n            type: SecureChannelEventType.Closed,\n          });\n        } else {\n          subscriber.next({\n            type: SecureChannelEventType.Error,\n            error: new SecureChannelError({\n              url: this._connection.url,\n              errorMessage: \"Connection closed unexpectedly\",\n            }),\n          });\n        }\n        subscriber.complete();\n      };\n\n      this._connection.onmessage = async (event) => {\n        // When unsubscribed, ignore the message\n        if (unsubscribed) {\n          return;\n        }\n\n        // Parse input message\n        let input: InMessageType;\n        try {\n          const jsonData = JSON.parse(String(event.data));\n          if (this.isInMessageType(jsonData)) {\n            input = jsonData;\n          } else {\n            throw new Error(\"Data does not match InMessageType\");\n          }\n        } catch (_) {\n          notifyError(\n            new SecureChannelError({\n              url: this._connection.url,\n              errorMessage: `Invalid message received: ${String(event.data)}`,\n            }),\n          );\n          return;\n        }\n\n        // Execute message query\n        switch (input.query) {\n          case InMessageQueryEnum.EXCHANGE: {\n            const { nonce, data } = input;\n\n            // Exchange query should contain a single APDU\n            if (typeof data !== \"string\") {\n              notifyError(\n                new SecureChannelError(\n                  `${InMessageQueryEnum.EXCHANGE} data type should be an APDU`,\n                ),\n              );\n              return;\n            }\n\n            // APDU should be a valid hex string\n            const apdu = hexaStringToBuffer(data);\n            if (apdu === null || apdu.length < 5) {\n              notifyError(\n                new SecureChannelError(`Received invalid APDU data: ${data}`),\n              );\n              return;\n            }\n            subscriber.next({\n              type: SecureChannelEventType.PreExchange,\n              payload: { nonce, apdu },\n            });\n\n            // Notify permission requested\n            let permissionRequested = false;\n            if (\n              willRequestPermission(apdu) &&\n              !this.isSecureConnectionAllowed()\n            ) {\n              permissionRequested = true;\n              subscriber.next({\n                type: SecureChannelEventType.PermissionRequested,\n              });\n            }\n\n            // Send APDU to the device\n            const response = await this._api.sendApdu(apdu);\n            if (unsubscribed) {\n              return;\n            }\n\n            // Map device response\n            response.caseOf({\n              Left: (error) => {\n                notifyError(new SecureChannelError(error));\n              },\n              Right: (apduResponse: ApduResponse) => {\n                let outMessageResponse: OutMessageResponseEnum;\n                const deviceError = this.mapDeviceError(apduResponse);\n                if (deviceError === null) {\n                  outMessageResponse = OutMessageResponseEnum.SUCCESS;\n\n                  // Check if this is the first GetCertificate call\n                  if (!this._deviceIdCaptured && isGetCertificateApdu(apdu)) {\n                    this._deviceIdCaptured = true;\n                    const publicKey = extractPublicKey(apduResponse);\n                    if (publicKey) {\n                      // Compute SHA3-256 hash of the public key to get the device ID\n                      const deviceId = this._cryptoService.sha3_256(publicKey);\n                      subscriber.next({\n                        type: SecureChannelEventType.DeviceId,\n                        payload: { deviceId },\n                      });\n                    }\n                  }\n\n                  // Emit event for the exchange\n                  subscriber.next({\n                    type: SecureChannelEventType.Exchange,\n                    payload: {\n                      nonce,\n                      apdu,\n                      data: apduResponse.data,\n                      status: apduResponse.statusCode,\n                    },\n                  });\n\n                  // If manager consent was requested, notify the \"granted\" event\n                  if (permissionRequested) {\n                    subscriber.next({\n                      type: SecureChannelEventType.PermissionGranted,\n                    });\n                  }\n                } else {\n                  outMessageResponse = OutMessageResponseEnum.ERROR;\n                  notifyError(deviceError);\n                }\n\n                // Send the message back to the server\n                const message: OutMessageType = {\n                  nonce,\n                  response: outMessageResponse,\n                  data: bufferToHexaString(apduResponse.data, false),\n                };\n                this._connection.send(JSON.stringify(message));\n              },\n            });\n            break;\n          }\n          case InMessageQueryEnum.BULK: {\n            // Network not needed anymore during bulk APDUs sending\n            ignoreNetworkEvents = true;\n            this._connection.close();\n\n            // A valid array of APDUs is required in a bulk query\n            if (\n              !Array.isArray(input.data) ||\n              input.data.length === 0 ||\n              !input.data.every((data) => typeof data === \"string\")\n            ) {\n              notifyError(new SecureChannelError(\"Invalid bulk data received\"));\n              return;\n            }\n\n            for (let i = 0, len = input.data.length; i < len; i++) {\n              // APDU should be a valid hex string\n              const apdu = hexaStringToBuffer(input.data[i]!);\n              if (apdu === null || apdu.length < 5) {\n                notifyError(\n                  new SecureChannelError(\n                    `Received invalid APDU bulk data: ${input.data[i]}`,\n                  ),\n                );\n                return;\n              }\n\n              // Send APDU to the device\n              const response = await this._api.sendApdu(apdu);\n              if (unsubscribed) {\n                return;\n              }\n\n              // Map device response\n              if (response.isLeft()) {\n                notifyError(new SecureChannelError(response.extract()));\n                return;\n              } else if (response.isRight()) {\n                const deviceError = this.mapDeviceError(response.extract());\n                if (deviceError === null) {\n                  // Notify the progress\n                  subscriber.next({\n                    type: SecureChannelEventType.Progress,\n                    payload: {\n                      progress: +Number((i + 1) / len).toFixed(2),\n                      index: i,\n                      total: len,\n                    },\n                  });\n                } else {\n                  notifyError(deviceError);\n                  return;\n                }\n              }\n            }\n            communicationFinished = true;\n            subscriber.complete();\n            break;\n          }\n          case InMessageQueryEnum.SUCCESS: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            // Emit the result if there is any\n            const payload = input.result ?? input.data;\n            if (payload) {\n              subscriber.next({\n                type: SecureChannelEventType.Result,\n                payload: payload ?? \"\",\n              });\n            }\n            communicationFinished = true;\n            subscriber.complete();\n            break;\n          }\n          case InMessageQueryEnum.WARNING: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            subscriber.next({\n              type: SecureChannelEventType.Warning,\n              payload: { message: String(input.data) },\n            });\n            break;\n          }\n          case InMessageQueryEnum.ERROR: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            notifyError(\n              new SecureChannelError({\n                url: this._connection.url,\n                errorMessage: String(input.data),\n              }),\n            );\n          }\n        }\n      };\n\n      return () => {\n        reenableRefresher();\n        unsubscribed = true;\n        // Close the connection if it is open when unsubscribing\n        if (this._connection.readyState === WebSocket.OPEN) {\n          this._connection.close();\n        }\n      };\n    });\n\n    return obs;\n  }\n\n  /**\n   * Determines if a secure connection is already allowed based on the current device session state.\n   *\n   * @returns {boolean} `true` if a secure connection is allowed, otherwise `false`.\n   */\n  isSecureConnectionAllowed(): boolean {\n    const deviceSessionState = this._api.getDeviceSessionState();\n    return (\n      \"isSecureConnectionAllowed\" in deviceSessionState &&\n      deviceSessionState.isSecureConnectionAllowed\n    );\n  }\n\n  isInMessageType(data: unknown): data is InMessageType {\n    if (typeof data !== \"object\" || !data) {\n      return false;\n    }\n\n    const message = data as InMessageType;\n    return (\n      typeof message.uuid === \"string\" &&\n      typeof message.session === \"string\" &&\n      typeof message.query === \"string\" &&\n      Object.values(InMessageQueryEnum).includes(message.query) &&\n      typeof message.nonce === \"number\"\n    );\n  }\n\n  mapDeviceError(apduResponse: ApduResponse): SecureChannelError | null {\n    if (CommandUtils.isSuccessResponse(apduResponse)) {\n      return null;\n    }\n\n    // Device is locked\n    if (CommandUtils.isLockedDeviceResponse(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: `Device is locked`,\n        },\n        SecureChannelErrorType.DeviceLocked,\n      );\n    }\n\n    // User refused the permission\n    if (CommandUtils.isRefusedByUser(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"User refused on the device\",\n        },\n        SecureChannelErrorType.RefusedByUser,\n      );\n    }\n\n    // App already installed\n    if (CommandUtils.isAppAlreadyInstalled(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"App already installed\",\n        },\n        SecureChannelErrorType.AppAlreadyInstalled,\n      );\n    }\n\n    // Out of memory\n    if (CommandUtils.isOutOfMemory(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"Out of memory\",\n        },\n        SecureChannelErrorType.OutOfMemory,\n      );\n    }\n\n    return new SecureChannelError({\n      url: this._connection.url,\n      errorMessage: `Invalid status code: ${bufferToHexaString(\n        apduResponse.statusCode,\n      )}`,\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["ConnectToSecureChannelTask_exports", "__export", "ConnectToSecureChannelTask", "__toCommonJS", "import_isomorphic_ws", "import_rxjs", "import_CommandUtils", "import_types", "import_utils", "import_HexaString", "import_NobleCryptoService", "import_Errors", "_api", "_args", "reenableRefresher", "subscriber", "unsubscribed", "ignoreNetworkEvents", "communicationFinished", "notifyError", "error", "event", "input", "jsonData", "nonce", "data", "apdu", "permissionRequested", "response", "apduResponse", "outMessageResponse", "deviceError", "publicKey", "deviceId", "message", "i", "len", "payload", "WebSocket", "deviceSessionState"]
}
