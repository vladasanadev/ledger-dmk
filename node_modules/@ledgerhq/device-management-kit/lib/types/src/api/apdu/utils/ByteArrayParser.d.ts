import { type HexaString } from "../../utils/HexaString";
export type TaggedField = {
    readonly tag: number;
    readonly value: Uint8Array;
    readonly tlv: Uint8Array;
};
/**
 * ByteArrayParser is a utility class to help parse a byte array.
 *
 * It provides methods to extract fields of different types from the buffer.
 *
 * @example
 * ```
 * const parser = new ByteArrayParser(buffer);
 * const targetId = parser.encodeToHexaString(parser.extractFieldByLength(4));
 * const seVersion = parser.encodeToString(parser.extractFieldLVEncoded());
 * ```
 */
export declare class ByteArrayParser {
    private readonly buffer;
    private index;
    constructor(buffer: Uint8Array);
    /**
     * Test if the length is greater than the response length
     * @param length: number
     * @returns {boolean} - Returns false if the length is greater than the response length
     */
    testMinimalLength(length: number): boolean;
    /**
     * Extract a single byte from the response
     * @returns {number | undefined} - Returns the byte extracted from the response
     */
    extract8BitUInt(): number | undefined;
    /**
     * Extract a 16-bit unsigned integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 16-bit unsigned integer extracted from the response
     */
    extract16BitUInt(bigEndian?: boolean): number | undefined;
    /**
     * Extract a 16-bit signed integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 16-bit signed integer extracted from the response
     */
    extract16BitInt(bigEndian?: boolean): number | undefined;
    /**
     * Extract a 32-bit unsigned integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 32-bit unsigned integer extracted from the response
     */
    extract32BitUInt(bigEndian?: boolean): number | undefined;
    /**
     * Extract a 32-bit signed integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 32-bit signed integer extracted from the response
     */
    extract32BitInt(bigEndian?: boolean): number | undefined;
    /**
     * Extract a 64-bit unsigned integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 64-bit unsigned integer extracted from the response
     */
    extract64BitUInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a 64-bit signed integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 64-bit signed integer extracted from the response
     */
    extract64BitInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a 128-bit unsigned integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 128-bit unsigned integer extracted from the response
     */
    extract128BitUInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a 128-bit signed integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 128-bit signed integer extracted from the response
     */
    extract128BitInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a 256-bit unsigned integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 256-bit unsigned integer extracted from the response
     */
    extract256BitUInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a 256-bit signed integer from the response
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {number | undefined} - Returns the 256-bit signed integer extracted from the response
     */
    extract256BitInt(bigEndian?: boolean): bigint | undefined;
    /**
     * Extract a field of a specified length from the response
     * @param length: number - The length of the field to extract
     * @returns {Uint8Array | undefined} - Returns the field extracted from the response
     */
    extractFieldByLength(length: number): Uint8Array | undefined;
    /**
     * Extract a field from the response that is length-value encoded
     * @returns {Uint8Array | undefined} - Returns the field extracted from the response
     */
    extractFieldLVEncoded(): Uint8Array | undefined;
    /**
     * Extract a field from the response that is tag-length-value encoded
     * @returns {TaggedField | undefined} - Returns the field extracted from the response
     */
    extractFieldTLVEncoded(): TaggedField | undefined;
    /**
     * Encode a value to a hexadecimal string
     * @param value {Uint8Array} - The value to encode
     * @param prefix {boolean} - Whether to add a prefix to the encoded value
     * @returns {string} - The encoded value as a hexadecimal string
     */
    encodeToHexaString(value?: Uint8Array, prefix?: false): string;
    encodeToHexaString(value?: Uint8Array, prefix?: true): HexaString;
    /**
     * Encode a value to an ASCII string
     * @param value {Uint8Array} - The value to encode
     * @returns {string} - The encoded value as an ASCII string
     */
    encodeToString(value?: Uint8Array): string;
    /**
     * Get the current index of the parser
     * @returns {number} - The current index of the parser
     */
    getCurrentIndex(): number;
    /**
     * Reset the index of the parser to 0
     */
    resetIndex(): void;
    /**
     * Get the remaining length of the response
     * @returns {number} - The remaining length of the response
     */
    getUnparsedRemainingLength(): number;
    /**
     * Check whether the expected length is out of range
     * @param length: number
     * @returns {boolean} - Returns true if the expected length is out of range
     */
    private outOfRange;
    /**
     * Extract a number from the buffer
     * @param sizeInBits: bigint - The number size in bits, for example 16 for a uint16
     * @param signed: boolean - True is the number can be signed and converted to two's compliment
     * @param bigEndian: boolean - True to decode in big endian, false for little endian
     * @returns {bigint | undefined} - Returns the number extracted from the buffer
     */
    private extractNumber;
}
//# sourceMappingURL=ByteArrayParser.d.ts.map