import { type DeviceGeneralState, type EndorsementInformation, type OnboardingStatus, type WordsInformation } from "../../device/SecureElementFlags";
/**
 * Secure element flags parser class.
 */
export declare class SecureElementFlagsParser {
    private readonly seFlags;
    /**
     * Creates an instance of SecureElementFlags parser.
     * @param seFlags - The secure element flags as an Uint8Array, it comes from the response of the GetOsVersionCommand.
     */
    constructor(seFlags: Uint8Array);
    /**
     * Retrieves the general device state based on the secure element flags, which is the first byte of the flags.
     * @returns {DeviceGeneralState}
     */
    generalDeviceState(): DeviceGeneralState;
    /**
     * Retrieves the endorsement information based on the secure element flags, which is the second byte of the flags.
     * @returns {EndorsementInformation}
     * @throws Will throw an error if the method is not implemented.
     */
    endorsementInformation(): EndorsementInformation;
    /**
     * Retrieves the words information based on the secure element flags, which is the third byte of the flags.
     * @returns {WordsInformation}
     * @throws Will throw an error if the method is not implemented.
     */
    wordsInformation(): WordsInformation;
    /**
     * Retrieves the onboarding status based on the secure element flags, which is the fourth byte of the flags.
     * @returns {OnboardingStatus}
     * @throws Will throw an error if the method is not implemented.
     */
    onboardingStatus(): OnboardingStatus;
    /**
     * Check the nth bit in a byte, returns true if the bit is set, false otherwise.
     * @param byte - The byte to check.
     * @param n - The bit number to check.
     * @returns {boolean} - True if the bit is set, false otherwise.
     */
    _checkNthBitInByte(byte: number, n: number): boolean;
}
//# sourceMappingURL=SecureElementFlagsParser.d.ts.map