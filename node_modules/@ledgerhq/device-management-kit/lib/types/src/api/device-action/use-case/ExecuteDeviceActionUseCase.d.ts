import { DeviceAction, DeviceActionIntermediateValue, ExecuteDeviceActionReturnType } from "../../device-action/DeviceAction";
import { DmkError } from "../../Error";
import { LoggerPublisherService } from "../../logger-publisher/service/LoggerPublisherService";
import type { DeviceSessionService } from "../../../internal/device-session/service/DeviceSessionService";
export type ExecuteDeviceActionUseCaseArgs<Output, Input, Error extends DmkError, IntermediateValue extends DeviceActionIntermediateValue> = {
    /**
     * The device session id.
     */
    readonly sessionId: string;
    /**
     * The device action to execute.
     */
    readonly deviceAction: DeviceAction<Output, Input, Error, IntermediateValue>;
};
/**
 * Executes a device action to a device through a device session.
 */
export declare class ExecuteDeviceActionUseCase {
    private readonly _sessionService;
    private readonly _logger;
    constructor(sessionService: DeviceSessionService, loggerFactory: (tag: string) => LoggerPublisherService);
    /**
     * Executes a device action to a device through a device session.
     *
     * @param sessionId - The device session id.
     * @param deviceAction - The device action to execute
     * @returns An object containing an observable of the device action state, and a cancel function.
     */
    execute<Output, Error extends DmkError, IntermediateValue extends DeviceActionIntermediateValue, Input>({ sessionId, deviceAction, }: ExecuteDeviceActionUseCaseArgs<Output, Input, Error, IntermediateValue>): ExecuteDeviceActionReturnType<Output, Error, IntermediateValue>;
}
//# sourceMappingURL=ExecuteDeviceActionUseCase.d.ts.map