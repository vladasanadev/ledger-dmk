import{hexaStringToBuffer as b}from"../../utils/HexaString";import{APDU_MAX_PAYLOAD as a}from"./ApduBuilder";import{DataOverflowError as x,HexaStringEncodeError as i}from"./AppBuilderError";import{ByteArrayBuilder as n}from"./ByteArrayBuilder";const u=new Uint8Array([]),y=new Uint8Array([1]),A=new Uint8Array([128,129,130,131,132]),E=new Uint8Array([133,134,135,136]),p=new Uint8Array([3,161,162,163]),h=new Uint8Array([5,109,97,109,97,110]),s=new Uint8Array([2,240,241]),w=new Uint8Array([1,51,2,1,35,69,103,128,129,130,131,132,133,134,135,136,3,161,162,163,5,109,97,109,97,110,2,240,241]),l=new Uint8Array([...Array(255).fill(170)]),g=new Uint8Array([...Array(254).fill(170)]);let e;describe("ByteArrayBuilder",()=>{const d=(f,t,r,o)=>{if(o)switch(r){case 2:e.add16BitIntToData(f,t);break;case 4:e.add32BitIntToData(f,t);break;case 8:e.add64BitIntToData(f,t);break;case 16:e.add128BitIntToData(f,t);break;case 32:e.add256BitIntToData(f,t);break}else switch(r){case 2:e.add16BitUIntToData(f,t);break;case 4:e.add32BitUIntToData(f,t);break;case 8:e.add64BitUIntToData(f,t);break;case 16:e.add128BitUIntToData(f,t);break;case 32:e.add256BitUIntToData(f,t);break}};describe("clean",()=>{beforeEach(()=>{e=new n(a)}),it("should create an instance",()=>{expect(e).toBeDefined(),expect(e).toBeInstanceOf(n)})}),describe("simple",()=>{beforeEach(()=>{e=new n(a)}),it("should serialize with an empty body",()=>{expect(e.build()).toEqual(u)}),it("should serialize with an single byte body",()=>{e=new n(1),e.add8BitUIntToData(1),expect(e.build()).toEqual(y),expect(e.getErrors()).toEqual([])}),it.each([[2,!1,!0,13058,"3302"],[2,!1,!1,0x3302n,"0233"],[2,!0,!0,4200n,"1068"],[2,!0,!0,-4200n,"ef98"],[2,!0,!1,4200,"6810"],[2,!0,!1,-4200,"98ef"],[4,!1,!0,0x01234567n,"01234567"],[4,!1,!1,0x01234567n,"67452301"],[4,!0,!0,123456789,"075bcd15"],[4,!0,!0,-123456789,"f8a432eb"],[4,!0,!1,123456789,"15cd5b07"],[4,!0,!1,-123456789,"eb32a4f8"],[8,!1,!0,14147778004927559n,"0032435442584447"],[8,!1,!1,14147778004927559n,"4744584254433200"],[8,!0,!0,14147778004927559n,"0032435442584447"],[8,!0,!0,-14147778004927559n,"ffcdbcabbda7bbb9"],[8,!0,!1,14147778004927559n,"4744584254433200"],[8,!0,!1,-14147778004927559n,"b9bba7bdabbccdff"],[16,!1,!0,0x00324354425844470032435442584447n,"00324354425844470032435442584447"],[16,!1,!1,0x00324354425844470032435442584447n,"47445842544332004744584254433200"],[16,!0,!0,0x00324354425844470032435442584447n,"00324354425844470032435442584447"],[16,!0,!0,-0x00324354425844470032435442584447n,"ffcdbcabbda7bbb8ffcdbcabbda7bbb9"],[16,!0,!1,0x00324354425844470032435442584447n,"47445842544332004744584254433200"],[16,!0,!1,-0x00324354425844470032435442584447n,"b9bba7bdabbccdffb8bba7bdabbccdff"],[32,!1,!0,0x0032435442584447003243544258444700324354425844470032435442584447n,"0032435442584447003243544258444700324354425844470032435442584447"],[32,!1,!1,0x0032435442584447003243544258444700324354425844470032435442584447n,"4744584254433200474458425443320047445842544332004744584254433200"],[32,!0,!0,0x0032435442584447003243544258444700324354425844470032435442584447n,"0032435442584447003243544258444700324354425844470032435442584447"],[32,!0,!0,-0x0032435442584447003243544258444700324354425844470032435442584447n,"ffcdbcabbda7bbb8ffcdbcabbda7bbb8ffcdbcabbda7bbb8ffcdbcabbda7bbb9"],[32,!0,!1,0x0032435442584447003243544258444700324354425844470032435442584447n,"4744584254433200474458425443320047445842544332004744584254433200"],[32,!0,!1,-0x0032435442584447003243544258444700324354425844470032435442584447n,"b9bba7bdabbccdffb8bba7bdabbccdffb8bba7bdabbccdffb8bba7bdabbccdff"]])("serialize the following number: size %i, signed %s, bigEndian %s, value %i, expected %s",(f,t,r,o,c)=>{e=new n(f),d(o,r,f,t),expect(e.build()).toEqual(b(c)),expect(e.getErrors()).toEqual([]),e=new n(f-1),d(o,r,f,t),expect(e.getErrors().length).toEqual(1),expect(e.build()).toEqual(Uint8Array.from([]))}),it.each([[2,!1,!0,0xffffn,"ffff"],[2,!0,!0,0x7fffn,"7fff"],[2,!0,!0,-0x8000n,"8000"],[4,!1,!0,0xffffffffn,"ffffffff"],[4,!0,!0,0x7fffffffn,"7fffffff"],[4,!0,!0,-0x80000000n,"80000000"],[8,!1,!0,0xffffffffffffffffn,"ffffffffffffffff"],[8,!0,!0,0x7fffffffffffffffn,"7fffffffffffffff"],[8,!0,!0,-0x8000000000000000n,"8000000000000000"],[16,!1,!0,0xffffffffffffffffffffffffffffffffn,"ffffffffffffffffffffffffffffffff"],[16,!0,!0,0x7fffffffffffffffffffffffffffffffn,"7fffffffffffffffffffffffffffffff"],[16,!0,!0,-0x80000000000000000000000000000000n,"80000000000000000000000000000000"],[32,!1,!0,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"],[32,!0,!0,0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"],[32,!0,!0,-0x8000000000000000000000000000000000000000000000000000000000000000n,"8000000000000000000000000000000000000000000000000000000000000000"]])("serialize the number to the limit: size %i, signed %s, bigEndian %s, value %i, expected %s",(f,t,r,o,c)=>{e=new n(f),d(o,r,f,t),expect(e.build()).toEqual(b(c)),expect(e.getErrors()).toEqual([])}),it("Serialize from float to bigint",()=>{e=new n(4),e.add32BitIntToData(1234567893e-1,!1),expect(e.getErrors().length).toEqual(1),expect(e.build()).toEqual(Uint8Array.from([]))}),it("should serialize with an 5 byte body from an hexastring",()=>{e.addHexaStringToData("0x8081828384"),expect(e.build()).toEqual(A),expect(e.getErrors()).toEqual([])}),it("should serialize with an 4 byte body from an hexastring without '0x'",()=>{e.addHexaStringToData("85868788"),expect(e.build()).toEqual(E),expect(e.getErrors()).toEqual([])}),it("should serialize with an 4 byte body LV encoded from an hexastring",()=>{e.encodeInLVFromHexa("0xA1A2A3"),expect(e.build()).toEqual(p),expect(e.getErrors()).toEqual([])}),it("should serialize with an 4 byte body LV encoded from an ascci string",()=>{e.encodeInLVFromAscii("maman"),expect(e.build()).toEqual(h),expect(e.getErrors()).toEqual([])}),it("should serialize with an 4 byte body LV encoded from a buffer",()=>{const f=new Uint8Array([240,241]);e.encodeInLVFromBuffer(f),expect(e.build()).toEqual(s),expect(e.getErrors()).toEqual([])}),it("should serialize with an 4 byte body LV encoded from a buffer",()=>{const f=new Uint8Array([240,241]);e.encodeInLVFromBuffer(f),expect(e.build()).toEqual(s),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an ascii string",()=>{e.encodeInTLVFromAscii(5,"coucou"),expect(e.build()).toEqual(Uint8Array.from([5,6,99,111,117,99,111,117])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an hexastring",()=>{e.encodeInTLVFromHexa(5,"0xA1A2A3"),expect(e.build()).toEqual(Uint8Array.from([5,3,161,162,163])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from a buffer",()=>{e.encodeInTLVFromBuffer(6,Uint8Array.from([161,162,163,164])),expect(e.build()).toEqual(Uint8Array.from([6,4,161,162,163,164])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an uint8",()=>{e.encodeInTLVFromUInt8(6,86),expect(e.build()).toEqual(Uint8Array.from([6,1,86])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an uint16",()=>{e.encodeInTLVFromUInt16(6,13398),expect(e.build()).toEqual(Uint8Array.from([6,2,52,86])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an uint32",()=>{e.encodeInTLVFromUInt32(6,2417112150),expect(e.build()).toEqual(Uint8Array.from([6,4,144,18,52,86])),expect(e.getErrors()).toEqual([])}),it("should serialize with an TLV encoded from an uint64",()=>{e.encodeInTLVFromUInt64(6,95075813176406),expect(e.build()).toEqual(Uint8Array.from([6,8,0,0,86,120,144,18,52,86])),expect(e.getErrors()).toEqual([])}),it("should serialize with an complete body of 0xAA",()=>{const f=new Uint8Array(255).fill(170,0,255);e.addBufferToData(f),expect(e.build()).toEqual(l),expect(e.getErrors()).toEqual([])})}),describe("mixed",()=>{beforeEach(()=>{e=new n(a)}),it("should serialize with all previous field",()=>{let f=a;e.add8BitUIntToData(1),f--,expect(e.getAvailablePayloadLength()).toBe(f),e.add16BitUIntToData(13058),f-=2,expect(e.getAvailablePayloadLength()).toBe(f),e.add32BitUIntToData(19088743),f-=4,expect(e.getAvailablePayloadLength()).toBe(f),e.addHexaStringToData("0x8081828384"),f-=5,expect(e.getAvailablePayloadLength()).toBe(f),e.addHexaStringToData("85868788"),f-=4,expect(e.getAvailablePayloadLength()).toBe(f),e.encodeInLVFromHexa("0xA1A2A3"),f-=4,expect(e.getAvailablePayloadLength()).toBe(f),e.encodeInLVFromAscii("maman"),f-=6,expect(e.getAvailablePayloadLength()).toBe(f);const t=new Uint8Array([240,241]);e.encodeInLVFromBuffer(t),f-=3,expect(e.getAvailablePayloadLength()).toBe(f),expect(e.build()).toEqual(w)})}),describe("error",()=>{beforeEach(()=>{e=new n(a)}),it.each([[2,!1,!0,0x10000n],[2,!0,!0,0x8000n],[2,!0,!0,-0x8001n],[4,!1,!0,0x100000000n],[4,!0,!0,0x80000000n],[4,!0,!0,-0x80000001n],[8,!1,!0,0x10000000000000000n],[8,!0,!0,0x8000000000000000n],[8,!0,!0,-0x8000000000000001n]])("serialize the number overflowed: size %i, signed %s, bigEndian %s, value %i",(f,t,r,o)=>{e=new n(f),d(o,r,f,t),expect(e.getErrors().length).toEqual(1),expect(e.build()).toEqual(Uint8Array.from([]))}),it("error due to a string not well coded",()=>{e.addHexaStringToData(":08081828384").addHexaStringToData("80818n8384").addHexaStringToData("808182838z"),expect(e.build()).toEqual(u),expect(e.getAvailablePayloadLength()).toBe(a),expect(e.getErrors()).toEqual([new i(":08081828384"),new i("80818n8384"),new i("808182838z")])}),it("error due direct overflow",()=>{const f=new Uint8Array(256).fill(170,0,256);e.addBufferToData(f),expect(e.build()).toEqual(u),expect(e.getAvailablePayloadLength()).toBe(a),expect(e.getErrors()).toEqual([new x(f.toString())])}),it("error due to subsequent overflow with 1-byte array",()=>{const f=new Uint8Array(a).fill(170,0,a);e.addBufferToData(f),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0);const t=new Uint8Array(1);t.set([255],0),e.addBufferToData(t),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0),expect(e.getErrors()).toEqual([new x(t.toString())])}),it("error due to subsequent overflow with 1-char ascii",()=>{const f=new Uint8Array(a).fill(170,0,a);e.addBufferToData(f),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0);const t="a";e.addAsciiStringToData(t),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0),expect(e.getErrors()).toEqual([new x(new TextEncoder().encode(t).toString())])}),it("error due to subsequent overflow with 1-char hexastring",()=>{const f=new Uint8Array(a).fill(170,0,a);e.addBufferToData(f),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0),e.addHexaStringToData("0xB4").addHexaStringToData("e1"),expect(e.build()).toEqual(l),expect(e.getAvailablePayloadLength()).toBe(0),expect(e.getErrors()).toEqual([new x("180"),new x("225")])}),it("error due to empty values",()=>{const f="";e.addHexaStringToData(f).encodeInLVFromHexa(f),expect(e.build()).toEqual(u),expect(e.getAvailablePayloadLength()).toBe(a),expect(e.getErrors()).toEqual([new i(f),new i(f)])}),it("error due to subsequent overflow with 1-char LV",()=>{const f=new Uint8Array(a-1).fill(170,0,a-1);e.addBufferToData(f),expect(e.build()).toEqual(g),expect(e.getAvailablePayloadLength()).toBe(1);const t="n",r="e1",o=new Uint8Array(1);o.set([255],0),e.encodeInLVFromAscii(t).encodeInLVFromHexa(r).encodeInLVFromBuffer(o),expect(e.build()).toEqual(g),expect(e.getAvailablePayloadLength()).toBe(1),expect(e.getErrors()).toEqual([new x(t),new x(r),new x(o.toString())])})})});
//# sourceMappingURL=ByteArrayBuilder.test.js.map
