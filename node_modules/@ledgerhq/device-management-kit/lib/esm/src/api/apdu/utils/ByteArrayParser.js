import{bufferToHexaString as d}from"../../utils/HexaString";class s{constructor(e){this.buffer=e}index=0;testMinimalLength(e){return e<=this.buffer.length-this.index}extract8BitUInt(){if(!this.outOfRange(1))return this.buffer[this.index++]}extract16BitUInt(e=!0){const t=this.extractNumber(16n,!1,e);return t===void 0?void 0:Number(t)}extract16BitInt(e=!0){const t=this.extractNumber(16n,!0,e);return t===void 0?void 0:Number(t)}extract32BitUInt(e=!0){const t=this.extractNumber(32n,!1,e);return t===void 0?void 0:Number(t)}extract32BitInt(e=!0){const t=this.extractNumber(32n,!0,e);return t===void 0?void 0:Number(t)}extract64BitUInt(e=!0){return this.extractNumber(64n,!1,e)}extract64BitInt(e=!0){return this.extractNumber(64n,!0,e)}extract128BitUInt(e=!0){return this.extractNumber(128n,!1,e)}extract128BitInt(e=!0){return this.extractNumber(128n,!0,e)}extract256BitUInt(e=!0){return this.extractNumber(256n,!1,e)}extract256BitInt(e=!0){return this.extractNumber(256n,!0,e)}extractFieldByLength(e){if(this.outOfRange(e))return;if(e===0)return new Uint8Array;const t=this.buffer.slice(this.index,this.index+e);return this.index+=e,t}extractFieldLVEncoded(){const e=this.extract8BitUInt();if(e===void 0)return;if(e===0)return new Uint8Array;const t=this.extractFieldByLength(e);return t===void 0&&this.index--,t}extractFieldTLVEncoded(){if(this.outOfRange(2))return;const e=this.index,t=this.extract8BitUInt(),n=this.extractFieldLVEncoded();if(t===void 0||n===void 0){this.index--;return}const i=this.index;return{tag:t,value:n,tlv:this.buffer.slice(e,i)}}encodeToHexaString(e,t=!1){if(e===void 0||e.length===0)return"";const n=d(e);return t?n:n.slice(2)}encodeToString(e){let t="",n=0;if(!e)return t;for(;n<=e.length;){const i=e[n];i&&(t+=String.fromCharCode(i)),n++}return t}getCurrentIndex(){return this.index}resetIndex(){this.index=0}getUnparsedRemainingLength(){return this.buffer.length-this.index}outOfRange(e){return this.index+e>this.buffer.length}extractNumber(e,t,n){const i=Number(e)/8;if(this.outOfRange(i))return;let u=0n;if(n)for(let r=0;r<i;r++)u=u<<8n|BigInt(this.buffer[r+this.index]);else for(let r=i-1;r>=0;r--)u=u<<8n|BigInt(this.buffer[r+this.index]);if(t){const r=1n<<e-1n;u&r&&(u-=r<<1n)}return this.index+=i,u}}export{s as ByteArrayParser};
//# sourceMappingURL=ByteArrayParser.js.map
