import{hexaStringToBuffer as h}from"../../utils/HexaString";import{DataOverflowError as o,HexaStringEncodeError as B,ValueOverflowError as s}from"./AppBuilderError";const b=4294967295;class g{constructor(t=b){this.maxPayloadSize=t}data=new Uint8Array;errors=[];build=()=>this.data;tryBuild=()=>this.hasErrors()?void 0:this.data;add8BitUIntToData=t=>this.addNumberToData(t,8n,!1,!1);add16BitUIntToData=(t,r=!0)=>this.addNumberToData(t,16n,!1,r);add32BitUIntToData=(t,r=!0)=>this.addNumberToData(t,32n,!1,r);add64BitUIntToData=(t,r=!0)=>this.addNumberToData(t,64n,!1,r);add128BitUIntToData=(t,r=!0)=>this.addNumberToData(t,128n,!1,r);add256BitUIntToData=(t,r=!0)=>this.addNumberToData(t,256n,!1,r);add16BitIntToData=(t,r=!0)=>this.addNumberToData(t,16n,!0,r);add32BitIntToData=(t,r=!0)=>this.addNumberToData(t,32n,!0,r);add64BitIntToData=(t,r=!0)=>this.addNumberToData(t,64n,!0,r);add128BitIntToData=(t,r=!0)=>this.addNumberToData(t,128n,!0,r);add256BitIntToData=(t,r=!0)=>this.addNumberToData(t,256n,!0,r);addBufferToData=t=>this.hasEnoughLengthRemaining(t)?(this.data=Uint8Array.from([...this.data,...t]),this):(this.errors.push(new o(t.toString())),this);addHexaStringToData=t=>{const r=h(t);return r===null||r.length===0?(this.errors.push(new B(t)),this):(this.addBufferToData(r),this)};addAsciiStringToData=t=>{const r=new TextEncoder().encode(t);return this.addBufferToData(r),this};encodeInLVFromHexa=t=>{const r=h(t);return r===null||r.length===0?(this.errors.push(new B(t)),this):this.hasEnoughLengthRemaining(r,!0)?(this.add8BitUIntToData(r.length),this.addBufferToData(r),this):(this.errors.push(new o(t)),this)};encodeInLVFromBuffer=t=>this.hasEnoughLengthRemaining(t,!0)?(this.add8BitUIntToData(t.length),this.addBufferToData(t),this):(this.errors.push(new o(t.toString())),this);encodeInLVFromAscii=t=>this.hasEnoughLengthRemaining(t,!0)?(this.add8BitUIntToData(t.length),this.addAsciiStringToData(t),this):(this.errors.push(new o(t)),this);encodeInTLVFromAscii=(t,r)=>(this.add8BitUIntToData(t),this.encodeInLVFromAscii(r));encodeInTLVFromHexa=(t,r)=>(this.add8BitUIntToData(t),this.encodeInLVFromHexa(r));encodeInTLVFromBuffer=(t,r)=>(this.add8BitUIntToData(t),this.encodeInLVFromBuffer(r));encodeInTLVFromUInt8=(t,r)=>(this.add8BitUIntToData(t),this.add8BitUIntToData(1),this.add8BitUIntToData(r));encodeInTLVFromUInt16=(t,r,e=!0)=>(this.add8BitUIntToData(t),this.add8BitUIntToData(2),this.add16BitUIntToData(r,e));encodeInTLVFromUInt32=(t,r,e=!0)=>(this.add8BitUIntToData(t),this.add8BitUIntToData(4),this.add32BitUIntToData(r,e));encodeInTLVFromUInt64=(t,r,e=!0)=>(this.add8BitUIntToData(t),this.add8BitUIntToData(8),this.add64BitUIntToData(r,e));getAvailablePayloadLength=()=>this.maxPayloadSize-this.data.length;getErrors=()=>this.errors;hasErrors=()=>this.errors.length!==0;hasEnoughLengthRemaining=(t,r=!1)=>this.data.length+t.length+(r?1:0)<=this.maxPayloadSize;addNumberToData(t,r,e,n){let i=this.checkBoundsAndConvert(t,r,e);if(i===void 0)return this;const d=Number(r)/8,u=new Uint8Array(d);if(n)for(let a=d-1;a>=0;a--)u[a]=Number(i&0xffn),i>>=8n;else for(let a=0;a<d;a++)u[a]=Number(i&0xffn),i>>=8n;return this.addBufferToData(u)}checkBoundsAndConvert(t,r,e){if(typeof t=="number"){if(!Number.isInteger(t)||t>Number.MAX_SAFE_INTEGER){this.errors.push(new s(t.toString()));return}t=BigInt(t)}if(e){const n=1n<<r-1n;if(t>=n||t<-n){this.errors.push(new s(t.toString(),n-1n));return}if(t<0n){const i=(1n<<r)-1n;t=-t,t=(~t&i)+1n}}else{const n=1n<<r;if(t<0||t>=n){this.errors.push(new s(t.toString(),n-1n));return}}return t}}export{g as ByteArrayBuilder};
//# sourceMappingURL=ByteArrayBuilder.js.map
