{
  "version": 3,
  "sources": ["../../../../../../../src/api/secure-channel/device-action/UninstallApp/UninstallAppDeviceAction.test.ts"],
  "sourcesContent": ["import { Right } from \"purify-ts\";\nimport { of, throwError } from \"rxjs\";\n\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { type GetOsVersionResponse } from \"@api/command/os/GetOsVersionCommand\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport {\n  setupGoToDashboardMock,\n  setupListInstalledAppsMock,\n} from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport {\n  type DeviceSessionState,\n  DeviceSessionStateType,\n} from \"@api/device-session/DeviceSessionState\";\nimport { type InstalledApp } from \"@api/secure-channel/device-action/ListInstalledApps/types\";\nimport {\n  type SecureChannelEvent,\n  SecureChannelEventType,\n} from \"@api/secure-channel/task/types\";\nimport { type Application } from \"@internal/manager-api/model/Application\";\nimport { SecureChannelError } from \"@internal/secure-channel/model/Errors\";\n\nimport { type UninstallAppDAState } from \"./types\";\nimport { UninstallAppDeviceAction } from \"./UninstallAppDeviceAction\";\n\nvi.mock(\n  \"@api/secure-channel/device-action/ListInstalledApps/ListInstalledAppsDeviceAction\",\n);\nvi.mock(\"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\");\n\ndescribe(\"UninstallAppDeviceAction\", () => {\n  const getOsVersionMock = vi.fn();\n  const getAppsByHashMock = vi.fn();\n  const uninstallAppMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n  const extractDependenciesMock = () => ({\n    getOsVersion: getOsVersionMock,\n    getAppsByHash: getAppsByHashMock,\n    uninstallApp: uninstallAppMock,\n    getDeviceSessionState: getDeviceSessionStateMock,\n    setDeviceSessionState: setDeviceSessionStateMock,\n  });\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  it(\"should finish successfully when the app is not installed on the device\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Completed,\n          output: undefined,\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Ethereum\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish successfully when the app is installed on the device\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n        { installedApps: [] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      getAppsByHashMock.mockResolvedValue(\n        Right([\n          {\n            versionName: \"Bitcoin\",\n            perso: \"test_perso\",\n            firmware: \"test_firmware_for_bitcoin\",\n            firmwareKey: \"test_firmware_key_for_bitcoin\",\n            hash: \"test_hash_for_bitcoin\",\n          } as Application,\n        ]),\n      );\n      uninstallAppMock.mockReturnValue(\n        of({\n          type: SecureChannelEventType.Exchange,\n        } as SecureChannelEvent),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Completed,\n          output: undefined,\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when the app is a dependency of other installed apps\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        {\n          installedApps: [\n            { name: \"Bitcoin\" },\n            { name: \"Testcoin\" },\n          ] as InstalledApp[],\n        },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      getAppsByHashMock.mockResolvedValue(\n        Right([\n          {\n            versionName: \"Testcoin\",\n            parentName: \"Bitcoin\",\n          },\n          {\n            versionName: \"Bitcoin\",\n          },\n        ] as Application[]),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new UnknownDAError(\n            \"App to uninstall is a dependency of another installed app\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when the app is not found in manager API\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({} as DeviceSessionState);\n      getAppsByHashMock.mockResolvedValueOnce(Right([]));\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new UnknownDAError(\n            \"App to uninstall not found in manager API\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should finish unsuccessfully when there is error in uninstallApp\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupListInstalledAppsMock([\n        { installedApps: [{ name: \"Bitcoin\" } as InstalledApp] },\n      ]);\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: 12345678,\n            secureElementFlags: {\n              isSecureConnectionAllowed: true,\n            },\n          } as GetOsVersionResponse,\n        }),\n      );\n      getDeviceSessionStateMock.mockReturnValue({} as DeviceSessionState);\n      getAppsByHashMock.mockResolvedValueOnce(\n        Right([{ versionName: \"Bitcoin\" } as Application]),\n      );\n      uninstallAppMock.mockReturnValue(\n        throwError(\n          () => new SecureChannelError(\"Uninstall app error in secure channel\"),\n        ),\n      );\n\n      const expectedStates: Array<UninstallAppDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new SecureChannelError(\n            \"Uninstall app error in secure channel\",\n          ),\n        },\n      ];\n\n      const uninstallAppDeviceAction = new UninstallAppDeviceAction({\n        input: { appName: \"Bitcoin\" },\n      });\n      vi.spyOn(\n        uninstallAppDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        uninstallAppDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n});\n"],
  "mappings": "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",
  "names": ["Right", "of", "throwError", "CommandResultFactory", "DeviceStatus", "makeDeviceActionInternalApiMock", "setupGoToDashboardMock", "setupListInstalledAppsMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "UnknownDAError", "DeviceSessionStateType", "SecureChannelEventType", "SecureChannelError", "UninstallAppDeviceAction", "getOsVersionMock", "getAppsByHashMock", "uninstallAppMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "extractDependenciesMock", "resolve", "reject", "expectedStates", "uninstallAppDeviceAction"]
}
