{
  "version": 3,
  "sources": ["../../../../../../../src/api/secure-channel/device-action/GenuineCheck/GenuineCheckDeviceAction.test.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\nimport { concat, of, throwError } from \"rxjs\";\n\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGoToDashboardMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport {\n  type SecureChannelEventPayload,\n  SecureChannelEventType,\n} from \"@api/secure-channel/task/types\";\nimport { type DeviceVersion } from \"@internal/manager-api/model/Device\";\nimport { HttpFetchApiError } from \"@internal/manager-api/model/Errors\";\nimport { type FinalFirmware } from \"@internal/manager-api/model/Firmware\";\nimport { SecureChannelError } from \"@internal/secure-channel/model/Errors\";\n\nimport { GenuineCheckDeviceAction } from \"./GenuineCheckDeviceAction\";\nimport { type GenuineCheckDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\");\n\ndescribe(\"GenuineCheckDeviceAction\", () => {\n  const getOsVersionMock = vi.fn();\n  const getDeviceVersionMock = vi.fn();\n  const getFirmwareVersionMock = vi.fn();\n  const genuineCheckMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n\n  const extractDependenciesMock = () => ({\n    getOsVersion: getOsVersionMock,\n    getDeviceVersion: getDeviceVersionMock,\n    getFirmwareVersion: getFirmwareVersionMock,\n    genuineCheck: genuineCheckMock,\n    getDeviceSessionState: getDeviceSessionStateMock,\n    setDeviceSessionState: setDeviceSessionStateMock,\n  });\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  it(\"should return the result of the genuine check\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: \"123456\",\n            secureElementFlags: {\n              isSecureConnectionAllowed: false,\n            },\n          },\n        }),\n      );\n      getDeviceVersionMock.mockResolvedValue(\n        Right({ id: 123456 } as DeviceVersion),\n      );\n      getFirmwareVersionMock.mockResolvedValue(\n        Right({ perso: \"perso_test\" } as FinalFirmware),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      genuineCheckMock.mockReturnValue(\n        of(\n          {\n            type: SecureChannelEventType.Exchange,\n            payload: {\n              data: new Uint8Array([0x00, 0x01, 0x02, 0x03]),\n            } as SecureChannelEventPayload[\"Exchange\"],\n          },\n          {\n            type: SecureChannelEventType.PermissionRequested,\n          },\n          {\n            type: SecureChannelEventType.PermissionGranted,\n          },\n          {\n            type: SecureChannelEventType.Result,\n            payload: \"0000\",\n          },\n        ),\n      );\n\n      const expectedStates: Array<GenuineCheckDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction:\n              UserInteractionRequired.AllowSecureConnection,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Completed,\n          output: { isGenuine: true },\n        },\n      ];\n\n      const genuineCheckDeviceAction = new GenuineCheckDeviceAction({\n        input: {},\n      });\n      vi.spyOn(\n        genuineCheckDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        genuineCheckDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should return error when error occurs in fetching device version\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: \"123456\",\n            secureElementFlags: {\n              isSecureConnectionAllowed: false,\n            },\n          },\n        }),\n      );\n      getDeviceVersionMock.mockResolvedValue(\n        Left(new HttpFetchApiError(\"Device version fetch failed\")),\n      );\n      getFirmwareVersionMock.mockResolvedValue(\n        Right({ perso: \"perso_test\" } as FinalFirmware),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      genuineCheckMock.mockReturnValue(\n        of(\n          {\n            type: SecureChannelEventType.Exchange,\n            payload: {\n              data: new Uint8Array([0x00, 0x01, 0x02, 0x03]),\n            } as SecureChannelEventPayload[\"Exchange\"],\n          },\n          {\n            type: SecureChannelEventType.Result,\n            payload: \"0000\",\n          },\n        ),\n      );\n\n      const expectedStates: Array<GenuineCheckDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new HttpFetchApiError(\"Device version fetch failed\"),\n        },\n      ];\n\n      const genuineCheckDeviceAction = new GenuineCheckDeviceAction({\n        input: {},\n      });\n      vi.spyOn(\n        genuineCheckDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        genuineCheckDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should return error when error occurs in fetching firmware version\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: \"123456\",\n            secureElementFlags: {\n              isSecureConnectionAllowed: false,\n            },\n          },\n        }),\n      );\n      getDeviceVersionMock.mockResolvedValue(\n        Right({ id: 123456 } as DeviceVersion),\n      );\n      getFirmwareVersionMock.mockResolvedValue(\n        Left(new HttpFetchApiError(\"Firmware version fetch failed\")),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      genuineCheckMock.mockReturnValue(\n        of(\n          {\n            type: SecureChannelEventType.Exchange,\n            payload: {\n              data: new Uint8Array([0x00, 0x01, 0x02, 0x03]),\n            } as SecureChannelEventPayload[\"Exchange\"],\n          },\n          {\n            type: SecureChannelEventType.Result,\n            payload: \"0000\",\n          },\n        ),\n      );\n\n      const expectedStates: Array<GenuineCheckDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new HttpFetchApiError(\"Firmware version fetch failed\"),\n        },\n      ];\n\n      const genuineCheckDeviceAction = new GenuineCheckDeviceAction({\n        input: {},\n      });\n      vi.spyOn(\n        genuineCheckDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        genuineCheckDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n  it(\"should return error when error occurs in communicating with secure channel\", () =>\n    new Promise<void>((resolve, reject) => {\n      setupGoToDashboardMock();\n      getOsVersionMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            targetId: \"123456\",\n            secureElementFlags: {\n              isSecureConnectionAllowed: false,\n            },\n          },\n        }),\n      );\n      getDeviceVersionMock.mockResolvedValue(\n        Right({ id: 123456 } as DeviceVersion),\n      );\n      getFirmwareVersionMock.mockResolvedValue(\n        Right({ perso: \"perso_test\" } as FinalFirmware),\n      );\n      getDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        isSecureConnectionAllowed: false,\n      });\n      genuineCheckMock.mockReturnValue(\n        concat(\n          of({\n            type: SecureChannelEventType.Exchange,\n            payload: {\n              data: new Uint8Array([0x00, 0x01, 0x02, 0x03]),\n            } as SecureChannelEventPayload[\"Exchange\"],\n          }),\n          throwError(() => new SecureChannelError(\"Secure channel error\")),\n        ),\n      );\n\n      const expectedStates: Array<GenuineCheckDAState> = [\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Pending,\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Error,\n          error: new SecureChannelError(\"Secure channel error\"),\n        },\n      ];\n\n      const genuineCheckDeviceAction = new GenuineCheckDeviceAction({\n        input: {},\n      });\n      vi.spyOn(\n        genuineCheckDeviceAction,\n        \"extractDependencies\",\n      ).mockImplementation(extractDependenciesMock);\n\n      testDeviceActionStates(\n        genuineCheckDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n    }));\n});\n"],
  "mappings": "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",
  "names": ["Left", "Right", "concat", "of", "throwError", "CommandResultFactory", "DeviceStatus", "makeDeviceActionInternalApiMock", "setupGoToDashboardMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "DeviceSessionStateType", "SecureChannelEventType", "HttpFetchApiError", "SecureChannelError", "GenuineCheckDeviceAction", "getOsVersionMock", "getDeviceVersionMock", "getFirmwareVersionMock", "genuineCheckMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "extractDependenciesMock", "resolve", "reject", "expectedStates", "genuineCheckDeviceAction"]
}
