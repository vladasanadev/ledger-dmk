import I from"isomorphic-ws";import{Observable as T}from"rxjs";import{CommandUtils as h}from"../../command/utils/CommandUtils";import{InMessageQueryEnum as y,OutMessageResponseEnum as w,SecureChannelEventType as i}from"../../secure-channel/task/types";import{extractPublicKey as O,isGetCertificateApdu as R,willRequestPermission as D}from"../../secure-channel/utils";import{bufferToHexaString as x,hexaStringToBuffer as A}from"../../utils/HexaString";import{NobleCryptoService as N}from"../../../internal/crypto/NobleCryptoService";import{SecureChannelError as r,SecureChannelErrorType as S}from"../../../internal/secure-channel/model/Errors";class j{constructor(n,c){this._api=n;this._args=c;if(this._args.connection.isRight())this._connection=this._args.connection.extract();else throw new r(`Invalid WebSocket connection: ${String(this._args.connection.extract())}`);this._cryptoService=this._args.cryptoService??new N}_connection;_cryptoService;_deviceIdCaptured=!1;run(){const n=this._api.disableRefresher("connectToSecureChannel");return new T(t=>{let g=!1,l=!1,v=!1;const a=f=>{t.next({type:i.Error,error:f}),t.complete(),l=!0};return this._connection.onopen=()=>{t.next({type:i.Opened})},this._connection.onerror=f=>{l||(t.next({type:i.Error,error:new r({url:this._connection.url,errorMessage:f.message})}),t.complete())},this._connection.onclose=()=>{l||(v?t.next({type:i.Closed}):t.next({type:i.Error,error:new r({url:this._connection.url,errorMessage:"Connection closed unexpectedly"})}),t.complete())},this._connection.onmessage=async f=>{if(g)return;let o;try{const e=JSON.parse(String(f.data));if(this.isInMessageType(e))o=e;else throw new Error("Data does not match InMessageType")}catch{a(new r({url:this._connection.url,errorMessage:`Invalid message received: ${String(f.data)}`}));return}switch(o.query){case y.EXCHANGE:{const{nonce:e,data:p}=o;if(typeof p!="string"){a(new r(`${y.EXCHANGE} data type should be an APDU`));return}const s=A(p);if(s===null||s.length<5){a(new r(`Received invalid APDU data: ${p}`));return}t.next({type:i.PreExchange,payload:{nonce:e,apdu:s}});let u=!1;D(s)&&!this.isSecureConnectionAllowed()&&(u=!0,t.next({type:i.PermissionRequested}));const m=await this._api.sendApdu(s);if(g)return;m.caseOf({Left:d=>{a(new r(d))},Right:d=>{let C;const E=this.mapDeviceError(d);if(E===null){if(C=w.SUCCESS,!this._deviceIdCaptured&&R(s)){this._deviceIdCaptured=!0;const _=O(d);if(_){const k=this._cryptoService.sha3_256(_);t.next({type:i.DeviceId,payload:{deviceId:k}})}}t.next({type:i.Exchange,payload:{nonce:e,apdu:s,data:d.data,status:d.statusCode}}),u&&t.next({type:i.PermissionGranted})}else C=w.ERROR,a(E);const M={nonce:e,response:C,data:x(d.data,!1)};this._connection.send(JSON.stringify(M))}});break}case y.BULK:{if(l=!0,this._connection.close(),!Array.isArray(o.data)||o.data.length===0||!o.data.every(e=>typeof e=="string")){a(new r("Invalid bulk data received"));return}for(let e=0,p=o.data.length;e<p;e++){const s=A(o.data[e]);if(s===null||s.length<5){a(new r(`Received invalid APDU bulk data: ${o.data[e]}`));return}const u=await this._api.sendApdu(s);if(g)return;if(u.isLeft()){a(new r(u.extract()));return}else if(u.isRight()){const m=this.mapDeviceError(u.extract());if(m===null)t.next({type:i.Progress,payload:{progress:+Number((e+1)/p).toFixed(2),index:e,total:p}});else{a(m);return}}}v=!0,t.complete();break}case y.SUCCESS:{if(l)break;const e=o.result??o.data;e&&t.next({type:i.Result,payload:e??""}),v=!0,t.complete();break}case y.WARNING:{if(l)break;t.next({type:i.Warning,payload:{message:String(o.data)}});break}case y.ERROR:{if(l)break;a(new r({url:this._connection.url,errorMessage:String(o.data)}))}}},()=>{n(),g=!0,this._connection.readyState===I.OPEN&&this._connection.close()}})}isSecureConnectionAllowed(){const n=this._api.getDeviceSessionState();return"isSecureConnectionAllowed"in n&&n.isSecureConnectionAllowed}isInMessageType(n){if(typeof n!="object"||!n)return!1;const c=n;return typeof c.uuid=="string"&&typeof c.session=="string"&&typeof c.query=="string"&&Object.values(y).includes(c.query)&&typeof c.nonce=="number"}mapDeviceError(n){return h.isSuccessResponse(n)?null:h.isLockedDeviceResponse(n)?new r({url:this._connection.url,errorMessage:"Device is locked"},S.DeviceLocked):h.isRefusedByUser(n)?new r({url:this._connection.url,errorMessage:"User refused on the device"},S.RefusedByUser):h.isAppAlreadyInstalled(n)?new r({url:this._connection.url,errorMessage:"App already installed"},S.AppAlreadyInstalled):h.isOutOfMemory(n)?new r({url:this._connection.url,errorMessage:"Out of memory"},S.OutOfMemory):new r({url:this._connection.url,errorMessage:`Invalid status code: ${x(n.statusCode)}`})}}export{j as ConnectToSecureChannelTask};
//# sourceMappingURL=ConnectToSecureChannelTask.js.map
