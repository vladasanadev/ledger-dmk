{
  "version": 3,
  "sources": ["../../../../../../src/api/secure-channel/task/ConnectToSecureChannelTask.ts"],
  "sourcesContent": ["import WebSocket from \"isomorphic-ws\";\nimport { type Either } from \"purify-ts\";\nimport { Observable } from \"rxjs\";\n\nimport { CommandUtils } from \"@api/command/utils/CommandUtils\";\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { type ApduResponse } from \"@api/device-session/ApduResponse\";\nimport {\n  InMessageQueryEnum,\n  type InMessageType,\n  OutMessageResponseEnum,\n  type OutMessageType,\n  type SecureChannelEvent,\n  SecureChannelEventType,\n} from \"@api/secure-channel/task/types\";\nimport {\n  extractPublicKey,\n  isGetCertificateApdu,\n  willRequestPermission,\n} from \"@api/secure-channel/utils\";\nimport { bufferToHexaString, hexaStringToBuffer } from \"@api/utils/HexaString\";\nimport { type CryptoService } from \"@internal/crypto/CryptoService\";\nimport { NobleCryptoService } from \"@internal/crypto/NobleCryptoService\";\nimport {\n  SecureChannelError,\n  SecureChannelErrorType,\n  type WebSocketConnectionError,\n} from \"@internal/secure-channel/model/Errors\";\n\nexport type ConnectToSecureChannelTaskArgs = {\n  connection: Either<WebSocketConnectionError, WebSocket>;\n  cryptoService?: CryptoService;\n};\n\nexport class ConnectToSecureChannelTask {\n  private readonly _connection: WebSocket;\n  private readonly _cryptoService: CryptoService;\n  private _deviceIdCaptured: boolean = false;\n  constructor(\n    private readonly _api: InternalApi,\n    private readonly _args: ConnectToSecureChannelTaskArgs,\n  ) {\n    if (this._args.connection.isRight()) {\n      this._connection = this._args.connection.extract();\n    } else {\n      throw new SecureChannelError(\n        `Invalid WebSocket connection: ${String(this._args.connection.extract())}`,\n      );\n    }\n    this._cryptoService = this._args.cryptoService ?? new NobleCryptoService();\n  }\n\n  run(): Observable<SecureChannelEvent> {\n    const reenableRefresher = this._api.disableRefresher(\n      \"connectToSecureChannel\",\n    );\n\n    const obs = new Observable<SecureChannelEvent>((subscriber) => {\n      let unsubscribed: boolean = false;\n      let ignoreNetworkEvents = false;\n      let communicationFinished = false;\n\n      const notifyError = (error: SecureChannelError) => {\n        subscriber.next({\n          type: SecureChannelEventType.Error,\n          error,\n        });\n        subscriber.complete();\n\n        // Netowrks events can be ignored once the obervable has been completed\n        ignoreNetworkEvents = true;\n      };\n\n      this._connection.onopen = () => {\n        subscriber.next({\n          type: SecureChannelEventType.Opened,\n        });\n      };\n\n      this._connection.onerror = (error) => {\n        if (ignoreNetworkEvents) {\n          return;\n        }\n\n        subscriber.next({\n          type: SecureChannelEventType.Error,\n          error: new SecureChannelError({\n            url: this._connection.url,\n            errorMessage: error.message,\n          }),\n        });\n        subscriber.complete();\n      };\n\n      this._connection.onclose = () => {\n        if (ignoreNetworkEvents) {\n          return;\n        }\n\n        if (communicationFinished) {\n          subscriber.next({\n            type: SecureChannelEventType.Closed,\n          });\n        } else {\n          subscriber.next({\n            type: SecureChannelEventType.Error,\n            error: new SecureChannelError({\n              url: this._connection.url,\n              errorMessage: \"Connection closed unexpectedly\",\n            }),\n          });\n        }\n        subscriber.complete();\n      };\n\n      this._connection.onmessage = async (event) => {\n        // When unsubscribed, ignore the message\n        if (unsubscribed) {\n          return;\n        }\n\n        // Parse input message\n        let input: InMessageType;\n        try {\n          const jsonData = JSON.parse(String(event.data));\n          if (this.isInMessageType(jsonData)) {\n            input = jsonData;\n          } else {\n            throw new Error(\"Data does not match InMessageType\");\n          }\n        } catch (_) {\n          notifyError(\n            new SecureChannelError({\n              url: this._connection.url,\n              errorMessage: `Invalid message received: ${String(event.data)}`,\n            }),\n          );\n          return;\n        }\n\n        // Execute message query\n        switch (input.query) {\n          case InMessageQueryEnum.EXCHANGE: {\n            const { nonce, data } = input;\n\n            // Exchange query should contain a single APDU\n            if (typeof data !== \"string\") {\n              notifyError(\n                new SecureChannelError(\n                  `${InMessageQueryEnum.EXCHANGE} data type should be an APDU`,\n                ),\n              );\n              return;\n            }\n\n            // APDU should be a valid hex string\n            const apdu = hexaStringToBuffer(data);\n            if (apdu === null || apdu.length < 5) {\n              notifyError(\n                new SecureChannelError(`Received invalid APDU data: ${data}`),\n              );\n              return;\n            }\n            subscriber.next({\n              type: SecureChannelEventType.PreExchange,\n              payload: { nonce, apdu },\n            });\n\n            // Notify permission requested\n            let permissionRequested = false;\n            if (\n              willRequestPermission(apdu) &&\n              !this.isSecureConnectionAllowed()\n            ) {\n              permissionRequested = true;\n              subscriber.next({\n                type: SecureChannelEventType.PermissionRequested,\n              });\n            }\n\n            // Send APDU to the device\n            const response = await this._api.sendApdu(apdu);\n            if (unsubscribed) {\n              return;\n            }\n\n            // Map device response\n            response.caseOf({\n              Left: (error) => {\n                notifyError(new SecureChannelError(error));\n              },\n              Right: (apduResponse: ApduResponse) => {\n                let outMessageResponse: OutMessageResponseEnum;\n                const deviceError = this.mapDeviceError(apduResponse);\n                if (deviceError === null) {\n                  outMessageResponse = OutMessageResponseEnum.SUCCESS;\n\n                  // Check if this is the first GetCertificate call\n                  if (!this._deviceIdCaptured && isGetCertificateApdu(apdu)) {\n                    this._deviceIdCaptured = true;\n                    const publicKey = extractPublicKey(apduResponse);\n                    if (publicKey) {\n                      // Compute SHA3-256 hash of the public key to get the device ID\n                      const deviceId = this._cryptoService.sha3_256(publicKey);\n                      subscriber.next({\n                        type: SecureChannelEventType.DeviceId,\n                        payload: { deviceId },\n                      });\n                    }\n                  }\n\n                  // Emit event for the exchange\n                  subscriber.next({\n                    type: SecureChannelEventType.Exchange,\n                    payload: {\n                      nonce,\n                      apdu,\n                      data: apduResponse.data,\n                      status: apduResponse.statusCode,\n                    },\n                  });\n\n                  // If manager consent was requested, notify the \"granted\" event\n                  if (permissionRequested) {\n                    subscriber.next({\n                      type: SecureChannelEventType.PermissionGranted,\n                    });\n                  }\n                } else {\n                  outMessageResponse = OutMessageResponseEnum.ERROR;\n                  notifyError(deviceError);\n                }\n\n                // Send the message back to the server\n                const message: OutMessageType = {\n                  nonce,\n                  response: outMessageResponse,\n                  data: bufferToHexaString(apduResponse.data, false),\n                };\n                this._connection.send(JSON.stringify(message));\n              },\n            });\n            break;\n          }\n          case InMessageQueryEnum.BULK: {\n            // Network not needed anymore during bulk APDUs sending\n            ignoreNetworkEvents = true;\n            this._connection.close();\n\n            // A valid array of APDUs is required in a bulk query\n            if (\n              !Array.isArray(input.data) ||\n              input.data.length === 0 ||\n              !input.data.every((data) => typeof data === \"string\")\n            ) {\n              notifyError(new SecureChannelError(\"Invalid bulk data received\"));\n              return;\n            }\n\n            for (let i = 0, len = input.data.length; i < len; i++) {\n              // APDU should be a valid hex string\n              const apdu = hexaStringToBuffer(input.data[i]!);\n              if (apdu === null || apdu.length < 5) {\n                notifyError(\n                  new SecureChannelError(\n                    `Received invalid APDU bulk data: ${input.data[i]}`,\n                  ),\n                );\n                return;\n              }\n\n              // Send APDU to the device\n              const response = await this._api.sendApdu(apdu);\n              if (unsubscribed) {\n                return;\n              }\n\n              // Map device response\n              if (response.isLeft()) {\n                notifyError(new SecureChannelError(response.extract()));\n                return;\n              } else if (response.isRight()) {\n                const deviceError = this.mapDeviceError(response.extract());\n                if (deviceError === null) {\n                  // Notify the progress\n                  subscriber.next({\n                    type: SecureChannelEventType.Progress,\n                    payload: {\n                      progress: +Number((i + 1) / len).toFixed(2),\n                      index: i,\n                      total: len,\n                    },\n                  });\n                } else {\n                  notifyError(deviceError);\n                  return;\n                }\n              }\n            }\n            communicationFinished = true;\n            subscriber.complete();\n            break;\n          }\n          case InMessageQueryEnum.SUCCESS: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            // Emit the result if there is any\n            const payload = input.result ?? input.data;\n            if (payload) {\n              subscriber.next({\n                type: SecureChannelEventType.Result,\n                payload: payload ?? \"\",\n              });\n            }\n            communicationFinished = true;\n            subscriber.complete();\n            break;\n          }\n          case InMessageQueryEnum.WARNING: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            subscriber.next({\n              type: SecureChannelEventType.Warning,\n              payload: { message: String(input.data) },\n            });\n            break;\n          }\n          case InMessageQueryEnum.ERROR: {\n            if (ignoreNetworkEvents) {\n              break;\n            }\n            notifyError(\n              new SecureChannelError({\n                url: this._connection.url,\n                errorMessage: String(input.data),\n              }),\n            );\n          }\n        }\n      };\n\n      return () => {\n        reenableRefresher();\n        unsubscribed = true;\n        // Close the connection if it is open when unsubscribing\n        if (this._connection.readyState === WebSocket.OPEN) {\n          this._connection.close();\n        }\n      };\n    });\n\n    return obs;\n  }\n\n  /**\n   * Determines if a secure connection is already allowed based on the current device session state.\n   *\n   * @returns {boolean} `true` if a secure connection is allowed, otherwise `false`.\n   */\n  isSecureConnectionAllowed(): boolean {\n    const deviceSessionState = this._api.getDeviceSessionState();\n    return (\n      \"isSecureConnectionAllowed\" in deviceSessionState &&\n      deviceSessionState.isSecureConnectionAllowed\n    );\n  }\n\n  isInMessageType(data: unknown): data is InMessageType {\n    if (typeof data !== \"object\" || !data) {\n      return false;\n    }\n\n    const message = data as InMessageType;\n    return (\n      typeof message.uuid === \"string\" &&\n      typeof message.session === \"string\" &&\n      typeof message.query === \"string\" &&\n      Object.values(InMessageQueryEnum).includes(message.query) &&\n      typeof message.nonce === \"number\"\n    );\n  }\n\n  mapDeviceError(apduResponse: ApduResponse): SecureChannelError | null {\n    if (CommandUtils.isSuccessResponse(apduResponse)) {\n      return null;\n    }\n\n    // Device is locked\n    if (CommandUtils.isLockedDeviceResponse(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: `Device is locked`,\n        },\n        SecureChannelErrorType.DeviceLocked,\n      );\n    }\n\n    // User refused the permission\n    if (CommandUtils.isRefusedByUser(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"User refused on the device\",\n        },\n        SecureChannelErrorType.RefusedByUser,\n      );\n    }\n\n    // App already installed\n    if (CommandUtils.isAppAlreadyInstalled(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"App already installed\",\n        },\n        SecureChannelErrorType.AppAlreadyInstalled,\n      );\n    }\n\n    // Out of memory\n    if (CommandUtils.isOutOfMemory(apduResponse)) {\n      return new SecureChannelError(\n        {\n          url: this._connection.url,\n          errorMessage: \"Out of memory\",\n        },\n        SecureChannelErrorType.OutOfMemory,\n      );\n    }\n\n    return new SecureChannelError({\n      url: this._connection.url,\n      errorMessage: `Invalid status code: ${bufferToHexaString(\n        apduResponse.statusCode,\n      )}`,\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["WebSocket", "Observable", "CommandUtils", "InMessageQueryEnum", "OutMessageResponseEnum", "SecureChannelEventType", "extractPublicKey", "isGetCertificateApdu", "willRequestPermission", "bufferToHexaString", "hexaStringToBuffer", "NobleCryptoService", "SecureChannelError", "SecureChannelErrorType", "ConnectToSecureChannelTask", "_api", "_args", "reenableRefresher", "subscriber", "unsubscribed", "ignoreNetworkEvents", "communicationFinished", "notifyError", "error", "event", "input", "jsonData", "nonce", "data", "apdu", "permissionRequested", "response", "apduResponse", "outMessageResponse", "deviceError", "publicKey", "deviceId", "message", "i", "len", "payload", "deviceSessionState"]
}
