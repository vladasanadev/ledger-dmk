{
  "version": 3,
  "sources": ["../../../../../../src/api/device-action/task/GetApplicationsMetadataTask.test.ts"],
  "sourcesContent": ["import { EitherAsync } from \"purify-ts\";\n\nimport { InvalidStatusWordError } from \"@api/command/Errors\";\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport {\n  BTC_APP_METADATA,\n  ETH_APP_METADATA,\n} from \"@api/device-action/__test-utils__/data\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { type FirmwareVersion } from \"@api/device-session/DeviceSessionState\";\nimport { type DeviceVersion } from \"@internal/manager-api/model/Device\";\nimport { type FinalFirmware } from \"@internal/manager-api/model/Firmware\";\nimport { type LanguagePackage } from \"@internal/manager-api/model/Language\";\nimport { type ManagerApiService } from \"@internal/manager-api/service/ManagerApiService\";\n\nimport { GetApplicationsMetadataTask } from \"./GetApplicationsMetadataTask\";\n\ndescribe(\"GetApplicationsMetadataTask\", () => {\n  const apiMock = makeDeviceActionInternalApiMock();\n\n  const DEVICE_VERSION = {\n    id: 7,\n  } as DeviceVersion;\n\n  const FIRMWARE = {\n    id: 361,\n    version: \"1.6.0\",\n    perso: \"perso_11\",\n  } as FinalFirmware;\n\n  const FIRMWARE_VERSION = {\n    mcu: \"mcu_version\",\n    bootloader: \"bl_version\",\n    os: \"se_version\",\n    metadata: \"metadata\",\n  } as unknown as FirmwareVersion;\n\n  const INSTALLED_APPS = [\n    { name: \"Ethereum\", hash: \"hash2\", hashCode: \"hashCode\" },\n    {\n      name: \"Language\",\n      hash: \"hash3\",\n      hashCode:\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n    },\n  ];\n\n  const APPS = [ETH_APP_METADATA];\n\n  const CATALOG = [BTC_APP_METADATA, ETH_APP_METADATA];\n\n  const LANGUAGES = [\"fr\", \"eng\", \"it\"] as unknown as LanguagePackage[];\n\n  const ARGS = {\n    deviceVersion: DEVICE_VERSION,\n    firmware: FIRMWARE,\n    firmwareVersion: FIRMWARE_VERSION,\n    installedApps: INSTALLED_APPS,\n  };\n\n  const MANAGER_MOCK = {\n    getAppsByHash: vi.fn(),\n    getAppList: vi.fn(),\n    getLanguagePackages: vi.fn(),\n  };\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n\n    apiMock.sendCommand.mockResolvedValue(\n      CommandResultFactory({ data: undefined }),\n    );\n    apiMock.getManagerApiService.mockReturnValue(\n      MANAGER_MOCK as unknown as ManagerApiService,\n    );\n    MANAGER_MOCK.getAppsByHash.mockReturnValue(EitherAsync(async () => APPS));\n    MANAGER_MOCK.getAppList.mockReturnValue(EitherAsync(async () => CATALOG));\n    MANAGER_MOCK.getLanguagePackages.mockReturnValue(\n      EitherAsync(async () => LANGUAGES),\n    );\n  });\n\n  it(\"Success without updates\", async () => {\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          applications: APPS,\n          applicationsUpdates: [],\n          installedLanguages: [],\n          catalog: {\n            applications: CATALOG,\n            languagePackages: LANGUAGES,\n          },\n        },\n      }),\n    );\n  });\n\n  it(\"Success without languages\", async () => {\n    // WHEN\n    apiMock.sendCommand\n      .mockResolvedValueOnce(\n        CommandResultFactory({ data: { id: 1, size: 15 } }),\n      )\n      .mockResolvedValueOnce(\n        CommandResultFactory({ data: { id: 2, size: 17 } }),\n      );\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          applications: APPS,\n          applicationsUpdates: [],\n          installedLanguages: [\n            { id: 1, size: 15 },\n            { id: 2, size: 17 },\n          ],\n          catalog: {\n            applications: CATALOG,\n            languagePackages: LANGUAGES,\n          },\n        },\n      }),\n    );\n  });\n\n  it(\"Success with an available update\", async () => {\n    // GIVEN\n    const app = {\n      ...BTC_APP_METADATA,\n      version: \"1.0.0\",\n    };\n    MANAGER_MOCK.getAppsByHash.mockReturnValue(EitherAsync(async () => [app]));\n\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          applications: [app],\n          applicationsUpdates: [BTC_APP_METADATA],\n          installedLanguages: [],\n          catalog: {\n            applications: CATALOG,\n            languagePackages: LANGUAGES,\n          },\n        },\n      }),\n    );\n    expect(MANAGER_MOCK.getAppsByHash).toHaveBeenCalledWith([\"hash2\"]);\n  });\n\n  it(\"Success with app hash not found\", async () => {\n    // GIVEN\n    MANAGER_MOCK.getAppsByHash.mockReturnValue(EitherAsync(async () => [null]));\n\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        data: {\n          applications: APPS,\n          applicationsUpdates: [],\n          installedLanguages: [],\n          catalog: {\n            applications: CATALOG,\n            languagePackages: LANGUAGES,\n          },\n        },\n      }),\n    );\n  });\n\n  it(\"should fail when apps hash cannot by retrieved\", async () => {\n    // GIVEN\n    MANAGER_MOCK.getAppsByHash.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        error: new InvalidStatusWordError(\"Cannot get the application catalog\"),\n      }),\n    );\n  });\n\n  it(\"should fail when apps list cannot by retrieved\", async () => {\n    // GIVEN\n    MANAGER_MOCK.getAppList.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        error: new InvalidStatusWordError(\"Cannot get the application catalog\"),\n      }),\n    );\n  });\n\n  it(\"should fail when languages cannot by retrieved\", async () => {\n    // GIVEN\n    MANAGER_MOCK.getLanguagePackages.mockReturnValueOnce(\n      EitherAsync(async ({ throwE }) => {\n        throwE(new Error(\"error\"));\n      }),\n    );\n\n    // WHEN\n    const result = await new GetApplicationsMetadataTask(apiMock, ARGS).run();\n\n    // THEN\n    expect(result).toStrictEqual(\n      CommandResultFactory({\n        error: new InvalidStatusWordError(\"Cannot get the languages catalog\"),\n      }),\n    );\n  });\n});\n"],
  "mappings": "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",
  "names": ["EitherAsync", "InvalidStatusWordError", "CommandResultFactory", "BTC_APP_METADATA", "ETH_APP_METADATA", "makeDeviceActionInternalApiMock", "GetApplicationsMetadataTask", "apiMock", "DEVICE_VERSION", "FIRMWARE", "FIRMWARE_VERSION", "INSTALLED_APPS", "APPS", "CATALOG", "LANGUAGES", "ARGS", "MANAGER_MOCK", "result", "app", "throwE"]
}
