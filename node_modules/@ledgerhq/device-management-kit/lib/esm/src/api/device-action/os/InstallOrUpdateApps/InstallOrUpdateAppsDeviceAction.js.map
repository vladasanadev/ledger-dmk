{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/InstallOrUpdateApps/InstallOrUpdateAppsDeviceAction.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\nimport { type Observable } from \"rxjs\";\nimport { assign, fromObservable, fromPromise, setup } from \"xstate\";\n\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { DEFAULT_UNLOCK_TIMEOUT_MS } from \"@api/device-action/os/Const\";\nimport { OutOfMemoryDAError } from \"@api/device-action/os/Errors\";\nimport { GetDeviceMetadataDeviceAction } from \"@api/device-action/os/GetDeviceMetadata/GetDeviceMetadataDeviceAction\";\nimport { GoToDashboardDeviceAction } from \"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\";\nimport {\n  BuildAppsInstallPlanTask,\n  type BuildAppsInstallPlanTaskResult,\n} from \"@api/device-action/task/BuildAppsInstallPlanTask\";\nimport {\n  PredictOutOfMemoryTask,\n  type PredictOutOfMemoryTaskResult,\n} from \"@api/device-action/task/PredictOutOfMemoryTask\";\nimport { type StateMachineTypes } from \"@api/device-action/xstate-utils/StateMachineTypes\";\nimport {\n  type DeviceActionStateMachine,\n  XStateDeviceAction,\n} from \"@api/device-action/xstate-utils/XStateDeviceAction\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { type GetOsVersionResponse } from \"@api/index\";\nimport { ConnectToSecureChannelTask } from \"@api/secure-channel/task/ConnectToSecureChannelTask\";\nimport { SecureChannelEventType } from \"@api/secure-channel/task/types\";\nimport { type SecureChannelEvent } from \"@api/secure-channel/task/types\";\nimport { type Application } from \"@internal/manager-api/model/Application\";\n\nimport {\n  type ApplicationDependency,\n  type InstallOrUpdateAppsDAError,\n  type InstallOrUpdateAppsDAInput,\n  type InstallOrUpdateAppsDAIntermediateValue,\n  type InstallOrUpdateAppsDAOutput,\n} from \"./types\";\n\ntype InstallOrUpdateAppsMachineInternalState = {\n  readonly error: InstallOrUpdateAppsDAError | null;\n  readonly osVersion: GetOsVersionResponse | null;\n  readonly currentIndex: number;\n};\n\nexport type MachineDependencies = {\n  readonly buildInstallPlan: (arg0: {\n    input: {\n      applications: ApplicationDependency[];\n      allowMissingApplication: boolean;\n    };\n  }) => Promise<BuildAppsInstallPlanTaskResult>;\n  readonly predictOutOfMemory: (arg0: {\n    input: {\n      installPlan: Application[];\n    };\n  }) => Promise<PredictOutOfMemoryTaskResult>;\n  readonly installApp: (arg0: {\n    input: {\n      osVersion: GetOsVersionResponse;\n      application: Application;\n    };\n  }) => Observable<SecureChannelEvent>;\n};\n\nexport type ExtractMachineDependencies = (\n  internalApi: InternalApi,\n) => MachineDependencies;\n\nexport class InstallOrUpdateAppsDeviceAction extends XStateDeviceAction<\n  InstallOrUpdateAppsDAOutput,\n  InstallOrUpdateAppsDAInput,\n  InstallOrUpdateAppsDAError,\n  InstallOrUpdateAppsDAIntermediateValue,\n  InstallOrUpdateAppsMachineInternalState\n> {\n  makeStateMachine(\n    internalApi: InternalApi,\n  ): DeviceActionStateMachine<\n    InstallOrUpdateAppsDAOutput,\n    InstallOrUpdateAppsDAInput,\n    InstallOrUpdateAppsDAError,\n    InstallOrUpdateAppsDAIntermediateValue,\n    InstallOrUpdateAppsMachineInternalState\n  > {\n    type types = StateMachineTypes<\n      InstallOrUpdateAppsDAOutput,\n      InstallOrUpdateAppsDAInput,\n      InstallOrUpdateAppsDAError,\n      InstallOrUpdateAppsDAIntermediateValue,\n      InstallOrUpdateAppsMachineInternalState\n    >;\n\n    const { buildInstallPlan, predictOutOfMemory, installApp } =\n      this.extractDependencies(internalApi);\n\n    const unlockTimeout = this.input.unlockTimeout ?? DEFAULT_UNLOCK_TIMEOUT_MS;\n\n    const updateMetadataMachine = new GetDeviceMetadataDeviceAction({\n      input: {\n        unlockTimeout,\n        useSecureChannel: true,\n        forceUpdate: false,\n      },\n    }).makeStateMachine(internalApi);\n\n    const goToDashboardMachine = new GoToDashboardDeviceAction({\n      input: {\n        unlockTimeout,\n      },\n    }).makeStateMachine(internalApi);\n\n    return setup({\n      types: {\n        input: {\n          unlockTimeout,\n        } as types[\"input\"],\n        context: {} as types[\"context\"],\n        output: {} as types[\"output\"],\n      },\n      actors: {\n        updateMetadata: updateMetadataMachine,\n        buildInstallPlan: fromPromise(buildInstallPlan),\n        predictOutOfMemory: fromPromise(predictOutOfMemory),\n        goToDashboard: goToDashboardMachine,\n        installApp: fromObservable(installApp),\n      },\n      guards: {\n        hasError: ({ context }) => context._internalState.error !== null,\n        hasInstallPlan: (_) => _.context.intermediateValue.installPlan !== null,\n        hasMoreApps: (_) =>\n          _.context._internalState.currentIndex <\n          _.context.intermediateValue.installPlan!.installPlan.length,\n      },\n      actions: {\n        assignErrorFromEvent: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: _.event[\"error\"], // NOTE: it should never happen, the error is not typed anymore here\n          }),\n        }),\n        nextAppIndex: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            currentIndex: _.context._internalState.currentIndex + 1,\n          }),\n        }),\n        cleanupDeviceState: () => {\n          // After app successful installation, cleanup the device session state\n          // to force fetching the new device state when required\n          const state = internalApi.getDeviceSessionState();\n          if (state.sessionStateType !== DeviceSessionStateType.Connected) {\n            internalApi.setDeviceSessionState({\n              ...state,\n              installedApps: [],\n              appsUpdates: undefined,\n            });\n          }\n        },\n      },\n    }).createMachine({\n      id: \"InstallOrUpdateAppsDeviceAction\",\n      initial: \"DeviceReady\",\n      context: (_) => {\n        return {\n          input: {\n            applications: _.input.applications,\n            allowMissingApplication: _.input.allowMissingApplication,\n            unlockTimeout: _.input.unlockTimeout,\n          },\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n            installPlan: null,\n          },\n          _internalState: {\n            error: null,\n            osVersion: null,\n            currentIndex: 0,\n          },\n        };\n      },\n      states: {\n        DeviceReady: {\n          always: [\n            {\n              target: \"UpdateDeviceMetadata\",\n            },\n          ],\n        },\n        UpdateDeviceMetadata: {\n          exit: assign({\n            intermediateValue: (_) => ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.None,\n            }),\n          }),\n          invoke: {\n            id: \"updateMetadata\",\n            src: \"updateMetadata\",\n            input: (_) => ({\n              unlockTimeout: _.context.input.unlockTimeout,\n              useSecureChannel: true,\n              forceUpdate: false,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) => ({\n                  ..._.context.intermediateValue,\n                  requiredUserInteraction:\n                    _.event.snapshot.context.intermediateValue\n                      .requiredUserInteraction,\n                  deviceId:\n                    _.event.snapshot.context.intermediateValue.deviceId ??\n                    _.context.intermediateValue.deviceId,\n                }),\n              }),\n            },\n            onDone: {\n              target: \"UpdateDeviceMetadataCheck\",\n              actions: assign({\n                _internalState: (_) =>\n                  _.event.output.caseOf<InstallOrUpdateAppsMachineInternalState>(\n                    {\n                      Right: (data) => ({\n                        ..._.context._internalState,\n                        osVersion: data.firmwareVersion.metadata!,\n                      }),\n                      Left: (error) => ({\n                        ..._.context._internalState,\n                        error,\n                      }),\n                    },\n                  ),\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        UpdateDeviceMetadataCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"Success\",\n              guard: \"hasInstallPlan\",\n            },\n            {\n              target: \"BuildInstallPlan\",\n            },\n          ],\n        },\n        BuildInstallPlan: {\n          invoke: {\n            src: \"buildInstallPlan\",\n            input: (_) => ({\n              applications: _.context.input.applications,\n              allowMissingApplication: _.context.input.allowMissingApplication,\n            }),\n            onDone: {\n              target: \"BuildInstallPlanCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (\"error\" in _.event.output) {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.output.error,\n                    };\n                  } else {\n                    return _.context._internalState;\n                  }\n                },\n                intermediateValue: (_) => {\n                  if (\"error\" in _.event.output) {\n                    return _.context.intermediateValue;\n                  } else {\n                    return {\n                      ..._.context.intermediateValue,\n                      installPlan: {\n                        installPlan: _.event.output.installPlan,\n                        alreadyInstalled: _.event.output.alreadyInstalled,\n                        missingApplications: _.event.output.missingApplications,\n                        currentIndex: 0,\n                        currentProgress: 0,\n                      },\n                    };\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        BuildInstallPlanCheck: {\n          always: [\n            {\n              guard: \"hasError\",\n              target: \"Error\",\n            },\n            {\n              target: \"PredictOutOfMemory\",\n              guard: \"hasMoreApps\",\n            },\n            {\n              target: \"Success\",\n            },\n          ],\n        },\n        PredictOutOfMemory: {\n          invoke: {\n            src: \"predictOutOfMemory\",\n            input: (_) => ({\n              installPlan: _.context.intermediateValue.installPlan!.installPlan,\n            }),\n            onDone: {\n              target: \"PredictOutOfMemoryCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (\"error\" in _.event.output) {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.output.error,\n                    };\n                  } else if (_.event.output.outOfMemory) {\n                    return {\n                      ..._.context._internalState,\n                      error: new OutOfMemoryDAError(\n                        \"Not enough memory for those applications\",\n                      ),\n                    };\n                  } else {\n                    return _.context._internalState;\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        PredictOutOfMemoryCheck: {\n          always: [\n            {\n              guard: \"hasError\",\n              target: \"Error\",\n            },\n            {\n              target: \"GoToDashboard\",\n            },\n          ],\n        },\n        GoToDashboard: {\n          invoke: {\n            id: \"goToDashboard\",\n            src: \"goToDashboard\",\n            input: (_) => ({\n              unlockTimeout: _.context.input.unlockTimeout,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) => ({\n                  ..._.context.intermediateValue,\n                  requiredUserInteraction:\n                    _.event.snapshot.context.intermediateValue\n                      .requiredUserInteraction,\n                }),\n              }),\n            },\n            onDone: {\n              target: \"GoToDashboardCheck\",\n              actions: assign({\n                _internalState: (_) =>\n                  _.event.output.caseOf<InstallOrUpdateAppsMachineInternalState>(\n                    {\n                      Right: () => _.context._internalState,\n                      Left: (error) => ({\n                        ..._.context._internalState,\n                        error,\n                      }),\n                    },\n                  ),\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        GoToDashboardCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"InstallApp\",\n              actions: \"cleanupDeviceState\",\n            },\n          ],\n        },\n        InstallApp: {\n          exit: assign({\n            intermediateValue: (_) => ({\n              ..._.context.intermediateValue,\n              requiredUserInteraction: UserInteractionRequired.None,\n            }),\n          }),\n          invoke: {\n            id: \"installApp\",\n            src: \"installApp\",\n            input: (_) => ({\n              osVersion: _.context._internalState.osVersion!,\n              application:\n                _.context.intermediateValue.installPlan!.installPlan[\n                  _.context._internalState.currentIndex\n                ]!,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) => {\n                  switch (_.event.snapshot.context?.type) {\n                    case SecureChannelEventType.DeviceId: {\n                      return {\n                        ..._.context.intermediateValue,\n                        deviceId: _.event.snapshot.context.payload.deviceId,\n                      };\n                    }\n                    case SecureChannelEventType.PermissionRequested: {\n                      return {\n                        ..._.context.intermediateValue,\n                        requiredUserInteraction:\n                          UserInteractionRequired.AllowSecureConnection,\n                      };\n                    }\n                    case SecureChannelEventType.PermissionGranted: {\n                      const deviceState = internalApi.getDeviceSessionState();\n                      if (\n                        deviceState.sessionStateType !==\n                        DeviceSessionStateType.Connected\n                      ) {\n                        internalApi.setDeviceSessionState({\n                          ...deviceState,\n                          isSecureConnectionAllowed: true,\n                        });\n                      }\n                      return {\n                        ..._.context.intermediateValue,\n                        requiredUserInteraction: UserInteractionRequired.None,\n                      };\n                    }\n                    case SecureChannelEventType.Progress: {\n                      return {\n                        ..._.context.intermediateValue,\n                        installPlan: {\n                          ..._.context.intermediateValue.installPlan!,\n                          currentIndex: _.context._internalState.currentIndex,\n                          currentProgress:\n                            _.event.snapshot.context.payload.progress,\n                        },\n                      };\n                    }\n                    default:\n                      return _.context.intermediateValue;\n                  }\n                },\n                _internalState: (_) => {\n                  if (\n                    _.event.snapshot.context?.type ===\n                    SecureChannelEventType.Error\n                  ) {\n                    return {\n                      ..._.context._internalState,\n                      error:\n                        _.event.snapshot.context.error.mapInstallDAErrors(),\n                    };\n                  }\n                  return _.context._internalState;\n                },\n              }),\n            },\n            onDone: {\n              target: \"InstallAppCheck\",\n              actions: \"nextAppIndex\",\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        InstallAppCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"InstallApp\",\n              guard: \"hasMoreApps\",\n            },\n            {\n              target: \"UpdateDeviceMetadata\",\n            },\n          ],\n        },\n        Success: {\n          type: \"final\",\n        },\n        Error: {\n          type: \"final\",\n        },\n      },\n      output: (args) => {\n        const { context } = args;\n        const { error } = context._internalState;\n        const { installPlan } = context.intermediateValue;\n        if (error) {\n          return Left(error);\n        }\n        return Right({\n          successfullyInstalled: installPlan!.installPlan,\n          alreadyInstalled: installPlan!.alreadyInstalled,\n          missingApplications: installPlan!.missingApplications,\n        });\n      },\n    });\n  }\n\n  extractDependencies(internalApi: InternalApi): MachineDependencies {\n    const buildInstallPlan = (arg0: {\n      input: {\n        applications: ApplicationDependency[];\n        allowMissingApplication: boolean;\n      };\n    }) =>\n      Promise.resolve(\n        new BuildAppsInstallPlanTask(internalApi, {\n          applications: arg0.input.applications,\n          allowMissingApplication: arg0.input.allowMissingApplication,\n        }).run(),\n      );\n\n    const predictOutOfMemory = (arg0: {\n      input: {\n        installPlan: Application[];\n      };\n    }) =>\n      Promise.resolve(\n        new PredictOutOfMemoryTask(internalApi, {\n          installPlan: arg0.input.installPlan,\n        }).run(),\n      );\n\n    const installApp = (arg0: {\n      input: {\n        osVersion: GetOsVersionResponse;\n        application: Application;\n      };\n    }) => {\n      const { osVersion, application } = arg0.input;\n      const connection = internalApi\n        .getSecureChannelService()\n        .installApp(osVersion, application);\n      return new ConnectToSecureChannelTask(internalApi, {\n        connection,\n      }).run();\n    };\n\n    return {\n      buildInstallPlan,\n      predictOutOfMemory,\n      installApp,\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": ["Left", "Right", "assign", "fromObservable", "fromPromise", "setup", "UserInteractionRequired", "DEFAULT_UNLOCK_TIMEOUT_MS", "OutOfMemoryDAError", "GetDeviceMetadataDeviceAction", "GoToDashboardDeviceAction", "BuildAppsInstallPlanTask", "PredictOutOfMemoryTask", "XStateDeviceAction", "DeviceSessionStateType", "ConnectToSecureChannelTask", "SecureChannelEventType", "InstallOrUpdateAppsDeviceAction", "internalApi", "buildInstallPlan", "predictOutOfMemory", "installApp", "unlockTimeout", "updateMetadataMachine", "goToDashboardMachine", "context", "_", "state", "data", "error", "deviceState", "args", "installPlan", "arg0", "osVersion", "application", "connection"]
}
