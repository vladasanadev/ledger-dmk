import{EitherAsync as s}from"purify-ts";import{InvalidStatusWordError as u}from"../../command/Errors";import{CommandResultFactory as n}from"../../command/model/CommandResult";import{BTC_APP_METADATA as g,ETH_APP_METADATA as d}from"../../device-action/__test-utils__/data";import{makeDeviceActionInternalApiMock as y}from"../../device-action/__test-utils__/makeInternalApi";import{GetApplicationsMetadataTask as r}from"./GetApplicationsMetadataTask";describe("GetApplicationsMetadataTask",()=>{const e=y(),m={id:7},h={id:361,version:"1.6.0",perso:"perso_11"},A={mcu:"mcu_version",bootloader:"bl_version",os:"se_version",metadata:"metadata"},w=[{name:"Ethereum",hash:"hash2",hashCode:"hashCode"},{name:"Language",hash:"hash3",hashCode:"0000000000000000000000000000000000000000000000000000000000000000"}],l=[d],c=[g,d],p=["fr","eng","it"],o={deviceVersion:m,firmware:h,firmwareVersion:A,installedApps:w},t={getAppsByHash:vi.fn(),getAppList:vi.fn(),getLanguagePackages:vi.fn()};beforeEach(()=>{vi.clearAllMocks(),e.sendCommand.mockResolvedValue(n({data:void 0})),e.getManagerApiService.mockReturnValue(t),t.getAppsByHash.mockReturnValue(s(async()=>l)),t.getAppList.mockReturnValue(s(async()=>c)),t.getLanguagePackages.mockReturnValue(s(async()=>p))}),it("Success without updates",async()=>{const a=await new r(e,o).run();expect(a).toStrictEqual(n({data:{applications:l,applicationsUpdates:[],installedLanguages:[],catalog:{applications:c,languagePackages:p}}}))}),it("Success without languages",async()=>{e.sendCommand.mockResolvedValueOnce(n({data:{id:1,size:15}})).mockResolvedValueOnce(n({data:{id:2,size:17}}));const a=await new r(e,o).run();expect(a).toStrictEqual(n({data:{applications:l,applicationsUpdates:[],installedLanguages:[{id:1,size:15},{id:2,size:17}],catalog:{applications:c,languagePackages:p}}}))}),it("Success with an available update",async()=>{const a={...g,version:"1.0.0"};t.getAppsByHash.mockReturnValue(s(async()=>[a]));const i=await new r(e,o).run();expect(i).toStrictEqual(n({data:{applications:[a],applicationsUpdates:[g],installedLanguages:[],catalog:{applications:c,languagePackages:p}}})),expect(t.getAppsByHash).toHaveBeenCalledWith(["hash2"])}),it("Success with app hash not found",async()=>{t.getAppsByHash.mockReturnValue(s(async()=>[null]));const a=await new r(e,o).run();expect(a).toStrictEqual(n({data:{applications:l,applicationsUpdates:[],installedLanguages:[],catalog:{applications:c,languagePackages:p}}}))}),it("should fail when apps hash cannot by retrieved",async()=>{t.getAppsByHash.mockReturnValueOnce(s(async({throwE:i})=>{i(new Error("error"))}));const a=await new r(e,o).run();expect(a).toStrictEqual(n({error:new u("Cannot get the application catalog")}))}),it("should fail when apps list cannot by retrieved",async()=>{t.getAppList.mockReturnValueOnce(s(async({throwE:i})=>{i(new Error("error"))}));const a=await new r(e,o).run();expect(a).toStrictEqual(n({error:new u("Cannot get the application catalog")}))}),it("should fail when languages cannot by retrieved",async()=>{t.getLanguagePackages.mockReturnValueOnce(s(async({throwE:i})=>{i(new Error("error"))}));const a=await new r(e,o).run();expect(a).toStrictEqual(n({error:new u("Cannot get the languages catalog")}))})});
//# sourceMappingURL=GetApplicationsMetadataTask.test.js.map
