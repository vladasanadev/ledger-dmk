{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/OpenAppDeviceAction/OpenAppDeviceAction.test.ts"],
  "sourcesContent": ["import { lastValueFrom } from \"rxjs\";\n\nimport { InvalidStatusWordError } from \"@api/command/Errors\";\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGetDeviceStatusMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport {\n  DeviceLockedError,\n  DeviceNotOnboardedError,\n  UnknownDAError,\n} from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { DeviceDisconnectedWhileSendingError } from \"@api/transport/model/Errors\";\n\nimport { OpenAppDeviceAction } from \"./OpenAppDeviceAction\";\nimport type { OpenAppDAError, OpenAppDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction\");\n\ndescribe(\"OpenAppDeviceAction\", () => {\n  const getAppAndVersionMock = vi.fn();\n  const openAppMock = vi.fn();\n  const closeAppMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n  const isDeviceOnboardedMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      getDeviceSessionState: getDeviceSessionStateMock,\n      setDeviceSessionState: setDeviceSessionStateMock,\n      getAppAndVersion: getAppAndVersionMock,\n      openApp: openAppMock,\n      closeApp: closeAppMock,\n      isDeviceOnboarded: isDeviceOnboardedMock,\n    };\n  }\n\n  const { getDeviceSessionState: apiGetDeviceSessionStateMock } =\n    makeDeviceActionInternalApiMock();\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n    isDeviceOnboardedMock.mockReturnValue(true);\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should end if the required application is opened\", () =>\n      new Promise<void>((resolve, reject) => {\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarding status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should end in a success if the app is already opened\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\", unlockTimeout: undefined },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarding status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if the dashboard is open and open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        const { observable } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n\n        lastValueFrom(observable).then(() => {\n          expect(setDeviceSessionStateMock).toHaveBeenCalledWith({\n            deviceStatus: DeviceStatus.CONNECTED,\n            sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n            currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          });\n        });\n      }));\n\n    it(\"should end in a success if disconnection occurs while open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockRejectedValue(\n          new DeviceDisconnectedWhileSendingError(),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if another app is open, close app succeeds and open app succeeds\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n          { currentApp: \"Bitcoin\", currentAppVersion: \"1.0.0\" },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: undefined,\n          },\n        ];\n\n        const { observable } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n\n        lastValueFrom(observable).then(() => {\n          expect(setDeviceSessionStateMock).toHaveBeenCalledWith({\n            currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n            deviceStatus: DeviceStatus.CONNECTED,\n            sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          });\n        });\n      }));\n  });\n\n  describe(\"errors cases\", () => {\n    it(\"should end in an error if the device is not onboarded\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n        isDeviceOnboardedMock.mockReturnValue(false);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            error: new DeviceNotOnboardedError(),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the device is locked\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new DeviceLockedError()]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new DeviceLockedError(),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new InvalidStatusWordError(\"mocked error\")]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get app and version\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the dashboard is open and open app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in a success if disconnection occurs while open app failed\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"0.0.0\",\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockRejectedValue(\n          new DeviceDisconnectedWhileSendingError(),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending,\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new DeviceDisconnectedWhileSendingError() as OpenAppDAError,\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if another app is open, and close app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if another app is open, close app succeeds but open app returns an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        openAppMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new InvalidStatusWordError(\"mocked error\"),\n          }),\n        );\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new InvalidStatusWordError(\"mocked error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        setupGetDeviceStatusMock([new UnknownDAError(\"Unknown error\")]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if openApp actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"BOLOS\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        openAppMock.mockImplementation(() => {\n          throw new UnknownDAError(\"Unknown error\");\n        });\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get device onboarded\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // open app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.ConfirmOpenApp,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if closeApp actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              sessionStateType:\n                DeviceSessionStateType.ReadyWithoutSecureChannel,\n              deviceStatus: DeviceStatus.CONNECTED,\n              currentApp: { name: \"BOLOS\", version: \"0.0.0\" },\n            },\n          }),\n        );\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"anApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n        closeAppMock.mockImplementation(() => {\n          throw new UnknownDAError(\"Unknown error\");\n        });\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get onboarded status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // close app\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should emit a stopped state if the action is cancelled\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"AnotherApp\", version: \"0.0.0\" },\n        });\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"AnotherApp\",\n            currentAppVersion: \"0.0.0\",\n          },\n        ]);\n\n        const openAppDeviceAction = new OpenAppDeviceAction({\n          input: { appName: \"Bitcoin\" },\n        });\n        vi.spyOn(openAppDeviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<OpenAppDAState> = [\n          {\n            status: DeviceActionStatus.Pending, // get device onboarded\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Pending, // get device status\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          },\n          {\n            status: DeviceActionStatus.Stopped,\n          },\n        ];\n\n        const { cancel } = testDeviceActionStates(\n          openAppDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n        cancel();\n      }));\n  });\n});\n"],
  "mappings": "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",
  "names": ["lastValueFrom", "InvalidStatusWordError", "CommandResultFactory", "DeviceModelId", "DeviceStatus", "makeDeviceActionInternalApiMock", "setupGetDeviceStatusMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "DeviceLockedError", "DeviceNotOnboardedError", "UnknownDAError", "DeviceSessionStateType", "DeviceDisconnectedWhileSendingError", "OpenAppDeviceAction", "getAppAndVersionMock", "openAppMock", "closeAppMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "isDeviceOnboardedMock", "extractDependenciesMock", "apiGetDeviceSessionStateMock", "resolve", "reject", "openAppDeviceAction", "expectedStates", "observable", "cancel"]
}
