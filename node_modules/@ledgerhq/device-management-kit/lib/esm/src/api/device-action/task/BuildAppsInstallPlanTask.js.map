{
  "version": 3,
  "sources": ["../../../../../../src/api/device-action/task/BuildAppsInstallPlanTask.ts"],
  "sourcesContent": ["import { gte } from \"semver\";\n\nimport type { DeviceModelId } from \"@api/device/DeviceModel\";\nimport type { InternalApi } from \"@api/device-action/DeviceAction\";\nimport {\n  UnknownDAError,\n  UnsupportedApplicationDAError,\n  UnsupportedFirmwareDAError,\n} from \"@api/device-action/os/Errors\";\nimport type {\n  ApplicationConstraint,\n  ApplicationDependency,\n} from \"@api/device-action/os/InstallOrUpdateApps/types\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport type { Application } from \"@internal/manager-api/model/Application\";\n\nexport type BuildAppsInstallPlanTaskArgs = {\n  /**\n   * List of applications to install or update\n   */\n  readonly applications: ApplicationDependency[];\n\n  /**\n   * Indicates if the device action should fail if an application is missing from the app store.\n   */\n  readonly allowMissingApplication: boolean;\n};\n\nexport type BuildAppsInstallPlanTaskResult =\n  | {\n      installPlan: Application[];\n      alreadyInstalled: string[];\n      missingApplications: string[];\n    }\n  | {\n      error:\n        | UnknownDAError\n        | UnsupportedApplicationDAError\n        | UnsupportedFirmwareDAError;\n    };\n\nexport class BuildAppsInstallPlanTask {\n  private readonly deviceModelId: DeviceModelId;\n\n  constructor(\n    private readonly api: InternalApi,\n    private readonly args: BuildAppsInstallPlanTaskArgs,\n  ) {\n    const deviceModel = api.getDeviceModel();\n    this.deviceModelId = deviceModel.id;\n  }\n\n  run(): BuildAppsInstallPlanTaskResult {\n    // Get device session state.\n    const deviceState = this.api.getDeviceSessionState();\n    if (deviceState.sessionStateType === DeviceSessionStateType.Connected) {\n      return { error: new UnknownDAError(\"Invalid device state\") };\n    }\n\n    // Ensure the device metadata were correctly fetched.\n    if (deviceState.catalog === undefined) {\n      return { error: new UnknownDAError(\"Device apps metadata not fetched\") };\n    }\n\n    // Build the install plan\n    let installPlan: Application[] = [];\n    let alreadyInstalled: string[] = [];\n    let missingApplications: string[] = [];\n    for (const app of this.args.applications) {\n      // Get app entry from catalog and from installed apps\n      const catalogApp = deviceState.catalog.applications.find(\n        (a) => a.versionName === app.name,\n      );\n      const installedApp = deviceState.installedApps.find(\n        (a) => a.versionName === app.name,\n      );\n\n      // If app is already installed, with validated constraints, continue the iteration\n      if (\n        installedApp !== undefined &&\n        this.validateConstraint(installedApp, catalogApp, app.constraints)\n      ) {\n        alreadyInstalled = [...alreadyInstalled, app.name];\n        continue;\n      }\n\n      // Handle the catalog application\n      if (\n        catalogApp !== undefined &&\n        this.validateConstraint(catalogApp, undefined, app.constraints)\n      ) {\n        // Add the catalog application to the install plan\n        installPlan = [...installPlan, catalogApp];\n      } else if (this.args.allowMissingApplication) {\n        missingApplications = [...missingApplications, app.name];\n      } else {\n        /**\n         * Fail immediately if missing application is not allowed.\n         *\n         * TODO: If the application is not in catalog, we should also check if the application will be available in the\n         * latest firmware catalog before throwing `UnsupportedApplicationDAError`. The actual implementation will always\n         * throw `UnsupportedFirmwareDAError` to force the user to update firmware first, even though the application may\n         * be still not available after the firmware update. For now, we keep `catalogApp !== undefined` check to prevent\n         * from forgetting this case.\n         *\n         * Decision matrix for application availability according to OS and catalog:\n         *\n         * \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         * \u2502 Not valid constraint \u2502 Found in catalog              \u2502 Not found in catalog               \u2502\n         * \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n         * \u2502 OS up-to-date        \u2502 UnsupportedApplicationDAError \u2502 UnsupportedApplicationDAError      \u2502\n         * \u2502 OS out-of-date       \u2502 UnsupportedFirmwareDAError    \u2502 UnsupportedFirmwareDAError => TODO \u2502\n         * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         */\n        if (\n          deviceState.firmwareUpdateContext?.availableUpdate !== undefined &&\n          catalogApp !== undefined\n        ) {\n          return {\n            error: new UnsupportedFirmwareDAError(\n              `Application ${app.name} needs latest firmware`,\n            ),\n          };\n        } else if (\n          deviceState.firmwareUpdateContext?.availableUpdate !== undefined\n        ) {\n          // TODO: Application not found in out-of-date firmware catalog, needs to check if the application will be available\n          // after firmware update\n          return {\n            error: new UnsupportedFirmwareDAError(\n              `Application ${app.name} needs latest firmware`,\n            ),\n          };\n        } else {\n          return {\n            error: new UnsupportedApplicationDAError(\n              `Application ${app.name} not supported for this device`,\n            ),\n          };\n        }\n      }\n    }\n\n    // Find installPlan dependencies\n    const dependencies = installPlan.reduce((apps, app) => {\n      const dependency = app.parentName;\n      if (dependency) {\n        const catalogApp = deviceState.catalog!.applications.find(\n          (a) => a.versionName === dependency,\n        );\n        const installedApp = deviceState.installedApps.find(\n          (a) => a.versionName === dependency,\n        );\n        if (catalogApp && !installedApp) {\n          return [...apps, catalogApp];\n        }\n      }\n      return apps;\n    }, [] as Application[]);\n\n    // Reorder and deduplicate the install plan with its dependencies first\n    installPlan = [...dependencies, ...installPlan];\n    const reorderedInstallPlan = installPlan.filter(\n      (app, index) =>\n        installPlan.findIndex((a) => a.versionName === app.versionName) ===\n        index,\n    );\n\n    return {\n      installPlan: reorderedInstallPlan,\n      missingApplications,\n      alreadyInstalled,\n    };\n  }\n\n  private validateConstraint(\n    app: Application,\n    catalogApp?: Application,\n    constraints?: ApplicationConstraint[],\n  ): boolean {\n    if (constraints === undefined) {\n      // No constraint\n      return true;\n    }\n\n    // Validate the constraint\n    for (const constraint of constraints) {\n      // Is current device exempt from the constraint?\n      if (\n        constraint.exemptModels !== undefined &&\n        constraint.exemptModels.includes(this.deviceModelId)\n      ) {\n        continue;\n      }\n\n      // Is current device not applicable for the constraint?\n      if (\n        constraint.applicableModels !== undefined &&\n        !constraint.applicableModels.includes(this.deviceModelId)\n      ) {\n        continue;\n      }\n\n      // Validate the min version\n      if (constraint.minVersion === \"latest\") {\n        return !catalogApp || gte(app.version, catalogApp.version);\n      } else {\n        return gte(app.version, constraint.minVersion);\n      }\n    }\n\n    // No constraint for the device\n    return true;\n  }\n}\n"],
  "mappings": "AAAA,OAAS,OAAAA,MAAW,SAIpB,OACE,kBAAAC,EACA,iCAAAC,EACA,8BAAAC,MACK,+BAKP,OAAS,0BAAAC,MAA8B,yCA4BhC,MAAMC,CAAyB,CAGpC,YACmBC,EACAC,EACjB,CAFiB,SAAAD,EACA,UAAAC,EAEjB,MAAMC,EAAcF,EAAI,eAAe,EACvC,KAAK,cAAgBE,EAAY,EACnC,CARiB,cAUjB,KAAsC,CAEpC,MAAMC,EAAc,KAAK,IAAI,sBAAsB,EACnD,GAAIA,EAAY,mBAAqBL,EAAuB,UAC1D,MAAO,CAAE,MAAO,IAAIH,EAAe,sBAAsB,CAAE,EAI7D,GAAIQ,EAAY,UAAY,OAC1B,MAAO,CAAE,MAAO,IAAIR,EAAe,kCAAkC,CAAE,EAIzE,IAAIS,EAA6B,CAAC,EAC9BC,EAA6B,CAAC,EAC9BC,EAAgC,CAAC,EACrC,UAAWC,KAAO,KAAK,KAAK,aAAc,CAExC,MAAMC,EAAaL,EAAY,QAAQ,aAAa,KACjDM,GAAMA,EAAE,cAAgBF,EAAI,IAC/B,EACMG,EAAeP,EAAY,cAAc,KAC5CM,GAAMA,EAAE,cAAgBF,EAAI,IAC/B,EAGA,GACEG,IAAiB,QACjB,KAAK,mBAAmBA,EAAcF,EAAYD,EAAI,WAAW,EACjE,CACAF,EAAmB,CAAC,GAAGA,EAAkBE,EAAI,IAAI,EACjD,QACF,CAGA,GACEC,IAAe,QACf,KAAK,mBAAmBA,EAAY,OAAWD,EAAI,WAAW,EAG9DH,EAAc,CAAC,GAAGA,EAAaI,CAAU,UAChC,KAAK,KAAK,wBACnBF,EAAsB,CAAC,GAAGA,EAAqBC,EAAI,IAAI,MAoBvD,QACEJ,EAAY,uBAAuB,kBAAoB,QACvDK,IAAe,OAER,CACL,MAAO,IAAIX,EACT,eAAeU,EAAI,IAAI,wBACzB,CACF,EAEAJ,EAAY,uBAAuB,kBAAoB,OAIhD,CACL,MAAO,IAAIN,EACT,eAAeU,EAAI,IAAI,wBACzB,CACF,EAEO,CACL,MAAO,IAAIX,EACT,eAAeW,EAAI,IAAI,gCACzB,CACF,CAGN,CAoBA,OAAAH,EAAc,CAAC,GAjBMA,EAAY,OAAO,CAACO,EAAMJ,IAAQ,CACrD,MAAMK,EAAaL,EAAI,WACvB,GAAIK,EAAY,CACd,MAAMJ,EAAaL,EAAY,QAAS,aAAa,KAClDM,GAAMA,EAAE,cAAgBG,CAC3B,EACMF,EAAeP,EAAY,cAAc,KAC5CM,GAAMA,EAAE,cAAgBG,CAC3B,EACA,GAAIJ,GAAc,CAACE,EACjB,MAAO,CAAC,GAAGC,EAAMH,CAAU,CAE/B,CACA,OAAOG,CACT,EAAG,CAAC,CAAkB,EAGU,GAAGP,CAAW,EAOvC,CACL,YAP2BA,EAAY,OACvC,CAACG,EAAKM,IACJT,EAAY,UAAWK,GAAMA,EAAE,cAAgBF,EAAI,WAAW,IAC9DM,CACJ,EAIE,oBAAAP,EACA,iBAAAD,CACF,CACF,CAEQ,mBACNE,EACAC,EACAM,EACS,CACT,GAAIA,IAAgB,OAElB,MAAO,GAIT,UAAWC,KAAcD,EAEvB,GACE,EAAAC,EAAW,eAAiB,QAC5BA,EAAW,aAAa,SAAS,KAAK,aAAa,IAOnD,EAAAA,EAAW,mBAAqB,QAChC,CAACA,EAAW,iBAAiB,SAAS,KAAK,aAAa,GAM1D,OAAIA,EAAW,aAAe,SACrB,CAACP,GAAcd,EAAIa,EAAI,QAASC,EAAW,OAAO,EAElDd,EAAIa,EAAI,QAASQ,EAAW,UAAU,EAKjD,MAAO,EACT,CACF",
  "names": ["gte", "UnknownDAError", "UnsupportedApplicationDAError", "UnsupportedFirmwareDAError", "DeviceSessionStateType", "BuildAppsInstallPlanTask", "api", "args", "deviceModel", "deviceState", "installPlan", "alreadyInstalled", "missingApplications", "app", "catalogApp", "a", "installedApp", "apps", "dependency", "index", "constraints", "constraint"]
}
