{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/InstallOrUpdateApps/InstallOrUpdateAppsDeviceAction.test.ts"],
  "sourcesContent": ["import { concat, of, throwError } from \"rxjs\";\n\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGoToDashboardMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { setupGetDeviceMetadataMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport { OutOfMemoryDAError } from \"@api/device-action/os/Errors\";\nimport type { GetDeviceMetadataDAOutput } from \"@api/device-action/os/GetDeviceMetadata/types\";\nimport type { DeviceSessionState } from \"@api/device-session/DeviceSessionState\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport type { SecureChannelEventPayload } from \"@api/secure-channel/task/types\";\nimport { SecureChannelEventType } from \"@api/secure-channel/task/types\";\nimport type { Application } from \"@internal/manager-api/model/Application\";\n\nimport { InstallOrUpdateAppsDeviceAction } from \"./InstallOrUpdateAppsDeviceAction\";\nimport type { InstallOrUpdateAppsDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\");\nvi.mock(\n  \"@api/device-action/os/GetDeviceMetadata/GetDeviceMetadataDeviceAction\",\n);\n\ndescribe(\"InstallOrUpdateAppsDeviceAction\", () => {\n  const apiMock = makeDeviceActionInternalApiMock();\n  const buildInstallPlanMock = vi.fn();\n  const predictOutOfMemoryMock = vi.fn();\n  const installAppMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      buildInstallPlan: buildInstallPlanMock,\n      predictOutOfMemory: predictOutOfMemoryMock,\n      installApp: installAppMock,\n    };\n  }\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    apiMock.getDeviceSessionState.mockReturnValue({\n      sessionStateType: DeviceSessionStateType.Connected,\n      deviceStatus: DeviceStatus.CONNECTED,\n    } as DeviceSessionState);\n  });\n\n  describe(\"success cases\", () => {\n    it(\"Install two applications\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGoToDashboardMock();\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [\n            { versionName: \"Bitcoin\" },\n            { versionName: \"XRP\" },\n          ] as Application[],\n          alreadyInstalled: [\"Ethereum\", \"Solana\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        predictOutOfMemoryMock.mockResolvedValueOnce({\n          outOfMemory: false,\n        });\n        installAppMock\n          .mockReturnValueOnce(\n            of(\n              {\n                type: SecureChannelEventType.PermissionRequested,\n              },\n              {\n                type: SecureChannelEventType.PermissionGranted,\n              },\n              {\n                type: SecureChannelEventType.Progress,\n                payload: { progress: 0.5 },\n              },\n              {\n                type: SecureChannelEventType.Progress,\n                payload: { progress: 1 },\n              },\n            ),\n          )\n          .mockReturnValueOnce(\n            of(\n              {\n                type: SecureChannelEventType.Progress,\n                payload: { progress: 0.25 },\n              },\n              {\n                type: SecureChannelEventType.Progress,\n                payload: { progress: 0.75 },\n              },\n              {\n                type: SecureChannelEventType.Progress,\n                payload: { progress: 1 },\n              },\n            ),\n          );\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // PredictOutOfMemory\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // GoToDashboard\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // InstallApp\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // InstallApp install first app\n          {\n            intermediateValue: {\n              requiredUserInteraction:\n                UserInteractionRequired.AllowSecureConnection,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0.5,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // InstallApp install second app\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 1,\n                currentProgress: 0.25,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 1,\n                currentProgress: 0.75,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 1,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 1,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 1,\n                currentProgress: 1,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            output: {\n              successfullyInstalled: [\n                { versionName: \"Bitcoin\" },\n                { versionName: \"XRP\" },\n              ] as unknown as Application[],\n              alreadyInstalled: [\"Ethereum\", \"Solana\"],\n              missingApplications: [\"MyShitCoin\"],\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"No install is needed\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGoToDashboardMock();\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [],\n          alreadyInstalled: [\"Ethereum\", \"Solana\", \"Bitcoin\", \"XRP\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            output: {\n              successfullyInstalled: [],\n              alreadyInstalled: [\"Ethereum\", \"Solana\", \"Bitcoin\", \"XRP\"],\n              missingApplications: [\"MyShitCoin\"],\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n  });\n\n  describe(\"error cases\", () => {\n    it(\"Update device metadata failure\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceMetadataMock(\n          {\n            firmwareVersion: {\n              metadata: {\n                targetId: 0x33200004,\n              },\n            },\n          } as unknown as GetDeviceMetadataDAOutput,\n          true,\n        );\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [{ name: \"Bitcoin\" }],\n            allowMissingApplication: false,\n          },\n        });\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new UnknownDAError(\"GetDeviceMetadata failed\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"Build install plan failure\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [{ name: \"Bitcoin\" }],\n            allowMissingApplication: false,\n          },\n        });\n\n        buildInstallPlanMock.mockResolvedValueOnce({\n          error: new UnknownDAError(\"BuildInstallPlan failed\"),\n        });\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new UnknownDAError(\"BuildInstallPlan failed\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"Predict out of memory failure\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [\n            { versionName: \"Bitcoin\" },\n            { versionName: \"XRP\" },\n          ] as Application[],\n          alreadyInstalled: [\"Ethereum\", \"Solana\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        predictOutOfMemoryMock.mockResolvedValueOnce({\n          error: new UnknownDAError(\"PredictOutOfMemory failed\"),\n        });\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // PredictOutOfMemory\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new UnknownDAError(\"PredictOutOfMemory failed\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"Is out of memory\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [\n            { versionName: \"Bitcoin\" },\n            { versionName: \"XRP\" },\n          ] as Application[],\n          alreadyInstalled: [\"Ethereum\", \"Solana\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        predictOutOfMemoryMock.mockResolvedValueOnce({\n          outOfMemory: true,\n        });\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // PredictOutOfMemory\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new OutOfMemoryDAError(\n              \"Not enough memory for those applications\",\n            ),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"Go to dashboard failure\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGoToDashboardMock(true);\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [\n            { versionName: \"Bitcoin\" },\n            { versionName: \"XRP\" },\n          ] as Application[],\n          alreadyInstalled: [\"Ethereum\", \"Solana\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        predictOutOfMemoryMock.mockResolvedValueOnce({\n          outOfMemory: false,\n        });\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // PredictOutOfMemory\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // GoToDashboard\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new UnknownDAError(\"GoToDashboard failed\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n\n    it(\"Install app failure\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGoToDashboardMock();\n        setupGetDeviceMetadataMock({\n          firmwareVersion: {\n            metadata: {\n              targetId: 0x33200004,\n            },\n          },\n        } as unknown as GetDeviceMetadataDAOutput);\n        const deviceAction = new InstallOrUpdateAppsDeviceAction({\n          input: {\n            applications: [\n              { name: \"Bitcoin\" },\n              { name: \"Ethereum\" },\n              { name: \"Solana\" },\n              { name: \"XRP\" },\n              { name: \"MyShitCoin\" },\n            ],\n            allowMissingApplication: false,\n          },\n        });\n        const installPlan = {\n          installPlan: [\n            { versionName: \"Bitcoin\" },\n            { versionName: \"XRP\" },\n          ] as Application[],\n          alreadyInstalled: [\"Ethereum\", \"Solana\"],\n          missingApplications: [\"MyShitCoin\"],\n        };\n\n        buildInstallPlanMock.mockResolvedValueOnce(installPlan);\n        predictOutOfMemoryMock.mockResolvedValueOnce({\n          outOfMemory: false,\n        });\n        installAppMock.mockReturnValue(\n          concat(\n            of({\n              type: SecureChannelEventType.Exchange,\n              payload: {\n                data: new Uint8Array([0x00, 0x01, 0x02, 0x03]),\n              } as SecureChannelEventPayload[\"Exchange\"],\n            }),\n            throwError(() => new UnknownDAError(\"Secure channel error\")),\n          ),\n        );\n        vi.spyOn(deviceAction, \"extractDependencies\").mockReturnValue(\n          extractDependenciesMock(),\n        );\n\n        const expectedStates: Array<InstallOrUpdateAppsDAState> = [\n          // UpdateDeviceMetadata\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // BuildInstallPlan\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: null,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // PredictOutOfMemory\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // GoToDashboard\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // InstallApp\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n              installPlan: {\n                ...installPlan,\n                currentIndex: 0,\n                currentProgress: 0,\n              },\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          // Success\n          {\n            error: new UnknownDAError(\"Secure channel error\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(deviceAction, expectedStates, apiMock, {\n          onDone: resolve,\n          onError: reject,\n        });\n      }));\n  });\n});\n"],
  "mappings": "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",
  "names": ["concat", "of", "throwError", "DeviceStatus", "makeDeviceActionInternalApiMock", "setupGoToDashboardMock", "setupGetDeviceMetadataMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "UnknownDAError", "OutOfMemoryDAError", "DeviceSessionStateType", "SecureChannelEventType", "InstallOrUpdateAppsDeviceAction", "apiMock", "buildInstallPlanMock", "predictOutOfMemoryMock", "installAppMock", "extractDependenciesMock", "resolve", "reject", "deviceAction", "installPlan", "expectedStates"]
}
