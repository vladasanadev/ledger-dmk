{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction.test.ts"],
  "sourcesContent": ["import { interval, Observable } from \"rxjs\";\n\nimport { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport {\n  GLOBAL_ERRORS,\n  GlobalCommandError,\n} from \"@api/command/utils/GlobalCommandError\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport {\n  DeviceLockedError,\n  DeviceNotOnboardedError,\n  UnknownDAError,\n} from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\n\nimport { GetDeviceStatusDeviceAction } from \"./GetDeviceStatusDeviceAction\";\nimport { type GetDeviceStatusDAState } from \"./types\";\n\ndescribe(\"GetDeviceStatusDeviceAction\", () => {\n  const getAppAndVersionMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const waitForDeviceUnlockMock = vi.fn();\n  const setDeviceSessionState = vi.fn();\n  const isDeviceOnboardedMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      getAppAndVersion: getAppAndVersionMock,\n      getDeviceSessionState: getDeviceSessionStateMock,\n      waitForDeviceUnlock: waitForDeviceUnlockMock,\n      setDeviceSessionState: setDeviceSessionState,\n      isDeviceOnboarded: isDeviceOnboardedMock,\n    };\n  }\n\n  const {\n    sendCommand: sendCommandMock,\n    getDeviceSessionState: apiGetDeviceSessionStateMock,\n    getDeviceSessionStateObservable: apiGetDeviceSessionStateObservableMock,\n  } = makeDeviceActionInternalApiMock();\n  beforeEach(() => {\n    vi.resetAllMocks();\n    isDeviceOnboardedMock.mockReturnValue(true);\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should run the device action with an unlocked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          deviceModelId: DeviceModelId.NANO_X,\n        });\n\n        sendCommandMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with a locked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 1500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should timeout with a locked device\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 200 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new DeviceLockedError(\"Device locked.\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with an old firmware not supporting GetAppAndVersion\", () =>\n      new Promise<void>((resolve, reject) => {\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          deviceModelId: DeviceModelId.NANO_X,\n        });\n\n        sendCommandMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new GlobalCommandError({\n              ...GLOBAL_ERRORS[\"6e00\"],\n              errorCode: \"6e00\",\n            }),\n          }),\n        );\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"0.0.0\",\n            },\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should return the device status if the device is unlocked\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: undefined },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: () => {\n              // Session should be updated with current app\n              expect(setDeviceSessionState).toHaveBeenCalledWith({\n                sessionStateType:\n                  DeviceSessionStateType.ReadyWithoutSecureChannel,\n                deviceStatus: DeviceStatus.CONNECTED,\n                currentApp: {\n                  name: \"BOLOS\",\n                  version: \"1.0.0\",\n                },\n              });\n              resolve();\n            },\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should return the device status and update session if the device is not ready\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.0.0\",\n            },\n          }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: undefined },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: () => {\n              // Session should be set as ready if GetAppAndVersionCommand was successful\n              expect(setDeviceSessionState).toHaveBeenCalledWith({\n                sessionStateType:\n                  DeviceSessionStateType.ReadyWithoutSecureChannel,\n                deviceStatus: DeviceStatus.CONNECTED,\n                currentApp: {\n                  name: \"BOLOS\",\n                  version: \"1.0.0\",\n                },\n                installedApps: [],\n                isSecureConnectionAllowed: false,\n              });\n              resolve();\n            },\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should return the device status if the device is locked and the user unlocks the device\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              error: new GlobalCommandError({\n                ...GLOBAL_ERRORS[\"5515\"],\n                errorCode: \"5515\",\n              }),\n            }),\n          )\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(50).subscribe({\n                next: (i) => {\n                  if (i > 2) {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.CONNECTED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                    o.complete();\n                  } else {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.LOCKED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                  }\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: {\n              currentApp: \"BOLOS\",\n              currentAppVersion: \"1.0.0\",\n            },\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"errors cases\", () => {\n    it(\"should end in an error if the device is not onboarded\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n        isDeviceOnboardedMock.mockReturnValue(false);\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            error: new DeviceNotOnboardedError(),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the device is locked and the user does not unlock\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockResolvedValue(\n          CommandResultFactory({\n            error: new GlobalCommandError({\n              ...GLOBAL_ERRORS[\"5515\"],\n              errorCode: \"5515\",\n            }),\n          }),\n        );\n\n        apiGetDeviceSessionStateObservableMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(200).subscribe({\n                next: () => {\n                  o.next({\n                    sessionStateType:\n                      DeviceSessionStateType.ReadyWithoutSecureChannel,\n                    deviceStatus: DeviceStatus.LOCKED,\n                    currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n                    installedApps: [],\n                    deviceModelId: DeviceModelId.NANO_X,\n                    isSecureConnectionAllowed: false,\n                  });\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.UnlockDevice,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new DeviceLockedError(\"Device locked.\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if the GetAppAndVersion command fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        const error = new GlobalCommandError({\n          ...GLOBAL_ERRORS[\"5501\"],\n          errorCode: \"5501\",\n        });\n\n        getAppAndVersionMock.mockResolvedValue(CommandResultFactory({ error }));\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              const inner = interval(50).subscribe({\n                next: (i) => {\n                  if (i > 2) {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.CONNECTED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                    o.complete();\n                  } else {\n                    o.next({\n                      sessionStateType:\n                        DeviceSessionStateType.ReadyWithoutSecureChannel,\n                      deviceStatus: DeviceStatus.LOCKED,\n                      currentApp: {\n                        name: \"mockedCurrentApp\",\n                        version: \"1.0.0\",\n                      },\n                    });\n                  }\n                },\n              });\n\n              return () => {\n                inner.unsubscribe();\n              };\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error,\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should end in an error if getAppAndVersion actor throws an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.LOCKED,\n          currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        });\n\n        getAppAndVersionMock.mockImplementation(() => {\n          throw new UnknownDAError(\"error\");\n        });\n\n        waitForDeviceUnlockMock.mockImplementation(\n          () =>\n            new Observable((o) => {\n              o.complete();\n            }),\n        );\n\n        const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          getDeviceStateDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GetDeviceStatusDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            error: new UnknownDAError(\"error\"),\n            status: DeviceActionStatus.Error,\n          },\n        ];\n\n        testDeviceActionStates(\n          getDeviceStateDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  it(\"should emit a stopped state if the action is cancelled\", () =>\n    new Promise<void>((resolve, reject) => {\n      apiGetDeviceSessionStateMock.mockReturnValue({\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: { name: \"mockedCurrentApp\", version: \"1.0.0\" },\n        installedApps: [],\n        deviceModelId: DeviceModelId.NANO_X,\n        isSecureConnectionAllowed: false,\n      });\n\n      sendCommandMock.mockResolvedValue(\n        CommandResultFactory({\n          data: {\n            name: \"BOLOS\",\n            version: \"1.0.0\",\n          },\n        }),\n      );\n\n      const getDeviceStateDeviceAction = new GetDeviceStatusDeviceAction({\n        input: { unlockTimeout: 500 },\n      });\n\n      const expectedStates: Array<GetDeviceStatusDAState> = [\n        {\n          status: DeviceActionStatus.Pending, // get app and version\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n        },\n        {\n          status: DeviceActionStatus.Stopped,\n        },\n      ];\n\n      const { cancel } = testDeviceActionStates(\n        getDeviceStateDeviceAction,\n        expectedStates,\n        makeDeviceActionInternalApiMock(),\n        {\n          onDone: resolve,\n          onError: reject,\n        },\n      );\n      cancel();\n    }));\n});\n"],
  "mappings": "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",
  "names": ["interval", "Observable", "CommandResultFactory", "GLOBAL_ERRORS", "GlobalCommandError", "DeviceModelId", "DeviceStatus", "makeDeviceActionInternalApiMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "DeviceLockedError", "DeviceNotOnboardedError", "UnknownDAError", "DeviceSessionStateType", "GetDeviceStatusDeviceAction", "getAppAndVersionMock", "getDeviceSessionStateMock", "waitForDeviceUnlockMock", "setDeviceSessionState", "isDeviceOnboardedMock", "extractDependenciesMock", "sendCommandMock", "apiGetDeviceSessionStateMock", "apiGetDeviceSessionStateObservableMock", "resolve", "reject", "getDeviceStateDeviceAction", "expectedStates", "o", "inner", "i", "error", "cancel"]
}
