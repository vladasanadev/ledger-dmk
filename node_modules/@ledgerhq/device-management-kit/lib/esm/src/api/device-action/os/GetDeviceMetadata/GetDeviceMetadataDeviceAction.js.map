{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GetDeviceMetadata/GetDeviceMetadataDeviceAction.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\nimport { type Observable } from \"rxjs\";\nimport { assign, fromObservable, fromPromise, setup } from \"xstate\";\n\nimport { isSuccessCommandResult } from \"@api/command/model/CommandResult\";\nimport { type InternalApi } from \"@api/device-action/DeviceAction\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { DEFAULT_UNLOCK_TIMEOUT_MS } from \"@api/device-action/os/Const\";\nimport { GoToDashboardDeviceAction } from \"@api/device-action/os/GoToDashboard/GoToDashboardDeviceAction\";\nimport { ListAppsDeviceAction } from \"@api/device-action/os/ListApps/ListAppsDeviceAction\";\nimport {\n  GetApplicationsMetadataTask,\n  type GetApplicationsMetadataTaskResult,\n  type InstalledApp,\n} from \"@api/device-action/task/GetApplicationsMetadataTask\";\nimport {\n  GetFirmwareMetadataTask,\n  type GetFirmwareMetadataTaskResult,\n} from \"@api/device-action/task/GetFirmwareMetadataTask\";\nimport { type StateMachineTypes } from \"@api/device-action/xstate-utils/StateMachineTypes\";\nimport {\n  type DeviceActionStateMachine,\n  XStateDeviceAction,\n} from \"@api/device-action/xstate-utils/XStateDeviceAction\";\nimport {\n  type Catalog,\n  type CustomImage,\n  DeviceSessionStateType,\n  type FirmwareUpdateContext,\n  type FirmwareVersion,\n  type InstalledLanguagePackage,\n} from \"@api/device-session/DeviceSessionState\";\nimport { installedAppResultGuard } from \"@api/secure-channel/device-action/ListInstalledApps/types\";\nimport { ConnectToSecureChannelTask } from \"@api/secure-channel/task/ConnectToSecureChannelTask\";\nimport { SecureChannelEventType } from \"@api/secure-channel/task/types\";\nimport { type SecureChannelEvent } from \"@api/secure-channel/task/types\";\nimport { type Application } from \"@internal/manager-api/model/Application\";\nimport { type DeviceVersion } from \"@internal/manager-api/model/Device\";\nimport { type FinalFirmware } from \"@internal/manager-api/model/Firmware\";\n\nimport {\n  type GetDeviceMetadataDAError,\n  type GetDeviceMetadataDAInput,\n  type GetDeviceMetadataDAIntermediateValue,\n  type GetDeviceMetadataDAOutput,\n} from \"./types\";\n\ntype GetDeviceMetadataMachineInternalState = {\n  readonly error: GetDeviceMetadataDAError | null;\n  readonly deviceVersion: DeviceVersion | null;\n  readonly firmware: FinalFirmware | null;\n  readonly firmwareVersion: FirmwareVersion | null;\n  readonly firmwareUpdateContext: FirmwareUpdateContext | null;\n  readonly customImage: CustomImage | null;\n  readonly installedApps: InstalledApp[] | null;\n  readonly applications: Application[] | null;\n  readonly applicationsUpdates: Application[] | null;\n  readonly installedLanguages: InstalledLanguagePackage[] | null;\n  readonly catalog: Catalog | null;\n};\n\nexport type GetDeviceMetadataFromContextTaskResult = {\n  readonly firmwareVersion: FirmwareVersion;\n  readonly firmwareUpdateContext: FirmwareUpdateContext;\n  readonly customImage: CustomImage;\n  readonly applications: Application[];\n  readonly applicationsUpdates: Application[];\n  readonly installedLanguages: InstalledLanguagePackage[];\n  readonly catalog: Catalog;\n} | null;\n\nexport type MachineDependencies = {\n  readonly getDeviceMetadata: () => Promise<GetDeviceMetadataFromContextTaskResult>;\n  readonly getFirmwareMetadata: () => Promise<GetFirmwareMetadataTaskResult>;\n  readonly getApplicationsMetadata: (arg0: {\n    input: {\n      deviceVersion: DeviceVersion;\n      firmware: FinalFirmware;\n      firmwareVersion: FirmwareVersion;\n      installedApps: InstalledApp[];\n    };\n  }) => Promise<GetApplicationsMetadataTaskResult>;\n  readonly listAppsSecureChannel: (arg0: {\n    input: {\n      firmware: FinalFirmware;\n      firmwareVersion: FirmwareVersion;\n    };\n  }) => Observable<SecureChannelEvent>;\n};\n\nexport type ExtractMachineDependencies = (\n  internalApi: InternalApi,\n) => MachineDependencies;\n\nexport class GetDeviceMetadataDeviceAction extends XStateDeviceAction<\n  GetDeviceMetadataDAOutput,\n  GetDeviceMetadataDAInput,\n  GetDeviceMetadataDAError,\n  GetDeviceMetadataDAIntermediateValue,\n  GetDeviceMetadataMachineInternalState\n> {\n  makeStateMachine(\n    internalApi: InternalApi,\n  ): DeviceActionStateMachine<\n    GetDeviceMetadataDAOutput,\n    GetDeviceMetadataDAInput,\n    GetDeviceMetadataDAError,\n    GetDeviceMetadataDAIntermediateValue,\n    GetDeviceMetadataMachineInternalState\n  > {\n    type types = StateMachineTypes<\n      GetDeviceMetadataDAOutput,\n      GetDeviceMetadataDAInput,\n      GetDeviceMetadataDAError,\n      GetDeviceMetadataDAIntermediateValue,\n      GetDeviceMetadataMachineInternalState\n    >;\n\n    const {\n      getDeviceMetadata,\n      getFirmwareMetadata,\n      getApplicationsMetadata,\n      listAppsSecureChannel,\n    } = this.extractDependencies(internalApi);\n\n    const unlockTimeout = this.input.unlockTimeout ?? DEFAULT_UNLOCK_TIMEOUT_MS;\n\n    const goToDashboardMachine = new GoToDashboardDeviceAction({\n      input: {\n        unlockTimeout,\n      },\n    }).makeStateMachine(internalApi);\n    const listAppsMachine = new ListAppsDeviceAction({\n      input: {\n        unlockTimeout,\n      },\n    }).makeStateMachine(internalApi);\n\n    return setup({\n      types: {\n        input: {\n          unlockTimeout,\n        } as types[\"input\"],\n        context: {} as types[\"context\"],\n        output: {} as types[\"output\"],\n      },\n      actors: {\n        goToDashboard: goToDashboardMachine,\n        getDeviceMetadata: fromPromise(getDeviceMetadata),\n        getFirmwareMetadata: fromPromise(getFirmwareMetadata),\n        getApplicationsMetadata: fromPromise(getApplicationsMetadata),\n        listApps: listAppsMachine,\n        listAppsSecureChannel: fromObservable(listAppsSecureChannel),\n      },\n      guards: {\n        hasError: ({ context }) => context._internalState.error !== null,\n        hasMetadata: ({ context }) =>\n          context._internalState.firmwareVersion !== null &&\n          context._internalState.firmwareUpdateContext !== null &&\n          context._internalState.customImage !== null &&\n          context._internalState.applications !== null &&\n          context._internalState.applicationsUpdates !== null &&\n          context._internalState.installedLanguages !== null &&\n          context._internalState.catalog !== null,\n        forceUpdate: ({ context }) => Boolean(context.input.forceUpdate),\n        useSecureChannel: ({ context }) =>\n          Boolean(context.input.useSecureChannel),\n      },\n      actions: {\n        assignErrorFromEvent: assign({\n          _internalState: (_) => ({\n            ..._.context._internalState,\n            error: _.event[\"error\"], // NOTE: it should never happen, the error is not typed anymore here\n          }),\n        }),\n      },\n    }).createMachine({\n      id: \"GetDeviceMetadataDeviceAction\",\n      initial: \"DeviceReady\",\n      context: (_) => {\n        return {\n          input: {\n            useSecureChannel: _.input.useSecureChannel,\n            forceUpdate: _.input.forceUpdate,\n            unlockTimeout: _.input.unlockTimeout,\n          },\n          intermediateValue: {\n            requiredUserInteraction: UserInteractionRequired.None,\n          },\n          _internalState: {\n            error: null,\n            deviceVersion: null,\n            firmware: null,\n            firmwareVersion: null,\n            firmwareUpdateContext: null,\n            customImage: null,\n            installedApps: null,\n            applications: null,\n            applicationsUpdates: null,\n            installedLanguages: null,\n            catalog: null,\n          },\n        };\n      },\n      states: {\n        DeviceReady: {\n          always: [\n            {\n              target: \"GoToDashboard\",\n              guard: \"forceUpdate\",\n            },\n            {\n              target: \"GetDeviceMetadataFromContext\",\n            },\n          ],\n        },\n        GetDeviceMetadataFromContext: {\n          invoke: {\n            src: \"getDeviceMetadata\",\n            onDone: {\n              target: \"GetDeviceMetadataFromContextResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (_.event.output === null) {\n                    return _.context._internalState;\n                  } else {\n                    return {\n                      ..._.context._internalState,\n                      firmwareVersion: _.event.output.firmwareVersion,\n                      firmwareUpdateContext:\n                        _.event.output.firmwareUpdateContext,\n                      customImage: _.event.output.customImage,\n                      applications: _.event.output.applications,\n                      applicationsUpdates: _.event.output.applicationsUpdates,\n                      installedLanguages: _.event.output.installedLanguages,\n                      catalog: _.event.output.catalog,\n                    };\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        GetDeviceMetadataFromContextResultCheck: {\n          always: [\n            {\n              target: \"Success\",\n              guard: \"hasMetadata\",\n            },\n            {\n              target: \"GoToDashboard\",\n            },\n          ],\n        },\n        GoToDashboard: {\n          exit: assign({\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          }),\n          invoke: {\n            id: \"dashboard\",\n            src: \"goToDashboard\",\n            input: (_) => ({\n              unlockTimeout: _.context.input.unlockTimeout,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) =>\n                  _.event.snapshot.context.intermediateValue,\n              }),\n            },\n            onDone: {\n              target: \"GoToDashboardCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  return _.event.output.caseOf({\n                    Right: () => _.context._internalState,\n                    Left: (error) => ({\n                      ..._.context._internalState,\n                      error,\n                    }),\n                  });\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        GoToDashboardCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"GetFirmwareMetadata\",\n            },\n          ],\n        },\n        GetFirmwareMetadata: {\n          invoke: {\n            src: \"getFirmwareMetadata\",\n            onDone: {\n              target: \"GetFirmwareMetadataResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (isSuccessCommandResult(_.event.output)) {\n                    const deviceState = internalApi.getDeviceSessionState();\n                    if (\n                      deviceState.sessionStateType !==\n                      DeviceSessionStateType.Connected\n                    ) {\n                      internalApi.setDeviceSessionState({\n                        ...deviceState,\n                        firmwareVersion: _.event.output.data.firmwareVersion,\n                        firmwareUpdateContext:\n                          _.event.output.data.firmwareUpdateContext,\n                        customImage: _.event.output.data.customImage,\n                      });\n                    }\n                    return {\n                      ..._.context._internalState,\n                      deviceVersion: _.event.output.data.deviceVersion,\n                      firmware: _.event.output.data.firmware,\n                      firmwareVersion: _.event.output.data.firmwareVersion,\n                      firmwareUpdateContext:\n                        _.event.output.data.firmwareUpdateContext,\n                      customImage: _.event.output.data.customImage,\n                    };\n                  }\n                  return {\n                    ..._.context._internalState,\n                    error: _.event.output.error,\n                  };\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        GetFirmwareMetadataResultCheck: {\n          always: [\n            {\n              guard: \"hasError\",\n              target: \"Error\",\n            },\n            {\n              guard: \"useSecureChannel\",\n              target: \"ListAppsSecureChannel\",\n            },\n            {\n              target: \"ListApps\",\n            },\n          ],\n        },\n        ListAppsSecureChannel: {\n          exit: assign({\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          }),\n          invoke: {\n            id: \"listAppsSecureChannel\",\n            src: \"listAppsSecureChannel\",\n            input: (_) => ({\n              firmware: _.context._internalState.firmware!,\n              firmwareVersion: _.context._internalState.firmwareVersion!,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) => {\n                  switch (_.event.snapshot.context?.type) {\n                    case SecureChannelEventType.DeviceId: {\n                      return {\n                        ..._.context.intermediateValue,\n                        deviceId: _.event.snapshot.context.payload.deviceId,\n                      };\n                    }\n                    case SecureChannelEventType.PermissionRequested: {\n                      return {\n                        ..._.context.intermediateValue,\n                        requiredUserInteraction:\n                          UserInteractionRequired.AllowSecureConnection,\n                      };\n                    }\n                    case SecureChannelEventType.PermissionGranted: {\n                      const deviceState = internalApi.getDeviceSessionState();\n                      if (\n                        deviceState.sessionStateType !==\n                        DeviceSessionStateType.Connected\n                      ) {\n                        internalApi.setDeviceSessionState({\n                          ...deviceState,\n                          isSecureConnectionAllowed: true,\n                        });\n                      }\n                      return {\n                        ..._.context.intermediateValue,\n                        requiredUserInteraction: UserInteractionRequired.None,\n                      };\n                    }\n                    default:\n                      return {\n                        ..._.context.intermediateValue,\n                      };\n                  }\n                },\n                _internalState: (_) => {\n                  if (\n                    _.event.snapshot.context?.type ===\n                    SecureChannelEventType.Error\n                  ) {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.snapshot.context.error.mapDAErrors(),\n                    };\n                  } else if (\n                    _.event.snapshot.context?.type ===\n                    SecureChannelEventType.Result\n                  ) {\n                    if (\n                      installedAppResultGuard(_.event.snapshot.context.payload)\n                    ) {\n                      return {\n                        ..._.context._internalState,\n                        installedApps: _.event.snapshot.context.payload.map(\n                          (app) => ({\n                            name: app.name,\n                            hash: app.hash,\n                            hashCode: app.hash_code_data,\n                          }),\n                        ),\n                      };\n                    }\n                    throw new Error(\n                      `Invalid result ${JSON.stringify(_.event.snapshot.context.payload)}`,\n                    );\n                  }\n                  return { ..._.context._internalState };\n                },\n              }),\n            },\n            onDone: {\n              target: \"ListAppsCheck\",\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        ListApps: {\n          exit: assign({\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n          }),\n          invoke: {\n            id: \"listApps\",\n            src: \"listApps\",\n            input: (_) => ({\n              unlockTimeout: _.context.input.unlockTimeout,\n            }),\n            onSnapshot: {\n              actions: assign({\n                intermediateValue: (_) =>\n                  _.event.snapshot.context.intermediateValue,\n              }),\n            },\n            onDone: {\n              target: \"ListAppsCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (_.event.output.isLeft()) {\n                    return {\n                      ..._.context._internalState,\n                      error: _.event.output.extract(),\n                    };\n                  } else {\n                    return {\n                      ..._.context._internalState,\n                      installedApps: _.event.output\n                        .unsafeCoerce()\n                        .map((app) => ({\n                          name: app.appName,\n                          hash: app.appFullHash,\n                          hashCode: app.appCodeHash,\n                        })),\n                    };\n                  }\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        ListAppsCheck: {\n          always: [\n            {\n              target: \"Error\",\n              guard: \"hasError\",\n            },\n            {\n              target: \"GetApplicationsMetadata\",\n            },\n          ],\n        },\n        GetApplicationsMetadata: {\n          invoke: {\n            src: \"getApplicationsMetadata\",\n            input: (_) => ({\n              deviceVersion: _.context._internalState.deviceVersion!,\n              firmware: _.context._internalState.firmware!,\n              firmwareVersion: _.context._internalState.firmwareVersion!,\n              installedApps: _.context._internalState.installedApps!,\n            }),\n            onDone: {\n              target: \"GetApplicationsMetadataResultCheck\",\n              actions: assign({\n                _internalState: (_) => {\n                  if (isSuccessCommandResult(_.event.output)) {\n                    const deviceState = internalApi.getDeviceSessionState();\n                    if (\n                      deviceState.sessionStateType !==\n                      DeviceSessionStateType.Connected\n                    ) {\n                      internalApi.setDeviceSessionState({\n                        ...deviceState,\n                        installedApps: _.event.output.data.applications,\n                        appsUpdates: _.event.output.data.applicationsUpdates,\n                        installedLanguages:\n                          _.event.output.data.installedLanguages,\n                        catalog: _.event.output.data.catalog,\n                      });\n                    }\n                    return {\n                      ..._.context._internalState,\n                      applications: _.event.output.data.applications,\n                      applicationsUpdates:\n                        _.event.output.data.applicationsUpdates,\n                      installedLanguages:\n                        _.event.output.data.installedLanguages,\n                      catalog: _.event.output.data.catalog,\n                    };\n                  }\n                  return {\n                    ..._.context._internalState,\n                    error: _.event.output.error,\n                  };\n                },\n              }),\n            },\n            onError: {\n              target: \"Error\",\n              actions: \"assignErrorFromEvent\",\n            },\n          },\n        },\n        GetApplicationsMetadataResultCheck: {\n          always: [\n            {\n              guard: \"hasError\",\n              target: \"Error\",\n            },\n            {\n              target: \"Success\",\n            },\n          ],\n        },\n        Success: {\n          type: \"final\",\n        },\n        Error: {\n          type: \"final\",\n        },\n      },\n      output: (args) => {\n        const { context } = args;\n        const {\n          error,\n          firmwareVersion,\n          firmwareUpdateContext,\n          customImage,\n          applications,\n          applicationsUpdates,\n          installedLanguages,\n          catalog,\n        } = context._internalState;\n        if (error) {\n          return Left(error);\n        }\n        return Right({\n          firmwareVersion: firmwareVersion!,\n          firmwareUpdateContext: firmwareUpdateContext!,\n          customImage: customImage!,\n          applications: applications!,\n          applicationsUpdates: applicationsUpdates!,\n          installedLanguages: installedLanguages!,\n          catalog: catalog!,\n        });\n      },\n    });\n  }\n\n  extractDependencies(internalApi: InternalApi): MachineDependencies {\n    const getDeviceMetadata = () => {\n      const deviceState = internalApi.getDeviceSessionState();\n      if (\n        deviceState.sessionStateType === DeviceSessionStateType.Connected ||\n        deviceState.firmwareVersion?.metadata === undefined ||\n        deviceState.firmwareUpdateContext === undefined ||\n        deviceState.customImage === undefined ||\n        deviceState.installedApps.length === 0 ||\n        deviceState.appsUpdates === undefined ||\n        deviceState.installedLanguages === undefined ||\n        deviceState.catalog === undefined\n      ) {\n        return Promise.resolve(null);\n      }\n      return Promise.resolve({\n        firmwareVersion: deviceState.firmwareVersion,\n        firmwareUpdateContext: deviceState.firmwareUpdateContext,\n        customImage: deviceState.customImage,\n        applications: deviceState.installedApps,\n        applicationsUpdates: deviceState.appsUpdates,\n        installedLanguages: deviceState.installedLanguages,\n        catalog: deviceState.catalog,\n      });\n    };\n\n    const getFirmwareMetadata = async () =>\n      new GetFirmwareMetadataTask(internalApi).run();\n\n    const getApplicationsMetadata = async (arg0: {\n      input: {\n        deviceVersion: DeviceVersion;\n        firmware: FinalFirmware;\n        firmwareVersion: FirmwareVersion;\n        installedApps: InstalledApp[];\n      };\n    }) =>\n      new GetApplicationsMetadataTask(internalApi, {\n        deviceVersion: arg0.input.deviceVersion,\n        firmware: arg0.input.firmware,\n        firmwareVersion: arg0.input.firmwareVersion,\n        installedApps: arg0.input.installedApps,\n      }).run();\n\n    const listAppsSecureChannel = (arg0: {\n      input: {\n        firmware: FinalFirmware;\n        firmwareVersion: FirmwareVersion;\n      };\n    }) => {\n      const { firmware, firmwareVersion } = arg0.input;\n      const connection = internalApi\n        .getSecureChannelService()\n        .listInstalledApps(firmwareVersion.metadata!, firmware);\n      return new ConnectToSecureChannelTask(internalApi, {\n        connection,\n      }).run();\n    };\n\n    return {\n      getDeviceMetadata,\n      getFirmwareMetadata,\n      getApplicationsMetadata,\n      listAppsSecureChannel,\n    };\n  }\n}\n"],
  "mappings": "AAAA,OAAS,QAAAA,EAAM,SAAAC,MAAa,YAE5B,OAAS,UAAAC,EAAQ,kBAAAC,EAAgB,eAAAC,EAAa,SAAAC,MAAa,SAE3D,OAAS,0BAAAC,MAA8B,mCAEvC,OAAS,2BAAAC,MAA+B,mDACxC,OAAS,6BAAAC,MAAiC,8BAC1C,OAAS,6BAAAC,MAAiC,gEAC1C,OAAS,wBAAAC,MAA4B,sDACrC,OACE,+BAAAC,MAGK,sDACP,OACE,2BAAAC,MAEK,kDAEP,OAEE,sBAAAC,MACK,qDACP,OAGE,0BAAAC,MAIK,yCACP,OAAS,2BAAAC,MAA+B,4DACxC,OAAS,8BAAAC,MAAkC,sDAC3C,OAAS,0BAAAC,MAA8B,iCA4DhC,MAAMC,UAAsCL,CAMjD,CACA,iBACEM,EAOA,CASA,KAAM,CACJ,kBAAAC,EACA,oBAAAC,EACA,wBAAAC,EACA,sBAAAC,CACF,EAAI,KAAK,oBAAoBJ,CAAW,EAElCK,EAAgB,KAAK,MAAM,eAAiBhB,EAE5CiB,EAAuB,IAAIhB,EAA0B,CACzD,MAAO,CACL,cAAAe,CACF,CACF,CAAC,EAAE,iBAAiBL,CAAW,EACzBO,EAAkB,IAAIhB,EAAqB,CAC/C,MAAO,CACL,cAAAc,CACF,CACF,CAAC,EAAE,iBAAiBL,CAAW,EAE/B,OAAOd,EAAM,CACX,MAAO,CACL,MAAO,CACL,cAAAmB,CACF,EACA,QAAS,CAAC,EACV,OAAQ,CAAC,CACX,EACA,OAAQ,CACN,cAAeC,EACf,kBAAmBrB,EAAYgB,CAAiB,EAChD,oBAAqBhB,EAAYiB,CAAmB,EACpD,wBAAyBjB,EAAYkB,CAAuB,EAC5D,SAAUI,EACV,sBAAuBvB,EAAeoB,CAAqB,CAC7D,EACA,OAAQ,CACN,SAAU,CAAC,CAAE,QAAAI,CAAQ,IAAMA,EAAQ,eAAe,QAAU,KAC5D,YAAa,CAAC,CAAE,QAAAA,CAAQ,IACtBA,EAAQ,eAAe,kBAAoB,MAC3CA,EAAQ,eAAe,wBAA0B,MACjDA,EAAQ,eAAe,cAAgB,MACvCA,EAAQ,eAAe,eAAiB,MACxCA,EAAQ,eAAe,sBAAwB,MAC/CA,EAAQ,eAAe,qBAAuB,MAC9CA,EAAQ,eAAe,UAAY,KACrC,YAAa,CAAC,CAAE,QAAAA,CAAQ,IAAM,EAAQA,EAAQ,MAAM,YACpD,iBAAkB,CAAC,CAAE,QAAAA,CAAQ,IAC3B,EAAQA,EAAQ,MAAM,gBAC1B,EACA,QAAS,CACP,qBAAsBzB,EAAO,CAC3B,eAAiB0B,IAAO,CACtB,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,KACjB,EACF,CAAC,CACH,CACF,CAAC,EAAE,cAAc,CACf,GAAI,gCACJ,QAAS,cACT,QAAUA,IACD,CACL,MAAO,CACL,iBAAkBA,EAAE,MAAM,iBAC1B,YAAaA,EAAE,MAAM,YACrB,cAAeA,EAAE,MAAM,aACzB,EACA,kBAAmB,CACjB,wBAAyBrB,EAAwB,IACnD,EACA,eAAgB,CACd,MAAO,KACP,cAAe,KACf,SAAU,KACV,gBAAiB,KACjB,sBAAuB,KACvB,YAAa,KACb,cAAe,KACf,aAAc,KACd,oBAAqB,KACrB,mBAAoB,KACpB,QAAS,IACX,CACF,GAEF,OAAQ,CACN,YAAa,CACX,OAAQ,CACN,CACE,OAAQ,gBACR,MAAO,aACT,EACA,CACE,OAAQ,8BACV,CACF,CACF,EACA,6BAA8B,CAC5B,OAAQ,CACN,IAAK,oBACL,OAAQ,CACN,OAAQ,0CACR,QAASL,EAAO,CACd,eAAiB0B,GACXA,EAAE,MAAM,SAAW,KACdA,EAAE,QAAQ,eAEV,CACL,GAAGA,EAAE,QAAQ,eACb,gBAAiBA,EAAE,MAAM,OAAO,gBAChC,sBACEA,EAAE,MAAM,OAAO,sBACjB,YAAaA,EAAE,MAAM,OAAO,YAC5B,aAAcA,EAAE,MAAM,OAAO,aAC7B,oBAAqBA,EAAE,MAAM,OAAO,oBACpC,mBAAoBA,EAAE,MAAM,OAAO,mBACnC,QAASA,EAAE,MAAM,OAAO,OAC1B,CAGN,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,wCAAyC,CACvC,OAAQ,CACN,CACE,OAAQ,UACR,MAAO,aACT,EACA,CACE,OAAQ,eACV,CACF,CACF,EACA,cAAe,CACb,KAAM1B,EAAO,CACX,kBAAmB,CACjB,wBAAyBK,EAAwB,IACnD,CACF,CAAC,EACD,OAAQ,CACN,GAAI,YACJ,IAAK,gBACL,MAAQqB,IAAO,CACb,cAAeA,EAAE,QAAQ,MAAM,aACjC,GACA,WAAY,CACV,QAAS1B,EAAO,CACd,kBAAoB0B,GAClBA,EAAE,MAAM,SAAS,QAAQ,iBAC7B,CAAC,CACH,EACA,OAAQ,CACN,OAAQ,qBACR,QAAS1B,EAAO,CACd,eAAiB0B,GACRA,EAAE,MAAM,OAAO,OAAO,CAC3B,MAAO,IAAMA,EAAE,QAAQ,eACvB,KAAOC,IAAW,CAChB,GAAGD,EAAE,QAAQ,eACb,MAAAC,CACF,EACF,CAAC,CAEL,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,mBAAoB,CAClB,OAAQ,CACN,CACE,OAAQ,QACR,MAAO,UACT,EACA,CACE,OAAQ,qBACV,CACF,CACF,EACA,oBAAqB,CACnB,OAAQ,CACN,IAAK,sBACL,OAAQ,CACN,OAAQ,iCACR,QAAS3B,EAAO,CACd,eAAiB0B,GAAM,CACrB,GAAItB,EAAuBsB,EAAE,MAAM,MAAM,EAAG,CAC1C,MAAME,EAAcX,EAAY,sBAAsB,EACtD,OACEW,EAAY,mBACZhB,EAAuB,WAEvBK,EAAY,sBAAsB,CAChC,GAAGW,EACH,gBAAiBF,EAAE,MAAM,OAAO,KAAK,gBACrC,sBACEA,EAAE,MAAM,OAAO,KAAK,sBACtB,YAAaA,EAAE,MAAM,OAAO,KAAK,WACnC,CAAC,EAEI,CACL,GAAGA,EAAE,QAAQ,eACb,cAAeA,EAAE,MAAM,OAAO,KAAK,cACnC,SAAUA,EAAE,MAAM,OAAO,KAAK,SAC9B,gBAAiBA,EAAE,MAAM,OAAO,KAAK,gBACrC,sBACEA,EAAE,MAAM,OAAO,KAAK,sBACtB,YAAaA,EAAE,MAAM,OAAO,KAAK,WACnC,CACF,CACA,MAAO,CACL,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,OAAO,KACxB,CACF,CACF,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,+BAAgC,CAC9B,OAAQ,CACN,CACE,MAAO,WACP,OAAQ,OACV,EACA,CACE,MAAO,mBACP,OAAQ,uBACV,EACA,CACE,OAAQ,UACV,CACF,CACF,EACA,sBAAuB,CACrB,KAAM1B,EAAO,CACX,kBAAmB,CACjB,wBAAyBK,EAAwB,IACnD,CACF,CAAC,EACD,OAAQ,CACN,GAAI,wBACJ,IAAK,wBACL,MAAQqB,IAAO,CACb,SAAUA,EAAE,QAAQ,eAAe,SACnC,gBAAiBA,EAAE,QAAQ,eAAe,eAC5C,GACA,WAAY,CACV,QAAS1B,EAAO,CACd,kBAAoB0B,GAAM,CACxB,OAAQA,EAAE,MAAM,SAAS,SAAS,KAAM,CACtC,KAAKX,EAAuB,SAC1B,MAAO,CACL,GAAGW,EAAE,QAAQ,kBACb,SAAUA,EAAE,MAAM,SAAS,QAAQ,QAAQ,QAC7C,EAEF,KAAKX,EAAuB,oBAC1B,MAAO,CACL,GAAGW,EAAE,QAAQ,kBACb,wBACErB,EAAwB,qBAC5B,EAEF,KAAKU,EAAuB,kBAAmB,CAC7C,MAAMa,EAAcX,EAAY,sBAAsB,EACtD,OACEW,EAAY,mBACZhB,EAAuB,WAEvBK,EAAY,sBAAsB,CAChC,GAAGW,EACH,0BAA2B,EAC7B,CAAC,EAEI,CACL,GAAGF,EAAE,QAAQ,kBACb,wBAAyBrB,EAAwB,IACnD,CACF,CACA,QACE,MAAO,CACL,GAAGqB,EAAE,QAAQ,iBACf,CACJ,CACF,EACA,eAAiBA,GAAM,CACrB,GACEA,EAAE,MAAM,SAAS,SAAS,OAC1BX,EAAuB,MAEvB,MAAO,CACL,GAAGW,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,SAAS,QAAQ,MAAM,YAAY,CACpD,EACK,GACLA,EAAE,MAAM,SAAS,SAAS,OAC1BX,EAAuB,OACvB,CACA,GACEF,EAAwBa,EAAE,MAAM,SAAS,QAAQ,OAAO,EAExD,MAAO,CACL,GAAGA,EAAE,QAAQ,eACb,cAAeA,EAAE,MAAM,SAAS,QAAQ,QAAQ,IAC7CG,IAAS,CACR,KAAMA,EAAI,KACV,KAAMA,EAAI,KACV,SAAUA,EAAI,cAChB,EACF,CACF,EAEF,MAAM,IAAI,MACR,kBAAkB,KAAK,UAAUH,EAAE,MAAM,SAAS,QAAQ,OAAO,CAAC,EACpE,CACF,CACA,MAAO,CAAE,GAAGA,EAAE,QAAQ,cAAe,CACvC,CACF,CAAC,CACH,EACA,OAAQ,CACN,OAAQ,eACV,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,SAAU,CACR,KAAM1B,EAAO,CACX,kBAAmB,CACjB,wBAAyBK,EAAwB,IACnD,CACF,CAAC,EACD,OAAQ,CACN,GAAI,WACJ,IAAK,WACL,MAAQqB,IAAO,CACb,cAAeA,EAAE,QAAQ,MAAM,aACjC,GACA,WAAY,CACV,QAAS1B,EAAO,CACd,kBAAoB0B,GAClBA,EAAE,MAAM,SAAS,QAAQ,iBAC7B,CAAC,CACH,EACA,OAAQ,CACN,OAAQ,gBACR,QAAS1B,EAAO,CACd,eAAiB0B,GACXA,EAAE,MAAM,OAAO,OAAO,EACjB,CACL,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,OAAO,QAAQ,CAChC,EAEO,CACL,GAAGA,EAAE,QAAQ,eACb,cAAeA,EAAE,MAAM,OACpB,aAAa,EACb,IAAKG,IAAS,CACb,KAAMA,EAAI,QACV,KAAMA,EAAI,YACV,SAAUA,EAAI,WAChB,EAAE,CACN,CAGN,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,cAAe,CACb,OAAQ,CACN,CACE,OAAQ,QACR,MAAO,UACT,EACA,CACE,OAAQ,yBACV,CACF,CACF,EACA,wBAAyB,CACvB,OAAQ,CACN,IAAK,0BACL,MAAQH,IAAO,CACb,cAAeA,EAAE,QAAQ,eAAe,cACxC,SAAUA,EAAE,QAAQ,eAAe,SACnC,gBAAiBA,EAAE,QAAQ,eAAe,gBAC1C,cAAeA,EAAE,QAAQ,eAAe,aAC1C,GACA,OAAQ,CACN,OAAQ,qCACR,QAAS1B,EAAO,CACd,eAAiB0B,GAAM,CACrB,GAAItB,EAAuBsB,EAAE,MAAM,MAAM,EAAG,CAC1C,MAAME,EAAcX,EAAY,sBAAsB,EACtD,OACEW,EAAY,mBACZhB,EAAuB,WAEvBK,EAAY,sBAAsB,CAChC,GAAGW,EACH,cAAeF,EAAE,MAAM,OAAO,KAAK,aACnC,YAAaA,EAAE,MAAM,OAAO,KAAK,oBACjC,mBACEA,EAAE,MAAM,OAAO,KAAK,mBACtB,QAASA,EAAE,MAAM,OAAO,KAAK,OAC/B,CAAC,EAEI,CACL,GAAGA,EAAE,QAAQ,eACb,aAAcA,EAAE,MAAM,OAAO,KAAK,aAClC,oBACEA,EAAE,MAAM,OAAO,KAAK,oBACtB,mBACEA,EAAE,MAAM,OAAO,KAAK,mBACtB,QAASA,EAAE,MAAM,OAAO,KAAK,OAC/B,CACF,CACA,MAAO,CACL,GAAGA,EAAE,QAAQ,eACb,MAAOA,EAAE,MAAM,OAAO,KACxB,CACF,CACF,CAAC,CACH,EACA,QAAS,CACP,OAAQ,QACR,QAAS,sBACX,CACF,CACF,EACA,mCAAoC,CAClC,OAAQ,CACN,CACE,MAAO,WACP,OAAQ,OACV,EACA,CACE,OAAQ,SACV,CACF,CACF,EACA,QAAS,CACP,KAAM,OACR,EACA,MAAO,CACL,KAAM,OACR,CACF,EACA,OAASI,GAAS,CAChB,KAAM,CAAE,QAAAL,CAAQ,EAAIK,EACd,CACJ,MAAAH,EACA,gBAAAI,EACA,sBAAAC,EACA,YAAAC,EACA,aAAAC,EACA,oBAAAC,EACA,mBAAAC,EACA,QAAAC,CACF,EAAIZ,EAAQ,eACZ,OAAIE,EACK7B,EAAK6B,CAAK,EAEZ5B,EAAM,CACX,gBAAiBgC,EACjB,sBAAuBC,EACvB,YAAaC,EACb,aAAcC,EACd,oBAAqBC,EACrB,mBAAoBC,EACpB,QAASC,CACX,CAAC,CACH,CACF,CAAC,CACH,CAEA,oBAAoBpB,EAA+C,CA2DjE,MAAO,CACL,kBA3DwB,IAAM,CAC9B,MAAMW,EAAcX,EAAY,sBAAsB,EACtD,OACEW,EAAY,mBAAqBhB,EAAuB,WACxDgB,EAAY,iBAAiB,WAAa,QAC1CA,EAAY,wBAA0B,QACtCA,EAAY,cAAgB,QAC5BA,EAAY,cAAc,SAAW,GACrCA,EAAY,cAAgB,QAC5BA,EAAY,qBAAuB,QACnCA,EAAY,UAAY,OAEjB,QAAQ,QAAQ,IAAI,EAEtB,QAAQ,QAAQ,CACrB,gBAAiBA,EAAY,gBAC7B,sBAAuBA,EAAY,sBACnC,YAAaA,EAAY,YACzB,aAAcA,EAAY,cAC1B,oBAAqBA,EAAY,YACjC,mBAAoBA,EAAY,mBAChC,QAASA,EAAY,OACvB,CAAC,CACH,EAqCE,oBAnC0B,SAC1B,IAAIlB,EAAwBO,CAAW,EAAE,IAAI,EAmC7C,wBAjC8B,MAAOqB,GAQrC,IAAI7B,EAA4BQ,EAAa,CAC3C,cAAeqB,EAAK,MAAM,cAC1B,SAAUA,EAAK,MAAM,SACrB,gBAAiBA,EAAK,MAAM,gBAC5B,cAAeA,EAAK,MAAM,aAC5B,CAAC,EAAE,IAAI,EAqBP,sBAnB6BA,GAKzB,CACJ,KAAM,CAAE,SAAAC,EAAU,gBAAAR,CAAgB,EAAIO,EAAK,MACrCE,EAAavB,EAChB,wBAAwB,EACxB,kBAAkBc,EAAgB,SAAWQ,CAAQ,EACxD,OAAO,IAAIzB,EAA2BG,EAAa,CACjD,WAAAuB,CACF,CAAC,EAAE,IAAI,CACT,CAOA,CACF,CACF",
  "names": ["Left", "Right", "assign", "fromObservable", "fromPromise", "setup", "isSuccessCommandResult", "UserInteractionRequired", "DEFAULT_UNLOCK_TIMEOUT_MS", "GoToDashboardDeviceAction", "ListAppsDeviceAction", "GetApplicationsMetadataTask", "GetFirmwareMetadataTask", "XStateDeviceAction", "DeviceSessionStateType", "installedAppResultGuard", "ConnectToSecureChannelTask", "SecureChannelEventType", "GetDeviceMetadataDeviceAction", "internalApi", "getDeviceMetadata", "getFirmwareMetadata", "getApplicationsMetadata", "listAppsSecureChannel", "unlockTimeout", "goToDashboardMachine", "listAppsMachine", "context", "_", "error", "deviceState", "app", "args", "firmwareVersion", "firmwareUpdateContext", "customImage", "applications", "applicationsUpdates", "installedLanguages", "catalog", "arg0", "firmware", "connection"]
}
