import{lastValueFrom as C}from"rxjs";import{InvalidStatusWordError as S}from"../../../command/Errors";import{CommandResultFactory as A}from"../../../command/model/CommandResult";import{DeviceModelId as R}from"../../../device/DeviceModel";import{DeviceStatus as a}from"../../../device/DeviceStatus";import{makeDeviceActionInternalApiMock as p}from"../../../device-action/__test-utils__/makeInternalApi";import{setupGetDeviceStatusMock as l}from"../../../device-action/__test-utils__/setupTestMachine";import{testDeviceActionStates as u}from"../../../device-action/__test-utils__/testDeviceActionStates";import{DeviceActionStatus as e}from"../../../device-action/model/DeviceActionState";import{UserInteractionRequired as t}from"../../../device-action/model/UserInteractionRequired";import{DeviceLockedError as E,DeviceNotOnboardedError as P,UnknownDAError as D}from"../../../device-action/os/Errors";import{DeviceSessionStateType as s}from"../../../device-session/DeviceSessionState";import{DeviceDisconnectedWhileSendingError as y}from"../../../transport/model/Errors";import{OpenAppDeviceAction as d}from"./OpenAppDeviceAction";vi.mock("@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction");describe("OpenAppDeviceAction",()=>{const O=vi.fn(),v=vi.fn(),V=vi.fn(),c=vi.fn(),h=vi.fn(),k=vi.fn();function m(){return{getDeviceSessionState:c,setDeviceSessionState:h,getAppAndVersion:O,openApp:v,closeApp:V,isDeviceOnboarded:k}}const{getDeviceSessionState:w}=p();beforeEach(()=>{vi.resetAllMocks(),k.mockReturnValue(!0)}),describe("without overriding `extractDependencies`",()=>{it("should end if the required application is opened",()=>new Promise((r,o)=>{w.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"Bitcoin",version:"1.0.0"},installedApps:[],deviceModelId:R.NANO_X,isSecureConnectionAllowed:!1}),l([{currentApp:"Bitcoin",currentAppVersion:"0.0.0"}]);const n=new d({input:{appName:"Bitcoin"}}),i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Completed,output:void 0}];u(n,i,p(),{onDone:r,onError:o})}))}),describe("success cases",()=>{it("should end in a success if the app is already opened",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"Bitcoin",version:"1.0.0"}}),l([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]);const n=new d({input:{appName:"Bitcoin",unlockTimeout:void 0}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Completed,output:void 0}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in a success if the dashboard is open and open app succeeds",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}),l([{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]),v.mockResolvedValue(A({data:void 0}));const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Completed,output:void 0}],{observable:N}=u(n,i,p(),{onDone:r,onError:o});C(N).then(()=>{expect(h).toHaveBeenCalledWith({deviceStatus:a.CONNECTED,sessionStateType:s.ReadyWithoutSecureChannel,currentApp:{name:"Bitcoin",version:"1.0.0"}})})})),it("should end in a success if disconnection occurs while open app succeeds",()=>new Promise((r,o)=>{c.mockReturnValue(A({data:{sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}})),O.mockResolvedValue(A({data:{name:"BOLOS",version:"0.0.0"}})),l([{currentApp:"BOLOS",currentAppVersion:"0.0.0"},{currentApp:"Bitcoin",currentAppVersion:"0.0.0"}]),v.mockRejectedValue(new y);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Completed,output:void 0}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in a success if another app is open, close app succeeds and open app succeeds",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"AnotherApp",version:"0.0.0"}}),l([{currentApp:"AnotherApp",currentAppVersion:"0.0.0"},{currentApp:"Bitcoin",currentAppVersion:"1.0.0"}]),V.mockResolvedValue(A({data:void 0})),v.mockResolvedValue(A({data:void 0}));const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Completed,output:void 0}],{observable:N}=u(n,i,p(),{onDone:r,onError:o});C(N).then(()=>{expect(h).toHaveBeenCalledWith({currentApp:{name:"Bitcoin",version:"1.0.0"},deviceStatus:a.CONNECTED,sessionStateType:s.ReadyWithoutSecureChannel})})}))}),describe("errors cases",()=>{it("should end in an error if the device is not onboarded",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),k.mockReturnValue(!1);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{error:new P,status:e.Error}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if the device is locked",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),l([new E]);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new E}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if getAppAndVersion returns an error",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),l([new S("mocked error")]);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new S("mocked error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if the dashboard is open and open app returns an error",()=>new Promise((r,o)=>{c.mockReturnValue(A({data:{sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}})),O.mockResolvedValue(A({data:{name:"BOLOS",version:"0.0.0"}})),l([{currentApp:"BOLOS",currentAppVersion:"0.0.0"}]),v.mockResolvedValue(A({error:new S("mocked error")}));const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Error,error:new S("mocked error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in a success if disconnection occurs while open app failed",()=>new Promise((r,o)=>{c.mockReturnValue(A({data:{sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}})),O.mockResolvedValue(A({data:{name:"BOLOS",version:"0.0.0"}})),l([{currentApp:"BOLOS",currentAppVersion:"0.0.0"},{currentApp:"BOLOS",currentAppVersion:"0.0.0"}]),v.mockRejectedValue(new y);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new y}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if another app is open, and close app returns an error",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"AnotherApp",version:"0.0.0"}}),l([{currentApp:"AnotherApp",currentAppVersion:"0.0.0"}]),V.mockResolvedValue(A({error:new S("mocked error")}));const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new S("mocked error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if another app is open, close app succeeds but open app returns an error",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"AnotherApp",version:"0.0.0"}}),l([{currentApp:"AnotherApp",currentAppVersion:"0.0.0"}]),V.mockResolvedValue(A({data:void 0})),v.mockResolvedValue(A({error:new S("mocked error")}));const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Error,error:new S("mocked error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if getAppAndVersion actor throws an error",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),l([new D("Unknown error")]);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new D("Unknown error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if openApp actor throws an error",()=>new Promise((r,o)=>{c.mockReturnValue(A({data:{sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}})),l([{currentApp:"BOLOS",currentAppVersion:"0.0.0"}]),v.mockImplementation(()=>{throw new D("Unknown error")});const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.ConfirmOpenApp}},{status:e.Error,error:new D("Unknown error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should end in an error if closeApp actor throws an error",()=>new Promise((r,o)=>{c.mockReturnValue(A({data:{sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"BOLOS",version:"0.0.0"}}})),l([{currentApp:"anApp",currentAppVersion:"0.0.0"}]),V.mockImplementation(()=>{throw new D("Unknown error")});const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Error,error:new D("Unknown error")}];u(n,i,p(),{onDone:r,onError:o})})),it("should emit a stopped state if the action is cancelled",()=>new Promise((r,o)=>{c.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:a.CONNECTED,currentApp:{name:"AnotherApp",version:"0.0.0"}}),l([{currentApp:"AnotherApp",currentAppVersion:"0.0.0"}]);const n=new d({input:{appName:"Bitcoin"}});vi.spyOn(n,"extractDependencies").mockReturnValue(m());const i=[{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Pending,intermediateValue:{requiredUserInteraction:t.None}},{status:e.Stopped}],{cancel:N}=u(n,i,p(),{onDone:r,onError:o});N()}))})});
//# sourceMappingURL=OpenAppDeviceAction.test.js.map
