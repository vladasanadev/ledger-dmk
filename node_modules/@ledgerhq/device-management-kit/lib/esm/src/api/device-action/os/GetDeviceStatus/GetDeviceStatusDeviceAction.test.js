import{interval as N,Observable as y}from"rxjs";import{CommandResultFactory as a}from"../../../command/model/CommandResult";import{GLOBAL_ERRORS as A,GlobalCommandError as k}from"../../../command/utils/GlobalCommandError";import{DeviceModelId as C}from"../../../device/DeviceModel";import{DeviceStatus as i}from"../../../device/DeviceStatus";import{makeDeviceActionInternalApiMock as u}from"../../../device-action/__test-utils__/makeInternalApi";import{testDeviceActionStates as d}from"../../../device-action/__test-utils__/testDeviceActionStates";import{DeviceActionStatus as t}from"../../../device-action/model/DeviceActionState";import{UserInteractionRequired as c}from"../../../device-action/model/UserInteractionRequired";import{DeviceLockedError as T,DeviceNotOnboardedError as I,UnknownDAError as f}from"../../../device-action/os/Errors";import{DeviceSessionStateType as s}from"../../../device-session/DeviceSessionState";import{GetDeviceStatusDeviceAction as p}from"./GetDeviceStatusDeviceAction";describe("GetDeviceStatusDeviceAction",()=>{const v=vi.fn(),m=vi.fn(),V=vi.fn(),w=vi.fn(),R=vi.fn();function S(){return{getAppAndVersion:v,getDeviceSessionState:m,waitForDeviceUnlock:V,setDeviceSessionState:w,isDeviceOnboarded:R}}const{sendCommand:O,getDeviceSessionState:h,getDeviceSessionStateObservable:g}=u();beforeEach(()=>{vi.resetAllMocks(),R.mockReturnValue(!0)}),describe("without overriding `extractDependencies`",()=>{it("should run the device action with an unlocked device",()=>new Promise((r,o)=>{const e=new p({input:{unlockTimeout:500}});h.mockReturnValue({sessionStateType:s.Connected,deviceStatus:i.CONNECTED,deviceModelId:C.NANO_X}),O.mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"},status:t.Completed}];d(e,n,u(),{onDone:r,onError:o})})),it("should run the device action with a locked device",()=>new Promise((r,o)=>{const e=new p({input:{unlockTimeout:1500}});h.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:C.NANO_X,isSecureConnectionAllowed:!1}),O.mockResolvedValueOnce(a({error:new k({...A[5515],errorCode:"5515"})})).mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.UnlockDevice},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"},status:t.Completed}];d(e,n,u(),{onDone:r,onError:o})})),it("should timeout with a locked device",()=>new Promise((r,o)=>{const e=new p({input:{unlockTimeout:200}});h.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:C.NANO_X,isSecureConnectionAllowed:!1}),O.mockResolvedValueOnce(a({error:new k({...A[5515],errorCode:"5515"})})).mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.UnlockDevice},status:t.Pending},{error:new T("Device locked."),status:t.Error}];d(e,n,u(),{onDone:r,onError:o})})),it("should run the device action with an old firmware not supporting GetAppAndVersion",()=>new Promise((r,o)=>{const e=new p({input:{unlockTimeout:500}});h.mockReturnValue({sessionStateType:s.Connected,deviceStatus:i.CONNECTED,deviceModelId:C.NANO_X}),O.mockResolvedValue(a({error:new k({...A["6e00"],errorCode:"6e00"})}));const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{output:{currentApp:"BOLOS",currentAppVersion:"0.0.0"},status:t.Completed}];d(e,n,u(),{onDone:r,onError:o})}))}),describe("success cases",()=>{it("should return the device status if the device is unlocked",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),v.mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const e=new p({input:{unlockTimeout:void 0}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{status:t.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];d(e,n,u(),{onDone:()=>{expect(w).toHaveBeenCalledWith({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"BOLOS",version:"1.0.0"}}),r()},onError:o})})),it("should return the device status and update session if the device is not ready",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.Connected,deviceStatus:i.CONNECTED}),v.mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const e=new p({input:{unlockTimeout:void 0}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{status:t.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];d(e,n,u(),{onDone:()=>{expect(w).toHaveBeenCalledWith({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"BOLOS",version:"1.0.0"},installedApps:[],isSecureConnectionAllowed:!1}),r()},onError:o})})),it("should return the device status if the device is locked and the user unlocks the device",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),v.mockResolvedValueOnce(a({error:new k({...A[5515],errorCode:"5515"})})).mockResolvedValueOnce(a({data:{name:"BOLOS",version:"1.0.0"}})),V.mockImplementation(()=>new y(l=>{const D=N(50).subscribe({next:E=>{E>2?(l.next({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),l.complete()):l.next({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}})}});return()=>{D.unsubscribe()}}));const e=new p({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.UnlockDevice},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{status:t.Completed,output:{currentApp:"BOLOS",currentAppVersion:"1.0.0"}}];d(e,n,u(),{onDone:r,onError:o})}))}),describe("errors cases",()=>{it("should end in an error if the device is not onboarded",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),R.mockReturnValue(!1);const e=new p({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{error:new I,status:t.Error}];d(e,n,u(),{onDone:r,onError:o})})),it("should end in an error if the device is locked and the user does not unlock",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),v.mockResolvedValue(a({error:new k({...A[5515],errorCode:"5515"})})),g.mockImplementation(()=>new y(l=>{const D=N(200).subscribe({next:()=>{l.next({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:C.NANO_X,isSecureConnectionAllowed:!1})}});return()=>{D.unsubscribe()}}));const e=new p({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{intermediateValue:{requiredUserInteraction:c.UnlockDevice},status:t.Pending},{error:new T("Device locked."),status:t.Error}];d(e,n,u(),{onDone:r,onError:o})})),it("should end in an error if the GetAppAndVersion command fails",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}});const e=new k({...A[5501],errorCode:"5501"});v.mockResolvedValue(a({error:e})),V.mockImplementation(()=>new y(D=>{const E=N(50).subscribe({next:x=>{x>2?(D.next({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),D.complete()):D.next({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}})}});return()=>{E.unsubscribe()}}));const n=new p({input:{unlockTimeout:500}});vi.spyOn(n,"extractDependencies").mockReturnValue(S());const l=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{error:e,status:t.Error}];d(n,l,u(),{onDone:r,onError:o})})),it("should end in an error if getAppAndVersion actor throws an error",()=>new Promise((r,o)=>{m.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.LOCKED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"}}),v.mockImplementation(()=>{throw new f("error")}),V.mockImplementation(()=>new y(l=>{l.complete()}));const e=new p({input:{unlockTimeout:500}});vi.spyOn(e,"extractDependencies").mockReturnValue(S());const n=[{intermediateValue:{requiredUserInteraction:c.None},status:t.Pending},{error:new f("error"),status:t.Error}];d(e,n,u(),{onDone:r,onError:o})}))}),it("should emit a stopped state if the action is cancelled",()=>new Promise((r,o)=>{h.mockReturnValue({sessionStateType:s.ReadyWithoutSecureChannel,deviceStatus:i.CONNECTED,currentApp:{name:"mockedCurrentApp",version:"1.0.0"},installedApps:[],deviceModelId:C.NANO_X,isSecureConnectionAllowed:!1}),O.mockResolvedValue(a({data:{name:"BOLOS",version:"1.0.0"}}));const e=new p({input:{unlockTimeout:500}}),n=[{status:t.Pending,intermediateValue:{requiredUserInteraction:c.None}},{status:t.Stopped}],{cancel:l}=d(e,n,u(),{onDone:r,onError:o});l()}))});
//# sourceMappingURL=GetDeviceStatusDeviceAction.test.js.map
