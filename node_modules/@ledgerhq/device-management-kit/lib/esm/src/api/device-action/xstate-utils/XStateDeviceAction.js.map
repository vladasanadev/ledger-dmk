{
  "version": 3,
  "sources": ["../../../../../../src/api/device-action/xstate-utils/XStateDeviceAction.ts"],
  "sourcesContent": ["// import { createBrowserInspector } from \"@statelyai/inspect\";\nimport { Observable, ReplaySubject, share } from \"rxjs\";\nimport {\n  createActor,\n  type SnapshotFrom,\n  type StateMachine,\n  type StateSchema,\n} from \"xstate\";\n\nimport {\n  type DeviceAction,\n  type DeviceActionIntermediateValue,\n  type ExecuteDeviceActionReturnType,\n  type InternalApi,\n} from \"@api/device-action/DeviceAction\";\nimport {\n  type DeviceActionState,\n  DeviceActionStatus,\n} from \"@api/device-action/model/DeviceActionState\";\nimport { type DmkError } from \"@api/Error\";\n\nimport { type StateMachineTypes } from \"./StateMachineTypes\";\n\nexport type DeviceActionStateMachine<\n  Output,\n  Input,\n  Error extends DmkError,\n  IntermediateValue extends DeviceActionIntermediateValue,\n  InternalState,\n> = StateMachine<\n  StateMachineTypes<\n    Output,\n    Input,\n    Error,\n    IntermediateValue,\n    InternalState\n  >[\"context\"], // context\n  /**\n   * The following usages `any` are OK because this is just a wrapper around the\n   * state machine and we are not directly going to use these types.\n   */\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  any, // event\n  any, // children\n  any, // actor\n  any, // action\n  any, // guard\n  any, // delay\n  any, // state value\n  any, // tag\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  StateMachineTypes<\n    Output,\n    Input,\n    Error,\n    IntermediateValue,\n    InternalState\n  >[\"input\"],\n  StateMachineTypes<\n    Output,\n    Input,\n    Error,\n    IntermediateValue,\n    InternalState\n  >[\"output\"],\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  any,\n  any,\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  StateSchema\n>;\n\n/**\n * A DeviceAction that uses an XState state machine to execute.\n * It maps the state machine snapshots to the DeviceActionState.\n * This class is abstract and should be extended to implement the state machine.\n */\nexport abstract class XStateDeviceAction<\n  Output,\n  Input,\n  Error extends DmkError,\n  IntermediateValue extends DeviceActionIntermediateValue,\n  InternalState,\n> implements DeviceAction<Output, Input, Error, IntermediateValue>\n{\n  readonly input: Input;\n  readonly inspect: boolean = false;\n\n  /**\n   *\n   * @param input The input for the DeviceAction\n   * @param inspect If true, the state machine will be inspected in the browser\n   */\n  constructor(args: { input: Input; inspect?: boolean }) {\n    this.input = args.input;\n    this.inspect = Boolean(args.inspect);\n  }\n\n  protected abstract makeStateMachine(\n    internalAPI: InternalApi,\n  ): DeviceActionStateMachine<\n    Output,\n    Input,\n    Error,\n    IntermediateValue,\n    InternalState\n  >;\n\n  _execute(\n    internalApi: InternalApi,\n  ): ExecuteDeviceActionReturnType<Output, Error, IntermediateValue> {\n    const stateMachine = this.makeStateMachine(internalApi);\n    return this._subscribeToStateMachine(stateMachine);\n  }\n\n  protected _subscribeToStateMachine(\n    stateMachine: DeviceActionStateMachine<\n      Output,\n      Input,\n      Error,\n      IntermediateValue,\n      InternalState\n    >,\n  ): ExecuteDeviceActionReturnType<Output, Error, IntermediateValue> {\n    const actor = createActor(stateMachine, {\n      input: this.input,\n      // optional inspector for debugging\n      // inspect: this.inspect ? createBrowserInspector().inspect : undefined,\n    });\n\n    /**\n     * Using a ReplaySubject is important because the first snapshots might be\n     * emitted before the observable is subscribed (if the machine goes through\n     * those states fully synchronously).\n     * This way, we ensure that the subscriber always receives the latest snapshot.\n     * */\n    const subject = new ReplaySubject<\n      DeviceActionState<Output, Error, IntermediateValue>\n    >();\n\n    const handleActorSnapshot = (\n      snapshot: SnapshotFrom<typeof stateMachine>,\n    ) => {\n      const { context, status, output, error } = snapshot;\n      switch (status) {\n        case \"active\":\n          subject.next({\n            status: DeviceActionStatus.Pending,\n            intermediateValue: context.intermediateValue,\n          });\n          break;\n        case \"done\":\n          output.caseOf({\n            Left: (err) => {\n              subject.next({\n                status: DeviceActionStatus.Error,\n                error: err,\n              });\n            },\n            Right: (result) => {\n              subject.next({\n                status: DeviceActionStatus.Completed,\n                output: result,\n              });\n            },\n          });\n          subject.complete();\n          break;\n        case \"error\":\n          // this is an error in the execution of the state machine, it should not happen\n          subject.error(error);\n          subject.complete();\n          break;\n        case \"stopped\":\n          subject.next({\n            status: DeviceActionStatus.Stopped,\n          });\n          subject.complete();\n          break;\n        default:\n          this._exhaustiveMatchingGuard(status);\n      }\n    };\n\n    const observable = new Observable<\n      DeviceActionState<Output, Error, IntermediateValue>\n    >((subscriber) => {\n      const subjectSubscription = subject.subscribe(subscriber);\n      return () => {\n        actorSubscription.unsubscribe();\n        subjectSubscription.unsubscribe();\n        actor.stop(); // stop the actor when the observable is unsubscribed\n      };\n    });\n\n    const actorSubscription = actor.subscribe(handleActorSnapshot);\n    actor.start();\n\n    return {\n      observable: observable.pipe(share()), // share to garantee that once there is no more observer, the actor is stopped\n      cancel: () => {\n        actor.stop();\n        actorSubscription.unsubscribe();\n        handleActorSnapshot(actor.getSnapshot());\n      },\n    };\n  }\n\n  private _exhaustiveMatchingGuard(status: never): never {\n    console.log(\"_exhaustiveMatchingGuard status\", status);\n    throw new Error(`Unhandled status: ${status}`);\n  }\n}\n"],
  "mappings": "AACA,OAAS,cAAAA,EAAY,iBAAAC,EAAe,SAAAC,MAAa,OACjD,OACE,eAAAC,MAIK,SAQP,OAEE,sBAAAC,MACK,6CA2DA,MAAeC,CAOtB,CACW,MACA,QAAmB,GAO5B,YAAYC,EAA2C,CACrD,KAAK,MAAQA,EAAK,MAClB,KAAK,QAAU,EAAQA,EAAK,OAC9B,CAYA,SACEC,EACiE,CACjE,MAAMC,EAAe,KAAK,iBAAiBD,CAAW,EACtD,OAAO,KAAK,yBAAyBC,CAAY,CACnD,CAEU,yBACRA,EAOiE,CACjE,MAAMC,EAAQN,EAAYK,EAAc,CACtC,MAAO,KAAK,KAGd,CAAC,EAQKE,EAAU,IAAIT,EAIdU,EACJC,GACG,CACH,KAAM,CAAE,QAAAC,EAAS,OAAAC,EAAQ,OAAAC,EAAQ,MAAAC,CAAM,EAAIJ,EAC3C,OAAQE,EAAQ,CACd,IAAK,SACHJ,EAAQ,KAAK,CACX,OAAQN,EAAmB,QAC3B,kBAAmBS,EAAQ,iBAC7B,CAAC,EACD,MACF,IAAK,OACHE,EAAO,OAAO,CACZ,KAAOE,GAAQ,CACbP,EAAQ,KAAK,CACX,OAAQN,EAAmB,MAC3B,MAAOa,CACT,CAAC,CACH,EACA,MAAQC,GAAW,CACjBR,EAAQ,KAAK,CACX,OAAQN,EAAmB,UAC3B,OAAQc,CACV,CAAC,CACH,CACF,CAAC,EACDR,EAAQ,SAAS,EACjB,MACF,IAAK,QAEHA,EAAQ,MAAMM,CAAK,EACnBN,EAAQ,SAAS,EACjB,MACF,IAAK,UACHA,EAAQ,KAAK,CACX,OAAQN,EAAmB,OAC7B,CAAC,EACDM,EAAQ,SAAS,EACjB,MACF,QACE,KAAK,yBAAyBI,CAAM,CACxC,CACF,EAEMK,EAAa,IAAInB,EAEpBoB,GAAe,CAChB,MAAMC,EAAsBX,EAAQ,UAAUU,CAAU,EACxD,MAAO,IAAM,CACXE,EAAkB,YAAY,EAC9BD,EAAoB,YAAY,EAChCZ,EAAM,KAAK,CACb,CACF,CAAC,EAEKa,EAAoBb,EAAM,UAAUE,CAAmB,EAC7D,OAAAF,EAAM,MAAM,EAEL,CACL,WAAYU,EAAW,KAAKjB,EAAM,CAAC,EACnC,OAAQ,IAAM,CACZO,EAAM,KAAK,EACXa,EAAkB,YAAY,EAC9BX,EAAoBF,EAAM,YAAY,CAAC,CACzC,CACF,CACF,CAEQ,yBAAyBK,EAAsB,CACrD,cAAQ,IAAI,kCAAmCA,CAAM,EAC/C,IAAI,MAAM,qBAAqBA,CAAM,EAAE,CAC/C,CACF",
  "names": ["Observable", "ReplaySubject", "share", "createActor", "DeviceActionStatus", "XStateDeviceAction", "args", "internalApi", "stateMachine", "actor", "subject", "handleActorSnapshot", "snapshot", "context", "status", "output", "error", "err", "result", "observable", "subscriber", "subjectSubscription", "actorSubscription"]
}
