{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/ListAppsWithMetadata/ListAppsWithMetadataDeviceAction.test.ts"],
  "sourcesContent": ["import { Left, Right } from \"purify-ts\";\n\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport {\n  BTC_APP,\n  BTC_APP_METADATA,\n  CUSTOM_LOCK_SCREEN_APP,\n  CUSTOM_LOCK_SCREEN_APP_METADATA,\n  ETH_APP,\n  ETH_APP_METADATA,\n} from \"@api/device-action/__test-utils__/data\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupListAppsMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { HttpFetchApiError } from \"@internal/manager-api/model/Errors\";\nimport { type ManagerApiService } from \"@internal/manager-api/service/ManagerApiService\";\n\nimport { ListAppsWithMetadataDeviceAction } from \"./ListAppsWithMetadataDeviceAction\";\nimport { type ListAppsWithMetadataDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/ListApps/ListAppsDeviceAction\");\n\ndescribe(\"ListAppsWithMetadataDeviceAction\", () => {\n  const { getManagerApiService: getManagerApiServiceMock } =\n    makeDeviceActionInternalApiMock();\n\n  const setDeviceSessionStateMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const getAppsByHashMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      getAppsByHash: getAppsByHashMock,\n      getDeviceSessionState: getDeviceSessionStateMock,\n      setDeviceSessionState: setDeviceSessionStateMock,\n    };\n  }\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  describe(\"success case\", () => {\n    it(\"should run the device actions with no apps installed\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi.fn().mockResolvedValue(Right([])),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: [],\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device actions with 1 app installed\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi.fn().mockResolvedValue(Right([BTC_APP_METADATA])),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // SaveSession\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: [BTC_APP_METADATA],\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device actions with 2 apps installed\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP, ETH_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi\n            .fn()\n            .mockResolvedValue(Right([BTC_APP_METADATA, ETH_APP_METADATA])),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // SaveSession\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: [BTC_APP_METADATA, ETH_APP_METADATA],\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device actions with 1 app installed and a custom lock screen\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP, CUSTOM_LOCK_SCREEN_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi\n            .fn()\n            .mockResolvedValue(\n              Right([BTC_APP_METADATA, CUSTOM_LOCK_SCREEN_APP_METADATA]),\n            ),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // SaveSession\n          },\n          {\n            status: DeviceActionStatus.Completed,\n            output: [BTC_APP_METADATA, CUSTOM_LOCK_SCREEN_APP_METADATA],\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"error case\", () => {\n    it(\"should error when ListApps fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([], true);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"ListApps failed\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should error when getAppsByHash rejects\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi\n            .fn()\n            .mockRejectedValue(new UnknownDAError(\"getAppsByHash failed\")),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"getAppsByHash failed\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should error when getAppsByHash fails but error is known\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        const error = new HttpFetchApiError(new Error(\"Failed to fetch data\"));\n\n        getManagerApiServiceMock.mockReturnValue({\n          getAppsByHash: vi.fn().mockResolvedValue(Left(error)),\n        } as unknown as ManagerApiService);\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error,\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should error when SaveSession fails\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupListAppsMock([BTC_APP]);\n        const listAppsWithMetadataDeviceAction =\n          new ListAppsWithMetadataDeviceAction({\n            input: {},\n          });\n\n        getAppsByHashMock.mockImplementation(async () =>\n          Promise.resolve(Right([BTC_APP_METADATA])),\n        );\n\n        vi.spyOn(\n          listAppsWithMetadataDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: \"BOLOS\",\n          installedApps: [],\n        });\n\n        setDeviceSessionStateMock.mockImplementation(() => {\n          throw new UnknownDAError(\"SaveSession failed\");\n        });\n\n        const expectedStates: Array<ListAppsWithMetadataDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // Ready\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.AllowListApps,\n            },\n            status: DeviceActionStatus.Pending, // ListAppsDeviceAction\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // FetchMetadata\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // SaveSession\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"SaveSession failed\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          listAppsWithMetadataDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n});\n"],
  "mappings": "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",
  "names": ["Left", "Right", "DeviceStatus", "BTC_APP", "BTC_APP_METADATA", "CUSTOM_LOCK_SCREEN_APP", "CUSTOM_LOCK_SCREEN_APP_METADATA", "ETH_APP", "ETH_APP_METADATA", "makeDeviceActionInternalApiMock", "setupListAppsMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "UnknownDAError", "DeviceSessionStateType", "HttpFetchApiError", "ListAppsWithMetadataDeviceAction", "getManagerApiServiceMock", "setDeviceSessionStateMock", "getDeviceSessionStateMock", "getAppsByHashMock", "extractDependenciesMock", "resolve", "reject", "listAppsWithMetadataDeviceAction", "expectedStates", "error"]
}
