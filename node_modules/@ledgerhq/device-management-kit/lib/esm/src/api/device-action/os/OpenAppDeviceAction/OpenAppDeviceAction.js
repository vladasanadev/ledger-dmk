import{Left as D,Right as g}from"purify-ts";import{assign as t,fromPromise as c,setup as y}from"xstate";import{isSuccessCommandResult as u}from"../../../command/model/CommandResult";import{CloseAppCommand as O}from"../../../command/os/CloseAppCommand";import{OpenAppCommand as v}from"../../../command/os/OpenAppCommand";import{UserInteractionRequired as i}from"../../../device-action/model/UserInteractionRequired";import{DEFAULT_UNLOCK_TIMEOUT_MS as h}from"../../../device-action/os/Const";import{DeviceNotOnboardedError as E}from"../../../device-action/os/Errors";import{GetDeviceStatusDeviceAction as f}from"../../../device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction";import{XStateDeviceAction as R}from"../../../device-action/xstate-utils/XStateDeviceAction";import{DeviceSessionStateType as l}from"../../../device-session/DeviceSessionState";import{DeviceDisconnectedWhileSendingError as C}from"../../../transport/model/Errors";import{isDashboardName as x}from"../../../utils/AppName";class W extends R{makeStateMachine(r){const{closeApp:o,openApp:s,getDeviceSessionState:a,isDeviceOnboarded:A,setDeviceSessionState:d}=this.extractDependencies(r),S=this.input.unlockTimeout??h,m=new f({input:{unlockTimeout:S}}).makeStateMachine(r);return y({types:{input:{},context:{},output:{}},actors:{closeApp:c(o),openApp:c(s),getDeviceStatus:m},guards:{isDeviceOnboarded:()=>A(),isRequestedAppOpen:({context:e})=>e._internalState.currentlyRunningApp===null?!1:e._internalState.currentlyRunningApp===e.input.appName,isDashboardOpen:({context:e})=>{if(e._internalState.currentlyRunningApp===null)throw new Error("context.currentlyRunningApp === null");return x(e._internalState.currentlyRunningApp)},hasDisconnectedWhileSending:({context:e})=>e._internalState.error!==null&&e._internalState.error instanceof C,hasError:({context:e})=>e._internalState.error!==null},actions:{assignErrorDeviceNotOnboarded:t({_internalState:e=>({...e.context._internalState,error:new E})}),assignUserActionNeededOpenApp:t({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:i.ConfirmOpenApp})}),assignNoUserActionNeeded:t({intermediateValue:e=>({...e.context.intermediateValue,requiredUserInteraction:i.None})}),assignErrorFromEvent:t({_internalState:e=>({...e.context._internalState,error:e.event.error})}),assignNoError:t({_internalState:e=>({...e.context._internalState,error:null})})}}).createMachine({id:"OpenAppDeviceAction",initial:"DeviceReady",context:({input:e})=>{const n=a(),{sessionStateType:p}=n;return{input:e,intermediateValue:{requiredUserInteraction:i.None},_internalState:{error:null,currentlyRunningApp:p===l.ReadyWithoutSecureChannel?n.currentApp.name:null}}},states:{DeviceReady:{always:{target:"OnboardingCheck"}},OnboardingCheck:{always:[{target:"GetDeviceStatus",guard:{type:"isDeviceOnboarded"}},{target:"Error",actions:"assignErrorDeviceNotOnboarded"}]},GetDeviceStatus:{invoke:{id:"deviceStatus",src:"getDeviceStatus",input:e=>({unlockTimeout:e.context.input.unlockTimeout}),onSnapshot:{actions:t({intermediateValue:e=>e.event.snapshot.context.intermediateValue})},onDone:{target:"CheckDeviceStatus",actions:t({_internalState:e=>e.event.output.caseOf({Right:n=>{const p=a();return p.sessionStateType!==l.Connected&&d({...p,currentApp:{name:n.currentApp,version:n.currentAppVersion}}),{...e.context._internalState,currentlyRunningApp:n.currentApp}},Left:n=>({...e.context._internalState,currentlyRunningApp:null,error:n})})})},onError:{target:"Error",actions:[t({_internalState:e=>({...e.context._internalState,currentlyRunningApp:null})}),"assignErrorFromEvent"]}}},CheckDeviceStatus:{always:[{target:"ApplicationReady",guard:"isRequestedAppOpen",actions:"assignNoError"},{target:"Error",guard:"hasError"},{target:"DashboardCheck"}]},DashboardCheck:{always:[{target:"OpenApplication",guard:"isDashboardOpen"},"CloseApplication"]},OpenApplication:{entry:"assignUserActionNeededOpenApp",exit:"assignNoUserActionNeeded",invoke:{src:"openApp",input:({context:e})=>({appName:e.input.appName}),onDone:{target:"OpenApplicationResultCheck",actions:t({_internalState:e=>u(e.event.output)?{...e.context._internalState,currentlyRunningApp:e.context.input.appName}:{...e.context._internalState,error:e.event.output.error}})},onError:{target:"OpenApplicationResultCheck",actions:"assignErrorFromEvent"}}},OpenApplicationResultCheck:{always:[{target:"GetDeviceStatus",guard:"hasDisconnectedWhileSending"},{target:"Error",guard:"hasError"},{target:"GetDeviceStatus"}]},CloseApplication:{invoke:{src:"closeApp",onDone:{target:"CloseApplicationResultCheck",actions:t({_internalState:e=>u(e.event.output)?{...e.context._internalState,currentlyRunningApp:"BOLOS"}:{...e.context._internalState,error:e.event.output.error}})},onError:{target:"Error",actions:"assignErrorFromEvent"}}},CloseApplicationResultCheck:{always:[{target:"Error",guard:"hasError"},{target:"OpenApplication"}]},ApplicationReady:{always:"Success"},Success:{type:"final",actions:"assignNoError"},Error:{type:"final"}},output:({context:e})=>e._internalState.error?D(e._internalState.error):g(void 0)})}extractDependencies(r){return{closeApp:async()=>r.sendCommand(new O),openApp:async a=>r.sendCommand(new v({appName:a.input.appName})),getDeviceSessionState:()=>r.getDeviceSessionState(),setDeviceSessionState:a=>r.setDeviceSessionState(a),isDeviceOnboarded:()=>!0}}}export{W as OpenAppDeviceAction};
//# sourceMappingURL=OpenAppDeviceAction.js.map
