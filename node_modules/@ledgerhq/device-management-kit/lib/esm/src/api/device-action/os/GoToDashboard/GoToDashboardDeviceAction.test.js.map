{
  "version": 3,
  "sources": ["../../../../../../../src/api/device-action/os/GoToDashboard/GoToDashboardDeviceAction.test.ts"],
  "sourcesContent": ["import { CommandResultFactory } from \"@api/command/model/CommandResult\";\nimport {\n  GLOBAL_ERRORS,\n  GlobalCommandError,\n} from \"@api/command/utils/GlobalCommandError\";\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport { DeviceStatus } from \"@api/device/DeviceStatus\";\nimport { makeDeviceActionInternalApiMock } from \"@api/device-action/__test-utils__/makeInternalApi\";\nimport { setupGetDeviceStatusMock } from \"@api/device-action/__test-utils__/setupTestMachine\";\nimport { testDeviceActionStates } from \"@api/device-action/__test-utils__/testDeviceActionStates\";\nimport { DeviceActionStatus } from \"@api/device-action/model/DeviceActionState\";\nimport { UserInteractionRequired } from \"@api/device-action/model/UserInteractionRequired\";\nimport { UnknownDAError } from \"@api/device-action/os/Errors\";\nimport { DeviceSessionStateType } from \"@api/device-session/DeviceSessionState\";\nimport { UnknownDeviceExchangeError } from \"@root/src\";\n\nimport { GoToDashboardDeviceAction } from \"./GoToDashboardDeviceAction\";\nimport { type GoToDashboardDAState } from \"./types\";\n\nvi.mock(\"@api/device-action/os/GetDeviceStatus/GetDeviceStatusDeviceAction\");\n\ndescribe(\"GoToDashboardDeviceAction\", () => {\n  const closeAppMock = vi.fn();\n  const getAppAndVersionMock = vi.fn();\n  const getDeviceSessionStateMock = vi.fn();\n  const setDeviceSessionStateMock = vi.fn();\n\n  function extractDependenciesMock() {\n    return {\n      closeApp: closeAppMock,\n      getAppAndVersion: getAppAndVersionMock,\n      getDeviceSessionState: getDeviceSessionStateMock,\n      setDeviceSessionState: setDeviceSessionStateMock,\n    };\n  }\n\n  const {\n    sendCommand: sendCommandMock,\n    getDeviceSessionState: apiGetDeviceSessionStateMock,\n  } = makeDeviceActionInternalApiMock();\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n  });\n\n  describe(\"without overriding `extractDependencies`\", () => {\n    it(\"should run the device action with device already on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending, // GetDeviceStatus events (mocked for tests)\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should run the device action with device not on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock([\n          {\n            currentApp: \"Bitcoin\",\n            currentAppVersion: \"1.0.0\",\n          },\n        ]);\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"Bitcoin\", version: \"1.0.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        sendCommandMock\n          .mockResolvedValueOnce(CommandResultFactory({ data: undefined }))\n          .mockResolvedValueOnce(\n            CommandResultFactory({\n              data: {\n                name: \"BOLOS\",\n                version: \"1.5.0\",\n              },\n            }),\n          );\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"success cases\", () => {\n    it(\"should success if the device is already on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n        });\n\n        getAppAndVersionMock.mockReturnValue({\n          app: \"BOLOS\",\n          version: \"1.5.0\",\n        });\n\n        vi.spyOn(\n          goToDashboardDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    it(\"should success if the device is not on dashboard\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock();\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        vi.spyOn(\n          goToDashboardDeviceAction,\n          \"extractDependencies\",\n        ).mockReturnValue(extractDependenciesMock());\n\n        getDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.Connected,\n          deviceStatus: DeviceStatus.CONNECTED,\n        });\n\n        closeAppMock.mockResolvedValue(\n          CommandResultFactory({ data: undefined }),\n        );\n        getAppAndVersionMock.mockReturnValue(\n          CommandResultFactory({\n            data: {\n              name: \"BOLOS\",\n              version: \"1.5.0\",\n            },\n          }),\n        );\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            output: undefined,\n            status: DeviceActionStatus.Completed,\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n  });\n\n  describe(\"error cases\", () => {\n    it(\"should return an error if GetDeviceStatus return an error\", () =>\n      new Promise<void>((resolve, reject) => {\n        setupGetDeviceStatusMock([new UnknownDAError(\"Unknown error\")]);\n\n        const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n          input: { unlockTimeout: 500 },\n        });\n\n        apiGetDeviceSessionStateMock.mockReturnValue({\n          sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n          deviceStatus: DeviceStatus.CONNECTED,\n          currentApp: { name: \"BOLOS\", version: \"1.5.0\" },\n          installedApps: [],\n          deviceModelId: DeviceModelId.NANO_X,\n          isSecureConnectionAllowed: false,\n        });\n\n        const expectedStates: Array<GoToDashboardDAState> = [\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            intermediateValue: {\n              requiredUserInteraction: UserInteractionRequired.None,\n            },\n            status: DeviceActionStatus.Pending,\n          },\n          {\n            status: DeviceActionStatus.Error,\n            error: new UnknownDAError(\"Unknown error\"),\n          },\n        ];\n\n        testDeviceActionStates(\n          goToDashboardDeviceAction,\n          expectedStates,\n          makeDeviceActionInternalApiMock(),\n          {\n            onDone: resolve,\n            onError: reject,\n          },\n        );\n      }));\n\n    describe(\"not on dashboard\", () => {\n      it(\"should return an error if closeApp fails\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: {},\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockReturnValue(\n            CommandResultFactory({\n              error: new UnknownDeviceExchangeError(\"Close app failed\"),\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error: new UnknownDeviceExchangeError(\"Close app failed\"),\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n\n      it(\"should return an error if getAppAndVersion fails\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: { unlockTimeout: 500 },\n          });\n          const error = new GlobalCommandError({\n            ...GLOBAL_ERRORS[\"5501\"],\n            errorCode: \"5501\",\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockResolvedValue(\n            CommandResultFactory({ data: undefined }),\n          );\n          getAppAndVersionMock.mockResolvedValue(\n            CommandResultFactory({\n              error,\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error,\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n\n      it(\"should return an error if getAppAndVersion does not return an app name\", () =>\n        new Promise<void>((resolve, reject) => {\n          setupGetDeviceStatusMock([\n            {\n              currentApp: \"Bitcoin\",\n              currentAppVersion: \"1.0.0\",\n            },\n          ]);\n\n          const goToDashboardDeviceAction = new GoToDashboardDeviceAction({\n            input: { unlockTimeout: 500 },\n          });\n\n          vi.spyOn(\n            goToDashboardDeviceAction,\n            \"extractDependencies\",\n          ).mockReturnValue(extractDependenciesMock());\n\n          getDeviceSessionStateMock.mockReturnValue({\n            sessionStateType: DeviceSessionStateType.Connected,\n            deviceStatus: DeviceStatus.CONNECTED,\n            currentApp: \"Bitcoin\",\n          });\n\n          closeAppMock.mockResolvedValue(\n            CommandResultFactory({ data: undefined }),\n          );\n          getAppAndVersionMock.mockResolvedValue(\n            CommandResultFactory({\n              data: {\n                name: null,\n                version: \"1.0.0\",\n              },\n            }),\n          );\n\n          const expectedStates: Array<GoToDashboardDAState> = [\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              intermediateValue: {\n                requiredUserInteraction: UserInteractionRequired.None,\n              },\n              status: DeviceActionStatus.Pending,\n            },\n            {\n              status: DeviceActionStatus.Error,\n              error: new UnknownDAError(\"currentApp === null\"),\n            },\n          ];\n\n          testDeviceActionStates(\n            goToDashboardDeviceAction,\n            expectedStates,\n            makeDeviceActionInternalApiMock(),\n            {\n              onDone: resolve,\n              onError: reject,\n            },\n          );\n        }));\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["CommandResultFactory", "GLOBAL_ERRORS", "GlobalCommandError", "DeviceModelId", "DeviceStatus", "makeDeviceActionInternalApiMock", "setupGetDeviceStatusMock", "testDeviceActionStates", "DeviceActionStatus", "UserInteractionRequired", "UnknownDAError", "DeviceSessionStateType", "UnknownDeviceExchangeError", "GoToDashboardDeviceAction", "closeAppMock", "getAppAndVersionMock", "getDeviceSessionStateMock", "setDeviceSessionStateMock", "extractDependenciesMock", "sendCommandMock", "apiGetDeviceSessionStateMock", "resolve", "reject", "goToDashboardDeviceAction", "expectedStates", "error"]
}
