{
  "version": 3,
  "sources": ["../../../../../src/api/utils/HexaString.ts"],
  "sourcesContent": ["export type HexaString = `0x${string}`;\n\nexport function isHexaString(value: unknown): value is HexaString {\n  return typeof value === \"string\" && /^0x[0-9a-fA-F]*$/.test(value);\n}\n\nexport function hexaStringToBuffer(value: string): Uint8Array | null {\n  if (value.startsWith(\"0x\")) {\n    value = value.slice(2);\n  }\n  if (value.length === 0) {\n    return new Uint8Array();\n  }\n  if (value.length % 2 !== 0) {\n    value = \"0\" + value;\n  }\n  if (/^[0-9a-fA-F]*$/.test(value) === false) {\n    return null;\n  }\n  const bytes = value.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16));\n  if (!bytes || bytes.some(isNaN)) {\n    return null;\n  }\n  return new Uint8Array(bytes);\n}\n\nexport function bufferToHexaString(\n  value: Uint8Array,\n  withPrefix?: true,\n): HexaString;\nexport function bufferToHexaString(\n  value: Uint8Array,\n  withPrefix?: false,\n): string;\nexport function bufferToHexaString(\n  value: Uint8Array,\n  withPrefix: boolean = true,\n): HexaString | string {\n  const prefix = withPrefix ? \"0x\" : \"\";\n  return `${prefix}${Array.from(value, (byte) =>\n    byte.toString(16).padStart(2, \"0\"),\n  ).join(\"\")}`;\n}\n"],
  "mappings": "AAEO,SAASA,EAAaC,EAAqC,CAChE,OAAO,OAAOA,GAAU,UAAY,mBAAmB,KAAKA,CAAK,CACnE,CAEO,SAASC,EAAmBD,EAAkC,CAInE,GAHIA,EAAM,WAAW,IAAI,IACvBA,EAAQA,EAAM,MAAM,CAAC,GAEnBA,EAAM,SAAW,EACnB,OAAO,IAAI,WAKb,GAHIA,EAAM,OAAS,IAAM,IACvBA,EAAQ,IAAMA,GAEZ,iBAAiB,KAAKA,CAAK,IAAM,GACnC,OAAO,KAET,MAAME,EAAQF,EAAM,MAAM,SAAS,GAAG,IAAKG,GAAS,SAASA,EAAM,EAAE,CAAC,EACtE,MAAI,CAACD,GAASA,EAAM,KAAK,KAAK,EACrB,KAEF,IAAI,WAAWA,CAAK,CAC7B,CAUO,SAASE,EACdJ,EACAK,EAAsB,GACD,CAErB,MAAO,GADQA,EAAa,KAAO,EACnB,GAAG,MAAM,KAAKL,EAAQG,GACpCA,EAAK,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CACnC,EAAE,KAAK,EAAE,CAAC,EACZ",
  "names": ["isHexaString", "value", "hexaStringToBuffer", "bytes", "byte", "bufferToHexaString", "withPrefix"]
}
