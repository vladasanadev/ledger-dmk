import{CommandResultFactory as n,isSuccessCommandResult as a}from"../../command/model/CommandResult";import{LoadCertificateCommand as s,LoadCertificateCommandError as c}from"../../command/os/LoadCertificateCommand";import{GlobalCommandError as i}from"../../command/utils/GlobalCommandError";import{hexaStringToBuffer as d}from"../../utils/HexaString";describe("LoadCertificateCommand",()=>{describe("name",()=>{it("should be 'loadCertificate'",()=>{const t=new s({keyUsage:1,certificate:new Uint8Array});expect(t.name).toBe("loadCertificate")})}),describe("getApdu",()=>{it("should return the APDU with key equal to 1",()=>{const t={keyUsage:66,certificate:new Uint8Array([1,2,3])},e=new s(t).getApdu();expect(e.cla).toBe(176),expect(e.ins).toBe(6),expect(e.p1).toBe(66),expect(e.p2).toBe(0),expect(e.data).toStrictEqual(new Uint8Array([1,2,3]))})}),describe("parseResponse",()=>{let t;beforeEach(()=>{t=new s({keyUsage:1,certificate:new Uint8Array})}),it("should return success if the response status code is success",()=>{const r={statusCode:new Uint8Array([144,0]),data:new Uint8Array},e=t.parseResponse(r);expect(e).toStrictEqual(n({data:void 0}))}),describe("errors",()=>{it("should return error command result if the device is locked",()=>{const r={statusCode:new Uint8Array([85,21]),data:new Uint8Array},e=t.parseResponse(r);a(e)?assert.fail("Expected error command result"):expect(e.error).toBeInstanceOf(i)}),it.each(["422f","4230","4231","4232","4233","4234","4235","4236","4237","4238","4239","422d","3301","422e","5720","4118","ffff"])("should return a ProvidePkiCertificateCommandError if the response is a %s specific error code",r=>{const e={statusCode:d(r),data:new Uint8Array},o=t.parseResponse(e);a(o)?assert.fail("Expected error command result"):(expect(o.error).toBeInstanceOf(c),expect(o.error.errorCode).toBe(r))})})})});
//# sourceMappingURL=LoadCertificateCommand.test.js.map
