{
  "version": 3,
  "sources": ["../../../../../../src/api/command/os/LoadCertificateCommand.test.ts"],
  "sourcesContent": ["import {\n  CommandResultFactory,\n  isSuccessCommandResult,\n} from \"@api/command/model/CommandResult\";\nimport {\n  LoadCertificateCommand,\n  LoadCertificateCommandError,\n} from \"@api/command/os/LoadCertificateCommand\";\nimport { GlobalCommandError } from \"@api/command/utils/GlobalCommandError\";\nimport { hexaStringToBuffer } from \"@api/utils/HexaString\";\n\ndescribe(\"LoadCertificateCommand\", () => {\n  describe(\"name\", () => {\n    it(\"should be 'loadCertificate'\", () => {\n      const command = new LoadCertificateCommand({\n        keyUsage: 0x01,\n        certificate: new Uint8Array(),\n      });\n      expect(command.name).toBe(\"loadCertificate\");\n    });\n  });\n\n  describe(\"getApdu\", () => {\n    it(\"should return the APDU with key equal to 1\", () => {\n      // GIVEN\n      const args = {\n        keyUsage: 0x42,\n        certificate: new Uint8Array([0x01, 0x02, 0x03]),\n      };\n      const command = new LoadCertificateCommand(args);\n\n      // WHEN\n      const apdu = command.getApdu();\n\n      // THEN\n      expect(apdu.cla).toBe(0xb0);\n      expect(apdu.ins).toBe(0x06);\n      expect(apdu.p1).toBe(0x42);\n      expect(apdu.p2).toBe(0x00);\n      expect(apdu.data).toStrictEqual(new Uint8Array([0x01, 0x02, 0x03]));\n    });\n  });\n\n  describe(\"parseResponse\", () => {\n    let command: LoadCertificateCommand;\n\n    beforeEach(() => {\n      command = new LoadCertificateCommand({\n        keyUsage: 0x01,\n        certificate: new Uint8Array(),\n      });\n    });\n\n    it(\"should return success if the response status code is success\", () => {\n      // GIVEN\n      const response = {\n        statusCode: new Uint8Array([0x90, 0x00]),\n        data: new Uint8Array(),\n      };\n\n      // WHEN\n      const result = command.parseResponse(response);\n\n      // THEN\n      expect(result).toStrictEqual(CommandResultFactory({ data: undefined }));\n    });\n\n    describe(\"errors\", () => {\n      it(\"should return error command result if the device is locked\", () => {\n        // GIVEN\n        const response = {\n          statusCode: new Uint8Array([0x55, 0x15]),\n          data: new Uint8Array(),\n        };\n\n        // WHEN\n        const result = command.parseResponse(response);\n\n        // THEN\n        if (isSuccessCommandResult(result)) {\n          assert.fail(\"Expected error command result\");\n        } else {\n          expect(result.error).toBeInstanceOf(GlobalCommandError);\n        }\n      });\n\n      it.each([\n        \"422f\",\n        \"4230\",\n        \"4231\",\n        \"4232\",\n        \"4233\",\n        \"4234\",\n        \"4235\",\n        \"4236\",\n        \"4237\",\n        \"4238\",\n        \"4239\",\n        \"422d\",\n        \"3301\",\n        \"422e\",\n        \"5720\",\n        \"4118\",\n        \"ffff\",\n      ])(\n        \"should return a ProvidePkiCertificateCommandError if the response is a %s specific error code\",\n        (errorCode) => {\n          // GIVEN\n          const response = {\n            statusCode: hexaStringToBuffer(errorCode)!,\n            data: new Uint8Array(),\n          };\n\n          // WHEN\n          const result = command.parseResponse(response);\n\n          // THEN\n          if (isSuccessCommandResult(result)) {\n            assert.fail(\"Expected error command result\");\n          } else {\n            expect(result.error).toBeInstanceOf(LoadCertificateCommandError);\n            // @ts-expect-error intended\n            expect(result.error.errorCode).toBe(errorCode);\n          }\n        },\n      );\n    });\n  });\n});\n"],
  "mappings": "AAAA,OACE,wBAAAA,EACA,0BAAAC,MACK,mCACP,OACE,0BAAAC,EACA,+BAAAC,MACK,yCACP,OAAS,sBAAAC,MAA0B,wCACnC,OAAS,sBAAAC,MAA0B,wBAEnC,SAAS,yBAA0B,IAAM,CACvC,SAAS,OAAQ,IAAM,CACrB,GAAG,8BAA+B,IAAM,CACtC,MAAMC,EAAU,IAAIJ,EAAuB,CACzC,SAAU,EACV,YAAa,IAAI,UACnB,CAAC,EACD,OAAOI,EAAQ,IAAI,EAAE,KAAK,iBAAiB,CAC7C,CAAC,CACH,CAAC,EAED,SAAS,UAAW,IAAM,CACxB,GAAG,6CAA8C,IAAM,CAErD,MAAMC,EAAO,CACX,SAAU,GACV,YAAa,IAAI,WAAW,CAAC,EAAM,EAAM,CAAI,CAAC,CAChD,EAIMC,EAHU,IAAIN,EAAuBK,CAAI,EAG1B,QAAQ,EAG7B,OAAOC,EAAK,GAAG,EAAE,KAAK,GAAI,EAC1B,OAAOA,EAAK,GAAG,EAAE,KAAK,CAAI,EAC1B,OAAOA,EAAK,EAAE,EAAE,KAAK,EAAI,EACzB,OAAOA,EAAK,EAAE,EAAE,KAAK,CAAI,EACzB,OAAOA,EAAK,IAAI,EAAE,cAAc,IAAI,WAAW,CAAC,EAAM,EAAM,CAAI,CAAC,CAAC,CACpE,CAAC,CACH,CAAC,EAED,SAAS,gBAAiB,IAAM,CAC9B,IAAIF,EAEJ,WAAW,IAAM,CACfA,EAAU,IAAIJ,EAAuB,CACnC,SAAU,EACV,YAAa,IAAI,UACnB,CAAC,CACH,CAAC,EAED,GAAG,+DAAgE,IAAM,CAEvE,MAAMO,EAAW,CACf,WAAY,IAAI,WAAW,CAAC,IAAM,CAAI,CAAC,EACvC,KAAM,IAAI,UACZ,EAGMC,EAASJ,EAAQ,cAAcG,CAAQ,EAG7C,OAAOC,CAAM,EAAE,cAAcV,EAAqB,CAAE,KAAM,MAAU,CAAC,CAAC,CACxE,CAAC,EAED,SAAS,SAAU,IAAM,CACvB,GAAG,6DAA8D,IAAM,CAErE,MAAMS,EAAW,CACf,WAAY,IAAI,WAAW,CAAC,GAAM,EAAI,CAAC,EACvC,KAAM,IAAI,UACZ,EAGMC,EAASJ,EAAQ,cAAcG,CAAQ,EAGzCR,EAAuBS,CAAM,EAC/B,OAAO,KAAK,+BAA+B,EAE3C,OAAOA,EAAO,KAAK,EAAE,eAAeN,CAAkB,CAE1D,CAAC,EAED,GAAG,KAAK,CACN,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACF,CAAC,EACC,gGACCO,GAAc,CAEb,MAAMF,EAAW,CACf,WAAYJ,EAAmBM,CAAS,EACxC,KAAM,IAAI,UACZ,EAGMD,EAASJ,EAAQ,cAAcG,CAAQ,EAGzCR,EAAuBS,CAAM,EAC/B,OAAO,KAAK,+BAA+B,GAE3C,OAAOA,EAAO,KAAK,EAAE,eAAeP,CAA2B,EAE/D,OAAOO,EAAO,MAAM,SAAS,EAAE,KAAKC,CAAS,EAEjD,CACF,CACF,CAAC,CACH,CAAC,CACH,CAAC",
  "names": ["CommandResultFactory", "isSuccessCommandResult", "LoadCertificateCommand", "LoadCertificateCommandError", "GlobalCommandError", "hexaStringToBuffer", "command", "args", "apdu", "response", "result", "errorCode"]
}
