import s from"axios";import{Left as i,Right as o}from"purify-ts";import{BTC_APP as p,BTC_APP_METADATA as l,CUSTOM_LOCK_SCREEN_APP as h,CUSTOM_LOCK_SCREEN_APP_METADATA as u,ETH_APP_METADATA as g}from"../../../api/device-action/__test-utils__/data";import{HttpFetchApiError as n}from"../../manager-api/model/Errors";import{AxiosManagerApiDataSource as t}from"./AxiosManagerApiDataSource";vi.mock("axios");describe("AxiosManagerApiDataSource",()=>{describe("getAppList",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a list of applications",async()=>{const e=[l,g];vi.spyOn(s,"get").mockResolvedValue({data:e});const r=await a.getAppList({targetId:"targetId",firmwareVersionName:"firmwareVersionName"});expect(r).toEqual(o(e))}),it("should return an error if payload don't match the dto",async()=>{const{versionId:e,...r}=l,d=[{versionId:"invalidVersion",...r}];vi.spyOn(s,"get").mockResolvedValue({data:d});const c=await a.getAppList({targetId:"targetId",firmwareVersionName:"firmwareVersionName"});expect(c.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getAppList({targetId:"targetId",firmwareVersionName:"firmwareVersionName"});expect(r).toEqual(i(new n(e)))})}),describe("getAppsByHash",()=>{describe("success cases",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("with BTC app, should return the metadata",async()=>{vi.spyOn(s,"post").mockResolvedValue({data:[l]});const e=[p.appFullHash],r=await a.getAppsByHash({hashes:e});expect(r).toEqual(o([l]))}),it("with no apps, should return an empty list",async()=>{vi.spyOn(s,"post").mockResolvedValue({data:[]});const e=[],r=await a.getAppsByHash({hashes:e});expect(r).toEqual(o([]))}),it("with BTC app and custom lock screen, should return the metadata",async()=>{vi.spyOn(s,"post").mockResolvedValue({data:[l,u]});const e=[p.appFullHash,h.appFullHash],r=await a.getAppsByHash({hashes:e});expect(r).toEqual(o([l,u]))})}),describe("error cases",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("with BTC app, should fail if payload don't match the dto",async()=>{const{versionId:e,...r}=l;vi.spyOn(s,"post").mockResolvedValue({data:[{versionId:"invalidVersion",...r}]});const d=[p.appFullHash],c=await a.getAppsByHash({hashes:d});expect(c.isRight()).toEqual(!1)}),it("should throw an error if the request fails",async()=>{const e=new t({}),r=new Error("fetch error");vi.spyOn(s,"post").mockRejectedValue(r);const d=[p.appFullHash],c=await e.getAppsByHash({hashes:d});expect(c).toEqual(i(new n(r)))})})}),describe("getDeviceVersion",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a complete device version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:17,target_id:"857735172"}});const e=await a.getDeviceVersion({targetId:"targetId"});expect(e).toEqual(o({id:17}))}),it("should return an error if payload don't match dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{target_id:"857735172"}});const e=await a.getDeviceVersion({targetId:"targetId"});expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getDeviceVersion({targetId:"targetId"});expect(r).toEqual(i(new n(e)))})}),describe("getFirmwareVersion",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a complete firmware version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:361,version:"1.6.0",perso:"perso_11",firmware:null,firmware_key:"testKey",hash:"hash",bytes:194,mcu_versions:[1,5,7]}});const e=await a.getFirmwareVersion({version:"versionName",deviceId:42});expect(e).toEqual(o({id:361,version:"1.6.0",perso:"perso_11",firmware:null,firmwareKey:"testKey",hash:"hash",bytes:194,mcuVersions:[1,5,7]}))}),it("should return an error if payload don't match the dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:"invalidId",version:"1.6.0",perso:"perso_11",firmware:null,firmware_key:"testKey",hash:"hash",bytes:194,mcu_versions:[1,5,7]}});const e=await a.getFirmwareVersion({version:"versionName",deviceId:42});expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getFirmwareVersion({version:"versionName",deviceId:42});expect(r).toEqual(i(new n(e)))})}),describe("setProvider",()=>{let a;beforeEach(()=>{a=new t({managerApiUrl:"http://fake-url.com",provider:1})}),it("should not change the provider if the new value is the same",()=>{const e=a._provider;a.setProvider(e),expect(a._provider).toBe(e)}),it("should not change the provider if the new value is less than 1",()=>{const e=a._provider;a.setProvider(0),a.setProvider(-5),expect(a._provider).toBe(e)}),it("should update the provider if a valid and different value is provided",()=>{a.setProvider(2),expect(a._provider).toBe(2)})}),describe("getFirmwareVersionById",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a complete firmware version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:361,version:"1.6.0",perso:"perso_11",firmware:null,firmware_key:"testKey",hash:"hash",bytes:194,mcu_versions:[1,5,7]}});const e=await a.getFirmwareVersionById(42);expect(e).toEqual(o({id:361,version:"1.6.0",perso:"perso_11",firmware:null,firmwareKey:"testKey",hash:"hash",bytes:194,mcuVersions:[1,5,7]}))})}),describe("getLatestFirmwareVersion",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return the latest firmware version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{result:"success",se_firmware_osu_version:{id:361,perso:"perso_11",firmware:"test",firmware_key:"testKey",hash:"hash",next_se_firmware_final_version:567}}});const e=await a.getLatestFirmwareVersion({currentFinalFirmwareId:200,deviceId:42});expect(e).toEqual(o({id:361,perso:"perso_11",firmware:"test",firmwareKey:"testKey",hash:"hash",nextFinalFirmware:567}))}),it("should return an error if result is not success",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{result:"failed",se_firmware_osu_version:null}});const e=await a.getLatestFirmwareVersion({currentFinalFirmwareId:200,deviceId:42});expect(e.isRight()).toEqual(!1)}),it("should return an error if payload don't match the dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{result:"success",se_firmware_osu_version:{id:"InvalidId",perso:"perso_11",firmware:"test",firmware_key:"testKey",hash:"hash",next_se_firmware_final_version:567}}});const e=await a.getLatestFirmwareVersion({currentFinalFirmwareId:200,deviceId:42});expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getLatestFirmwareVersion({currentFinalFirmwareId:200,deviceId:42});expect(r).toEqual(i(new n(e)))})}),describe("getOsuFirmwareVersion",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a complete OSU firmware version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:361,perso:"perso_11",firmware:"test",firmware_key:"testKey",hash:"hash",next_se_firmware_final_version:567}});const e=await a.getOsuFirmwareVersion({version:"versionName",deviceId:42});expect(e).toEqual(o({id:361,perso:"perso_11",firmware:"test",firmwareKey:"testKey",hash:"hash",nextFinalFirmware:567}))}),it("should return an error if payload don't match the dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:{id:"invalidId",perso:"perso_11",firmware:"test",firmware_key:"testKey",hash:"hash",next_se_firmware_final_version:567}});const e=await a.getOsuFirmwareVersion({version:"versionName",deviceId:42});expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getOsuFirmwareVersion({version:"versionName",deviceId:42});expect(r).toEqual(i(new n(e)))})}),describe("getLanguagePackages",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return the langage packages version",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:[{language:"turkish",languagePackageVersionId:474,version:"0.0.4",language_package_id:57,apdu_install_url:"https://download.languages.ledger.com/stax/turkish/bolos_1.6.2_pack_0.0.4_tr.apdu",apdu_uninstall_url:"https://download.languages.ledger.com/stax/turkish/bolos_1.6.2_pack_0.0.4_tr_del.apdu",device_versions:[17],se_firmware_final_versions:[432],bytes:20800,date_creation:"2025-03-04T10:48:27.910630Z",date_last_modified:"2025-03-04T10:48:27.910630Z"},{language:"russian",languagePackageVersionId:470,version:"0.0.4",language_package_id:56,apdu_install_url:"https://download.languages.ledger.com/stax/russian/bolos_1.6.2_pack_0.0.4_ru.apdu",apdu_uninstall_url:"https://download.languages.ledger.com/stax/russian/bolos_1.6.2_pack_0.0.4_ru_del.apdu",device_versions:[17],se_firmware_final_versions:[432],bytes:46592,date_creation:"2025-03-04T10:48:26.218729Z",date_last_modified:"2025-03-04T10:48:26.218729Z"}]});const e=await a.getLanguagePackages({deviceId:1,currentFinalFirmwareId:42});expect(e).toEqual(o([{language:"turkish",languagePackageVersionId:474,version:"0.0.4",languagePackageId:57,apduInstallUrl:"https://download.languages.ledger.com/stax/turkish/bolos_1.6.2_pack_0.0.4_tr.apdu",apduUninstallUrl:"https://download.languages.ledger.com/stax/turkish/bolos_1.6.2_pack_0.0.4_tr_del.apdu",bytes:20800,dateCreation:"2025-03-04T10:48:27.910630Z",dateLastModified:"2025-03-04T10:48:27.910630Z"},{language:"russian",languagePackageVersionId:470,version:"0.0.4",languagePackageId:56,apduInstallUrl:"https://download.languages.ledger.com/stax/russian/bolos_1.6.2_pack_0.0.4_ru.apdu",apduUninstallUrl:"https://download.languages.ledger.com/stax/russian/bolos_1.6.2_pack_0.0.4_ru_del.apdu",bytes:46592,dateCreation:"2025-03-04T10:48:26.218729Z",dateLastModified:"2025-03-04T10:48:26.218729Z"}]))}),it("should return an error if payload don't match the dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:[{language:"turkish",version:"0.0.4",language_package_id:"invalid"}]});const e=await a.getLanguagePackages({deviceId:1,currentFinalFirmwareId:42});expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getLanguagePackages({deviceId:1,currentFinalFirmwareId:42});expect(r).toEqual(i(new n(e)))})}),describe("getMcuList",()=>{let a;beforeEach(()=>{a=new t({})}),afterEach(()=>{vi.clearAllMocks()}),it("should return a the list of MCUs",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:[{id:1,mcu:1,name:"1.0",description:null,providers:[],device_versions:[1,2],from_bootloader_version:"",from_bootloader_version_id:2,se_firmware_final_versions:[7,12,13,14,15],date_creation:"2018-09-20T13:30:50.156394Z",date_last_modified:"2018-09-20T13:30:50.156453Z"},{id:2,mcu:1,name:"1.1",description:null,providers:[],device_versions:[1,2],from_bootloader_version:"",from_bootloader_version_id:2,se_firmware_final_versions:[7,12,13,14,15],date_creation:"2018-09-20T13:30:50.339966Z",date_last_modified:"2018-09-20T13:30:50.340031Z"}]});const e=await a.getMcuList();expect(e).toEqual(o([{id:1,name:"1.0"},{id:2,name:"1.1"}]))}),it("should return an error when the payload don't match the dto",async()=>{vi.spyOn(s,"get").mockResolvedValue({data:[{id:"invalid id",mcu:1,name:"1.0",description:null,providers:[],se_firmware_final_versions:[7,12,13,14,15],date_creation:"2018-09-20T13:30:50.156394Z",date_last_modified:"2018-09-20T13:30:50.156453Z"}]});const e=await a.getMcuList();expect(e.isRight()).toEqual(!1)}),it("should return an error if the request fails",async()=>{const e=new Error("fetch error");vi.spyOn(s,"get").mockRejectedValue(e);const r=await a.getMcuList();expect(r).toEqual(i(new n(e)))})}),describe("getProvider",()=>{let a;beforeEach(()=>{a=new t({managerApiUrl:"http://fake-url.com",provider:123})}),afterEach(()=>{vi.clearAllMocks()}),it("should return the initial provider",()=>{expect(a.getProvider()).toBe(123)}),it("should return the updated provider after setProvider is called",()=>{a.setProvider(321),expect(a.getProvider()).toBe(321)})})});
//# sourceMappingURL=AxiosManagerApiDataSource.test.js.map
