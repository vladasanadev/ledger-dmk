import{Left as n,Right as i}from"purify-ts";import{getOsVersionCommandResponseMockBuilder as c}from"../../../api/command/os/__mocks__/GetOsVersionCommand";import{DeviceModelId as p}from"../../../api/device/DeviceModel";import{BTC_APP as s,BTC_APP_METADATA as o,ETH_APP as l,ETH_APP_METADATA as d}from"../../../api/device-action/__test-utils__/data";import{AxiosManagerApiDataSource as m}from"../../manager-api/data/AxiosManagerApiDataSource";import{HttpFetchApiError as h}from"../../manager-api/model/Errors";import{DefaultManagerApiService as u}from"./DefaultManagerApiService";vi.mock("@internal/manager-api/data/AxiosManagerApiDataSource");let t,a;describe("ManagerApiService",()=>{beforeEach(()=>{t=new m({}),a=new u(t)}),describe("getAppList",()=>{it("should call api with the correct parameters",()=>{const e=c(p.STAX);a.getAppList(e),expect(t.getAppList).toHaveBeenCalledWith({targetId:"857735172",firmwareVersionName:"1.3.0"})})}),describe("getAppsByHash",()=>{describe("success cases",()=>{it("with no apps, should return an empty list",async()=>{t.getAppsByHash.mockResolvedValue(i([])),expect(await a.getAppsByHash([])).toEqual(i([]))}),it("with one app, should return the metadata",async()=>{t.getAppsByHash.mockResolvedValue(i([o])),expect(await a.getAppsByHash([s.appFullHash])).toEqual(i([o]))}),it("with two app, should return the metadata of both apps",async()=>{t.getAppsByHash.mockResolvedValue(i([o,d])),expect(await a.getAppsByHash([s,l].map(e=>e.appFullHash))).toEqual(i([o,d]))}),it("with one app and one without `appFullHash`, should return the metadata of the correct app",async()=>{t.getAppsByHash.mockResolvedValue(i([o]));const e={...l,appFullHash:""};expect(await a.getAppsByHash([s,e].map(r=>r.appFullHash))).toEqual(i([o]))})}),describe("error cases",()=>{it("should return an error when the data source fails with a known error",async()=>{const e=new h(new Error("Failed to fetch data"));t.getAppsByHash.mockRejectedValue(e),expect(await a.getAppsByHash([s.appFullHash])).toEqual(n(e))}),it("should return an error when the data source fails with an unknown error",async()=>{const e=new Error("unkown error");t.getAppsByHash.mockRejectedValue(e),expect(await a.getAppsByHash([s.appFullHash])).toEqual(n(new h(e)))})})}),describe("getDeviceVersion",()=>{it("should call api with the correct parameters",()=>{const e=c(p.STAX);a.getDeviceVersion(e),expect(t.getDeviceVersion).toHaveBeenCalledWith({targetId:"857735172"})})}),describe("getFirmwareVersion",()=>{it("should call api with the correct parameters",()=>{const e={id:17,target_id:"857735172"},r=c(p.STAX);a.getFirmwareVersion(r,e),expect(t.getFirmwareVersion).toHaveBeenCalledWith({deviceId:17,version:"1.3.0"})})}),describe("getOsuFirmwareVersion",()=>{it("should call api with the correct parameters",()=>{const e={id:17,target_id:"857735172"},r=c(p.STAX);a.getOsuFirmwareVersion(r,e),expect(t.getOsuFirmwareVersion).toHaveBeenCalledWith({deviceId:17,version:"1.3.0"})})}),describe("getLatestFirmwareVersion",()=>{it("should call api with the correct parameters",()=>{const e={id:17,target_id:"857735172"},r={id:159};a.getLatestFirmwareVersion(r,e),expect(t.getLatestFirmwareVersion).toHaveBeenCalledWith({currentFinalFirmwareId:159,deviceId:17})})}),describe("getNextFirmwareVersion",()=>{it("should call api with the correct parameters",()=>{const e={nextFinalFirmware:159};a.getNextFirmwareVersion(e),expect(t.getFirmwareVersionById).toHaveBeenCalledWith(159)})}),describe("getLanguagePackages",()=>{it("should call api with the correct parameters",()=>{const e={id:17,target_id:"857735172"},r={id:159};a.getLanguagePackages(e,r),expect(t.getLanguagePackages).toHaveBeenCalledWith({deviceId:17,currentFinalFirmwareId:159})})}),describe("getMcuList",()=>{it("should call api with the correct parameters",()=>{a.getMcuList(),expect(t.getMcuList).toHaveBeenCalled()})})});
//# sourceMappingURL=DefaultManagerApiService.test.js.map
