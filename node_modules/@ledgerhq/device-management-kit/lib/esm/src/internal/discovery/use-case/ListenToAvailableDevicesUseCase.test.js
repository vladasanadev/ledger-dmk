import{Just as A}from"purify-ts";import{Subject as f}from"rxjs";import{DeviceModel as b}from"../../../api/device/DeviceModel";import{deviceModelStubBuilder as g}from"../../../api/device-model/model/DeviceModel.stub";import{DefaultLoggerPublisherService as B}from"../../logger-publisher/service/DefaultLoggerPublisherService";import{DefaultTransportService as k}from"../../transport/service/DefaultTransportService";import{ListenToAvailableDevicesUseCase as l}from"./ListenToAvailableDevicesUseCase";vi.mock("@internal/transport/service/DefaultTransportService");let c,p;function D(e){return{listenToAvailableDevices:vi.fn(),connect:vi.fn(),disconnect:vi.fn(),startDiscovering:vi.fn(),stopDiscovering:vi.fn(),getIdentifier:vi.fn(),isSupported:vi.fn(),...e}}const m=g();function n(e){return new b({id:e,model:m.id,name:m.productName})}function u(){const e=new f,t=new f,o=D({listenToAvailableDevices:()=>e.asObservable(),getIdentifier:()=>"mock-A"}),s=D({listenToAvailableDevices:()=>t.asObservable(),getIdentifier:()=>"mock-B"});return{transportAKnownDevicesSubject:e,transportBKnownDevicesSubject:t,transportA:o,transportB:s}}function a(e){return{id:e,deviceModel:m,transport:"mock"}}describe("ListenToAvailableDevicesUseCase",()=>{beforeEach(()=>{vi.clearAllMocks(),c=new k,p=new B([],"listen-to-available-devices-use-case-test")}),describe("when no transports are available",()=>{it("should return no discovered devices",()=>new Promise((e,t)=>{vi.spyOn(c,"getAllTransports").mockReturnValue([]);const o=new l(c,()=>p),s=[];o.execute({}).subscribe({next:r=>{s.push(r)},complete:()=>{try{expect(s).toEqual([[]]),e()}catch(r){t(r)}},error:r=>{t(r)}})}))}),describe("when one transport is available",()=>{it("should return discovered devices from one transport",()=>{const{transportA:e,transportAKnownDevicesSubject:t}=u();vi.spyOn(c,"getAllTransports").mockReturnValue([e]);const o=[];new l(c,()=>p).execute({}).subscribe(s=>{o.push(s)}),t.next([a("transportA-device1")]),expect(o[0]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),name:"Ledger Nano X",transport:"mock",rssi:void 0}]),t.next([a("transportA-device1"),a("transportA-device2")]),expect(o[1]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0},{id:"transportA-device2",deviceModel:n("transportA-device2"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),t.next([a("transportA-device2")]),expect(o[2]).toEqual([{id:"transportA-device2",deviceModel:n("transportA-device2"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),t.next([]),expect(o[3]).toEqual([])})}),describe("when multiple transports are available",()=>{it("should return discovered devices from one of the transports as soon as it emits",()=>{const{transportAKnownDevicesSubject:e,transportA:t,transportB:o}=u();vi.spyOn(c,"getAllTransports").mockReturnValue([t,o]);const s=[],r=vi.fn(),i=vi.fn();new l(c,()=>p).execute({}).subscribe({next:d=>{s.push(d)},error:r,complete:i}),e.next([a("transportA-device1")]),expect(s[0]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),e.complete(),expect(r).not.toHaveBeenCalled(),expect(i).not.toHaveBeenCalled()}),it("should combine discovered devices from multiple transports",()=>{const{transportAKnownDevicesSubject:e,transportBKnownDevicesSubject:t,transportA:o,transportB:s}=u(),r=[];vi.spyOn(c,"getAllTransports").mockReturnValue([o,s]);const i=vi.fn(),d=vi.fn();new l(c,()=>p).execute({}).subscribe({next:v=>{r.push(v)},error:i,complete:d}),e.next([a("transportA-device1")]),expect(r[0]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),t.next([a("transportB-device1")]),expect(r[1]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0},{id:"transportB-device1",deviceModel:n("transportB-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),t.next([a("transportB-device1"),a("transportB-device2")]),expect(r[2]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0},{id:"transportB-device1",deviceModel:n("transportB-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0},{id:"transportB-device2",deviceModel:n("transportB-device2"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),e.next([]),expect(r[3]).toEqual([{id:"transportB-device1",deviceModel:n("transportB-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0},{id:"transportB-device2",deviceModel:n("transportB-device2"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),e.complete(),expect(i).not.toHaveBeenCalled(),expect(d).not.toHaveBeenCalled(),t.next([]),expect(r[4]).toEqual([]),t.complete(),expect(i).not.toHaveBeenCalled(),expect(d).toHaveBeenCalled()}),it("should filter out the devices by transport",()=>{const{transportAKnownDevicesSubject:e,transportBKnownDevicesSubject:t,transportA:o,transportB:s}=u(),r=vi.spyOn(c,"getAllTransports").mockReturnValue([o,s]);vi.spyOn(c,"getTransport").mockReturnValue(A(o));const i=[],d=vi.fn(),v=vi.fn();new l(c,()=>p).execute({transport:"mock-A"}).subscribe({next:x=>{i.push(x)},error:d,complete:v}),expect(r).toBeCalledTimes(1),expect(c.getTransport).toBeCalledWith("mock-A"),e.next([a("transportA-device1")]),expect(i[0]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),t.next([a("transportB-device1")]),expect(i.length).toEqual(1),t.next([a("transportB-device1"),a("transportB-device2")]),expect(i.length).toEqual(1),e.next([]),expect(i[0]).toEqual([{id:"transportA-device1",deviceModel:n("transportA-device1"),transport:"mock",name:"Ledger Nano X",rssi:void 0}]),e.complete(),expect(d).not.toHaveBeenCalled(),expect(v).toHaveBeenCalledOnce(),t.next([]),expect(i[1]).toEqual([]),t.complete(),expect(d).not.toHaveBeenCalled(),expect(v).toHaveBeenCalledOnce()})})});
//# sourceMappingURL=ListenToAvailableDevicesUseCase.test.js.map
