{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/ListenToAvailableDevicesUseCase.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { from, map, merge, Observable, of, scan } from \"rxjs\";\n\nimport { DeviceModel } from \"@api/device/DeviceModel\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { type Transport } from \"@api/transport/model/Transport\";\nimport { type TransportDiscoveredDevice } from \"@api/transport/model/TransportDiscoveredDevice\";\nimport { type TransportIdentifier } from \"@api/transport/model/TransportIdentifier\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\nimport { transportDiTypes } from \"@internal/transport/di/transportDiTypes\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\nexport type ListenToAvailableDevicesUseCaseArgs = {\n  /**\n   * Identifier of the transport to start discovering devices.\n   * Can be undefined to discover all available transports in parallel.\n   */\n  transport?: TransportIdentifier;\n};\n\n/**\n * Listen to list of known discovered devices (and later BLE).\n */\n@injectable()\nexport class ListenToAvailableDevicesUseCase {\n  private readonly _transports: Transport[];\n  private readonly _transportService: TransportService;\n  private readonly _logger: LoggerPublisherService;\n  constructor(\n    @inject(transportDiTypes.TransportService)\n    transportService: TransportService,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    this._transports = transportService.getAllTransports();\n    this._transportService = transportService;\n    this._logger = loggerFactory(\"ListenToAvailableDevicesUseCase\");\n  }\n\n  private mapTransportDiscoveredDeviceToDiscoveredDevice(\n    discoveredDevice: TransportDiscoveredDevice,\n  ): DiscoveredDevice {\n    const deviceModel = new DeviceModel({\n      id: discoveredDevice.id,\n      model: discoveredDevice.deviceModel.id,\n      name: discoveredDevice.deviceModel.productName,\n    });\n    return {\n      id: discoveredDevice.id,\n      deviceModel,\n      transport: discoveredDevice.transport,\n      name: discoveredDevice.name || deviceModel.name,\n      rssi: discoveredDevice.rssi,\n    };\n  }\n\n  execute({ transport }: ListenToAvailableDevicesUseCaseArgs = {}): Observable<\n    DiscoveredDevice[]\n  > {\n    this._logger.info(\"Listening to available devices\");\n\n    if (this._transports.length === 0) {\n      this._logger.warn(\"No transports available\");\n      return from([[]]);\n    }\n\n    if (!transport) {\n      this._logger.info(\"Discovering all available transports\");\n      /**\n       * Note: we're not using combineLatest because combineLatest will\n       * - wait for all observables to emit at least once before emitting.\n       * - complete as soon as one of the observables completes.\n       * Some transports will just return an empty array and complete.\n       * We want to keep listening to all transports until all have completed.\n       */\n\n      const observablesWithIndex = this._transports.map((t, index) =>\n        t.listenToAvailableDevices().pipe(\n          map((arr) => ({\n            index,\n            arr,\n          })),\n        ),\n      );\n\n      return merge(...observablesWithIndex).pipe(\n        scan<\n          { index: number; arr: TransportDiscoveredDevice[] },\n          { [key: number]: TransportDiscoveredDevice[] }\n        >((acc, { index, arr }) => {\n          acc[index] = arr;\n          return acc;\n        }, {}),\n        map((acc) =>\n          Object.values(acc)\n            .flat()\n            .map(this.mapTransportDiscoveredDeviceToDiscoveredDevice),\n        ),\n      );\n    }\n\n    this._logger.info(`Discovering devices on transport ${transport}`);\n\n    const instance = this._transportService.getTransport(transport);\n\n    return instance.caseOf({\n      Nothing: () => {\n        this._logger.error(`Transport ${transport} not found`);\n        return of([]);\n      },\n      Just: (t) => {\n        return t\n          .listenToAvailableDevices()\n          .pipe(\n            map((devices) =>\n              devices.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice),\n            ),\n          );\n      },\n    });\n  }\n}\n"],
  "mappings": "iOAAA,OAAS,UAAAA,EAAQ,cAAAC,MAAkB,YACnC,OAAS,QAAAC,EAAM,OAAAC,EAAK,SAAAC,EAAmB,MAAAC,EAAI,QAAAC,MAAY,OAEvD,OAAS,eAAAC,MAAmB,0BAM5B,OAAS,eAAAC,MAAmB,4CAC5B,OAAS,oBAAAC,MAAwB,0CAe1B,IAAMC,EAAN,KAAsC,CAC1B,YACA,kBACA,QACjB,YAEEC,EAEAC,EACA,CACA,KAAK,YAAcD,EAAiB,iBAAiB,EACrD,KAAK,kBAAoBA,EACzB,KAAK,QAAUC,EAAc,iCAAiC,CAChE,CAEQ,+CACNC,EACkB,CAClB,MAAMC,EAAc,IAAIC,EAAY,CAClC,GAAIF,EAAiB,GACrB,MAAOA,EAAiB,YAAY,GACpC,KAAMA,EAAiB,YAAY,WACrC,CAAC,EACD,MAAO,CACL,GAAIA,EAAiB,GACrB,YAAAC,EACA,UAAWD,EAAiB,UAC5B,KAAMA,EAAiB,MAAQC,EAAY,KAC3C,KAAMD,EAAiB,IACzB,CACF,CAEA,QAAQ,CAAE,UAAAG,CAAU,EAAyC,CAAC,EAE5D,CAGA,GAFA,KAAK,QAAQ,KAAK,gCAAgC,EAE9C,KAAK,YAAY,SAAW,EAC9B,YAAK,QAAQ,KAAK,yBAAyB,EACpCC,EAAK,CAAC,CAAC,CAAC,CAAC,EAGlB,GAAI,CAACD,EAAW,CACd,KAAK,QAAQ,KAAK,sCAAsC,EASxD,MAAME,EAAuB,KAAK,YAAY,IAAI,CAACC,EAAGC,IACpDD,EAAE,yBAAyB,EAAE,KAC3BE,EAAKC,IAAS,CACZ,MAAAF,EACA,IAAAE,CACF,EAAE,CACJ,CACF,EAEA,OAAOC,EAAM,GAAGL,CAAoB,EAAE,KACpCM,EAGE,CAACC,EAAK,CAAE,MAAAL,EAAO,IAAAE,CAAI,KACnBG,EAAIL,CAAK,EAAIE,EACNG,GACN,CAAC,CAAC,EACLJ,EAAKI,GACH,OAAO,OAAOA,CAAG,EACd,KAAK,EACL,IAAI,KAAK,8CAA8C,CAC5D,CACF,CACF,CAEA,YAAK,QAAQ,KAAK,oCAAoCT,CAAS,EAAE,EAEhD,KAAK,kBAAkB,aAAaA,CAAS,EAE9C,OAAO,CACrB,QAAS,KACP,KAAK,QAAQ,MAAM,aAAaA,CAAS,YAAY,EAC9CU,EAAG,CAAC,CAAC,GAEd,KAAOP,GACEA,EACJ,yBAAyB,EACzB,KACCE,EAAKM,GACHA,EAAQ,IAAI,KAAK,8CAA8C,CACjE,CACF,CAEN,CAAC,CACH,CACF,EAjGajB,EAANkB,EAAA,CADNC,EAAW,EAMPC,EAAA,EAAAC,EAAOC,EAAiB,gBAAgB,GAExCF,EAAA,EAAAC,EAAOE,EAAY,6BAA6B,IAPxCvB",
  "names": ["inject", "injectable", "from", "map", "merge", "of", "scan", "DeviceModel", "loggerTypes", "transportDiTypes", "ListenToAvailableDevicesUseCase", "transportService", "loggerFactory", "discoveredDevice", "deviceModel", "DeviceModel", "transport", "from", "observablesWithIndex", "t", "index", "map", "arr", "merge", "scan", "acc", "of", "devices", "__decorateClass", "injectable", "__decorateParam", "inject", "transportDiTypes", "loggerTypes"]
}
