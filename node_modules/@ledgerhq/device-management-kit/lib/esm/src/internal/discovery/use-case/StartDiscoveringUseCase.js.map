{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/StartDiscoveringUseCase.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { map, mergeMap, Observable, of } from \"rxjs\";\n\nimport { DeviceModel } from \"@api/device/DeviceModel\";\nimport { DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { TransportNotSupportedError } from \"@api/transport/model/Errors\";\nimport { TransportDiscoveredDevice } from \"@api/transport/model/TransportDiscoveredDevice\";\nimport { TransportIdentifier } from \"@api/transport/model/TransportIdentifier\";\nimport { transportDiTypes } from \"@internal/transport/di/transportDiTypes\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\nexport type StartDiscoveringUseCaseArgs = {\n  /**\n   * Identifier of the transport to start discovering devices.\n   * Can be undefined to discover all available transports in parralel.\n   */\n  transport?: TransportIdentifier;\n};\n\n/**\n * Starts discovering devices connected.\n *\n * For the WebHID implementation, this use-case needs to be called as a result of an user interaction (button \"click\" event for ex).\n */\n@injectable()\nexport class StartDiscoveringUseCase {\n  constructor(\n    @inject(transportDiTypes.TransportService)\n    private readonly _transportService: TransportService,\n  ) {}\n\n  private mapDiscoveredDevice(\n    device: TransportDiscoveredDevice,\n  ): DiscoveredDevice {\n    const deviceModel = new DeviceModel({\n      id: device.id,\n      model: device.deviceModel.id,\n      name: device.deviceModel.productName,\n    });\n    return {\n      id: device.id,\n      deviceModel,\n      transport: device.transport,\n      name: device.name || deviceModel.name,\n      rssi: device.rssi,\n    };\n  }\n\n  execute({\n    transport,\n  }: StartDiscoveringUseCaseArgs = {}): Observable<DiscoveredDevice> {\n    if (!transport) {\n      const transports = this._transportService.getAllTransports();\n      return of(...transports).pipe(\n        mergeMap((instance) =>\n          instance\n            .startDiscovering()\n            .pipe(map((device) => this.mapDiscoveredDevice(device))),\n        ),\n      );\n    }\n\n    const instance = this._transportService.getTransport(transport);\n\n    return instance.caseOf({\n      Just: (t) => {\n        return t\n          .startDiscovering()\n          .pipe(map((device) => this.mapDiscoveredDevice(device)));\n      },\n      Nothing: () => {\n        throw new TransportNotSupportedError(new Error(\"Unknown transport\"));\n      },\n    });\n  }\n}\n"],
  "mappings": "iOAAA,OAAS,UAAAA,EAAQ,cAAAC,MAAkB,YACnC,OAAS,OAAAC,EAAK,YAAAC,EAAsB,MAAAC,MAAU,OAE9C,OAAS,eAAAC,MAAmB,0BAE5B,OAAS,8BAAAC,MAAkC,8BAG3C,OAAS,oBAAAC,MAAwB,0CAiB1B,IAAMC,EAAN,KAA8B,CACnC,YAEmBC,EACjB,CADiB,uBAAAA,CAChB,CAEK,oBACNC,EACkB,CAClB,MAAMC,EAAc,IAAIC,EAAY,CAClC,GAAIF,EAAO,GACX,MAAOA,EAAO,YAAY,GAC1B,KAAMA,EAAO,YAAY,WAC3B,CAAC,EACD,MAAO,CACL,GAAIA,EAAO,GACX,YAAAC,EACA,UAAWD,EAAO,UAClB,KAAMA,EAAO,MAAQC,EAAY,KACjC,KAAMD,EAAO,IACf,CACF,CAEA,QAAQ,CACN,UAAAG,CACF,EAAiC,CAAC,EAAiC,CACjE,GAAI,CAACA,EAAW,CACd,MAAMC,EAAa,KAAK,kBAAkB,iBAAiB,EAC3D,OAAOC,EAAG,GAAGD,CAAU,EAAE,KACvBE,EAAUC,GACRA,EACG,iBAAiB,EACjB,KAAKC,EAAKR,GAAW,KAAK,oBAAoBA,CAAM,CAAC,CAAC,CAC3D,CACF,CACF,CAIA,OAFiB,KAAK,kBAAkB,aAAaG,CAAS,EAE9C,OAAO,CACrB,KAAO,GACE,EACJ,iBAAiB,EACjB,KAAKK,EAAKR,GAAW,KAAK,oBAAoBA,CAAM,CAAC,CAAC,EAE3D,QAAS,IAAM,CACb,MAAM,IAAIS,EAA2B,IAAI,MAAM,mBAAmB,CAAC,CACrE,CACF,CAAC,CACH,CACF,EAlDaX,EAANY,EAAA,CADNC,EAAW,EAGPC,EAAA,EAAAC,EAAOC,EAAiB,gBAAgB,IAFhChB",
  "names": ["inject", "injectable", "map", "mergeMap", "of", "DeviceModel", "TransportNotSupportedError", "transportDiTypes", "StartDiscoveringUseCase", "_transportService", "device", "deviceModel", "DeviceModel", "transport", "transports", "of", "mergeMap", "instance", "map", "TransportNotSupportedError", "__decorateClass", "injectable", "__decorateParam", "inject", "transportDiTypes"]
}
