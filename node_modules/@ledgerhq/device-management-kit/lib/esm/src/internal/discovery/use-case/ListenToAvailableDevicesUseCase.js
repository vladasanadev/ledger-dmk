var m=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var v=(n,r,t,o)=>{for(var e=o>1?void 0:o?g(r,t):r,i=n.length-1,s;i>=0;i--)(s=n[i])&&(e=(o?s(r,t,e):s(e))||e);return o&&e&&m(r,t,e),e},p=(n,r)=>(t,o)=>r(t,o,n);import{inject as l,injectable as D}from"inversify";import{from as d,map as c,merge as T,of as f,scan as h}from"rxjs";import{DeviceModel as b}from"../../../api/device/DeviceModel";import{loggerTypes as u}from"../../logger-publisher/di/loggerTypes";import{transportDiTypes as _}from"../../transport/di/transportDiTypes";let a=class{_transports;_transportService;_logger;constructor(r,t){this._transports=r.getAllTransports(),this._transportService=r,this._logger=t("ListenToAvailableDevicesUseCase")}mapTransportDiscoveredDeviceToDiscoveredDevice(r){const t=new b({id:r.id,model:r.deviceModel.id,name:r.deviceModel.productName});return{id:r.id,deviceModel:t,transport:r.transport,name:r.name||t.name,rssi:r.rssi}}execute({transport:r}={}){if(this._logger.info("Listening to available devices"),this._transports.length===0)return this._logger.warn("No transports available"),d([[]]);if(!r){this._logger.info("Discovering all available transports");const o=this._transports.map((e,i)=>e.listenToAvailableDevices().pipe(c(s=>({index:i,arr:s}))));return T(...o).pipe(h((e,{index:i,arr:s})=>(e[i]=s,e),{}),c(e=>Object.values(e).flat().map(this.mapTransportDiscoveredDeviceToDiscoveredDevice)))}return this._logger.info(`Discovering devices on transport ${r}`),this._transportService.getTransport(r).caseOf({Nothing:()=>(this._logger.error(`Transport ${r} not found`),f([])),Just:o=>o.listenToAvailableDevices().pipe(c(e=>e.map(this.mapTransportDiscoveredDeviceToDiscoveredDevice)))})}};a=v([D(),p(0,l(_.TransportService)),p(1,l(u.LoggerPublisherServiceFactory))],a);export{a as ListenToAvailableDevicesUseCase};
//# sourceMappingURL=ListenToAvailableDevicesUseCase.js.map
