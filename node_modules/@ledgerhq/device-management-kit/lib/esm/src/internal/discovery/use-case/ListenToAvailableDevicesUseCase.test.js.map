{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/ListenToAvailableDevicesUseCase.test.ts"],
  "sourcesContent": ["import { Just } from \"purify-ts\";\nimport { Subject } from \"rxjs\";\n\nimport { type DeviceId, DeviceModel } from \"@api/device/DeviceModel\";\nimport { deviceModelStubBuilder } from \"@api/device-model/model/DeviceModel.stub\";\nimport { type LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { type DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { type Transport } from \"@api/transport/model/Transport\";\nimport { type TransportDiscoveredDevice } from \"@api/transport/model/TransportDiscoveredDevice\";\nimport { DefaultLoggerPublisherService } from \"@internal/logger-publisher/service/DefaultLoggerPublisherService\";\nimport { DefaultTransportService } from \"@internal/transport/service/DefaultTransportService\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\nimport { ListenToAvailableDevicesUseCase } from \"./ListenToAvailableDevicesUseCase\";\n\nvi.mock(\"@internal/transport/service/DefaultTransportService\");\n\nlet transportService: TransportService;\nlet logger: LoggerPublisherService;\nfunction makeMockTransport(props: Partial<Transport>): Transport {\n  return {\n    listenToAvailableDevices: vi.fn(),\n    connect: vi.fn(),\n    disconnect: vi.fn(),\n    startDiscovering: vi.fn(),\n    stopDiscovering: vi.fn(),\n    getIdentifier: vi.fn(),\n    isSupported: vi.fn(),\n    ...props,\n  };\n}\n\nconst mockInternalDeviceModel = deviceModelStubBuilder();\nfunction makeMockDeviceModel(id: DeviceId): DeviceModel {\n  return new DeviceModel({\n    id,\n    model: mockInternalDeviceModel.id,\n    name: mockInternalDeviceModel.productName,\n  });\n}\n\nfunction setup2MockTransports() {\n  const transportAKnownDevicesSubject = new Subject<\n    TransportDiscoveredDevice[]\n  >();\n  const transportBKnownDevicesSubject = new Subject<\n    TransportDiscoveredDevice[]\n  >();\n  const transportA = makeMockTransport({\n    listenToAvailableDevices: () =>\n      transportAKnownDevicesSubject.asObservable(),\n    getIdentifier: () => \"mock-A\",\n  });\n  const transportB = makeMockTransport({\n    listenToAvailableDevices: () =>\n      transportBKnownDevicesSubject.asObservable(),\n    getIdentifier: () => \"mock-B\",\n  });\n  return {\n    transportAKnownDevicesSubject,\n    transportBKnownDevicesSubject,\n    transportA,\n    transportB,\n  };\n}\n\nfunction makeMockTransportDiscoveredDevice(\n  id: string,\n): TransportDiscoveredDevice {\n  return {\n    id,\n    deviceModel: mockInternalDeviceModel,\n    transport: \"mock\",\n  };\n}\n\ndescribe(\"ListenToAvailableDevicesUseCase\", () => {\n  beforeEach(() => {\n    vi.clearAllMocks();\n    // @ts-expect-error mock\n    transportService = new DefaultTransportService();\n    logger = new DefaultLoggerPublisherService(\n      [],\n      \"listen-to-available-devices-use-case-test\",\n    );\n  });\n\n  describe(\"when no transports are available\", () => {\n    it(\"should return no discovered devices\", () =>\n      new Promise<void>((resolve, reject) => {\n        vi.spyOn(transportService, \"getAllTransports\").mockReturnValue([]);\n\n        const useCase = new ListenToAvailableDevicesUseCase(\n          transportService,\n          () => logger,\n        );\n\n        const observedDiscoveredDevices: DiscoveredDevice[][] = [];\n        useCase.execute({}).subscribe({\n          next: (devices) => {\n            observedDiscoveredDevices.push(devices);\n          },\n          complete: () => {\n            try {\n              expect(observedDiscoveredDevices).toEqual([[]]);\n              resolve();\n            } catch (error) {\n              reject(error as Error);\n            }\n          },\n          error: (error) => {\n            reject(error);\n          },\n        });\n      }));\n  });\n\n  describe(\"when one transport is available\", () => {\n    it(\"should return discovered devices from one transport\", () => {\n      const { transportA, transportAKnownDevicesSubject } =\n        setup2MockTransports();\n\n      vi.spyOn(transportService, \"getAllTransports\").mockReturnValue([\n        transportA,\n      ]);\n\n      const observedDiscoveredDevices: DiscoveredDevice[][] = [];\n      new ListenToAvailableDevicesUseCase(transportService, () => logger)\n        .execute({})\n        .subscribe((devices) => {\n          observedDiscoveredDevices.push(devices);\n        });\n\n      // When transportA emits 1 known device\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices[0]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          name: \"Ledger Nano X\",\n          transport: \"mock\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportA emits 2 known devices\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device1\"),\n        makeMockTransportDiscoveredDevice(\"transportA-device2\"),\n      ]);\n\n      expect(observedDiscoveredDevices[1]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n        {\n          id: \"transportA-device2\",\n          deviceModel: makeMockDeviceModel(\"transportA-device2\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportA emits 1 known device (device1 disconnects)\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device2\"),\n      ]);\n\n      expect(observedDiscoveredDevices[2]).toEqual([\n        {\n          id: \"transportA-device2\",\n          deviceModel: makeMockDeviceModel(\"transportA-device2\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportA emits 0 known devices (device2 disconnects)\n      transportAKnownDevicesSubject.next([]);\n\n      expect(observedDiscoveredDevices[3]).toEqual([]);\n    });\n  });\n\n  describe(\"when multiple transports are available\", () => {\n    it(\"should return discovered devices from one of the transports as soon as it emits\", () => {\n      const { transportAKnownDevicesSubject, transportA, transportB } =\n        setup2MockTransports();\n\n      vi.spyOn(transportService, \"getAllTransports\").mockReturnValue([\n        transportA,\n        transportB,\n      ]);\n\n      const observedDiscoveredDevices: DiscoveredDevice[][] = [];\n\n      const onError = vi.fn();\n      const onComplete = vi.fn();\n\n      new ListenToAvailableDevicesUseCase(transportService, () => logger)\n        .execute({})\n        .subscribe({\n          next: (devices) => {\n            observedDiscoveredDevices.push(devices);\n          },\n          error: onError,\n          complete: onComplete,\n        });\n\n      // When transportA emits 1 known device\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices[0]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transport A listen observable completes\n      transportAKnownDevicesSubject.complete();\n\n      expect(onError).not.toHaveBeenCalled();\n      expect(onComplete).not.toHaveBeenCalled(); // Should not complete yet because transportB has not completed\n    });\n\n    it(\"should combine discovered devices from multiple transports\", () => {\n      const {\n        transportAKnownDevicesSubject,\n        transportBKnownDevicesSubject,\n        transportA,\n        transportB,\n      } = setup2MockTransports();\n\n      const observedDiscoveredDevices: DiscoveredDevice[][] = [];\n\n      vi.spyOn(transportService, \"getAllTransports\").mockReturnValue([\n        transportA,\n        transportB,\n      ]);\n\n      const onError = vi.fn();\n      const onComplete = vi.fn();\n      new ListenToAvailableDevicesUseCase(transportService, () => logger)\n        .execute({})\n        .subscribe({\n          next: (devices) => {\n            observedDiscoveredDevices.push(devices);\n          },\n          error: onError,\n          complete: onComplete,\n        });\n\n      // When transportA emits 1 known device\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices[0]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportB emits 1 known device\n      transportBKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportB-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices[1]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n        {\n          id: \"transportB-device1\",\n          deviceModel: makeMockDeviceModel(\"transportB-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportB emits 2 known devices\n      transportBKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportB-device1\"),\n        makeMockTransportDiscoveredDevice(\"transportB-device2\"),\n      ]);\n\n      expect(observedDiscoveredDevices[2]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n        {\n          id: \"transportB-device1\",\n          deviceModel: makeMockDeviceModel(\"transportB-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n        {\n          id: \"transportB-device2\",\n          deviceModel: makeMockDeviceModel(\"transportB-device2\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportA emits 0 known devices\n      transportAKnownDevicesSubject.next([]);\n\n      expect(observedDiscoveredDevices[3]).toEqual([\n        {\n          id: \"transportB-device1\",\n          deviceModel: makeMockDeviceModel(\"transportB-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n        {\n          id: \"transportB-device2\",\n          deviceModel: makeMockDeviceModel(\"transportB-device2\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transport A listen observable completes\n      transportAKnownDevicesSubject.complete();\n\n      expect(onError).not.toHaveBeenCalled();\n      expect(onComplete).not.toHaveBeenCalled(); // Should not complete yet because transportB has not completed\n\n      // When transport B emits 0 known devices\n      transportBKnownDevicesSubject.next([]);\n\n      expect(observedDiscoveredDevices[4]).toEqual([]);\n\n      // When transport B listen observable completes\n      transportBKnownDevicesSubject.complete();\n\n      expect(onError).not.toHaveBeenCalled();\n      expect(onComplete).toHaveBeenCalled(); // Should complete now because all transports have completed\n    });\n\n    it(\"should filter out the devices by transport\", () => {\n      const {\n        transportAKnownDevicesSubject,\n        transportBKnownDevicesSubject,\n        transportA,\n        transportB,\n      } = setup2MockTransports();\n\n      const all = vi\n        .spyOn(transportService, \"getAllTransports\")\n        .mockReturnValue([transportA, transportB]);\n\n      vi.spyOn(transportService, \"getTransport\").mockReturnValue(\n        Just(transportA),\n      );\n\n      const observedDiscoveredDevices: DiscoveredDevice[][] = [];\n\n      const onError = vi.fn();\n      const onComplete = vi.fn();\n\n      new ListenToAvailableDevicesUseCase(transportService, () => logger)\n        .execute({ transport: \"mock-A\" })\n        .subscribe({\n          next: (devices) => {\n            observedDiscoveredDevices.push(devices);\n          },\n          error: onError,\n          complete: onComplete,\n        });\n\n      expect(all).toBeCalledTimes(1);\n      expect(transportService.getTransport).toBeCalledWith(\"mock-A\");\n\n      // When transportA emits 1 known device\n      transportAKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportA-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices[0]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // When transportB emits 1 known device\n      transportBKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportB-device1\"),\n      ]);\n\n      expect(observedDiscoveredDevices.length).toEqual(1);\n\n      // When transportB emits 2 known devices\n      transportBKnownDevicesSubject.next([\n        makeMockTransportDiscoveredDevice(\"transportB-device1\"),\n        makeMockTransportDiscoveredDevice(\"transportB-device2\"),\n      ]);\n\n      // Only transportA is listened to, so only transportA devices should be returned\n      expect(observedDiscoveredDevices.length).toEqual(1);\n\n      // // When transportA emits 0 known devices\n      transportAKnownDevicesSubject.next([]);\n\n      expect(observedDiscoveredDevices[0]).toEqual([\n        {\n          id: \"transportA-device1\",\n          deviceModel: makeMockDeviceModel(\"transportA-device1\"),\n          transport: \"mock\",\n          name: \"Ledger Nano X\",\n          rssi: undefined,\n        },\n      ]);\n\n      // // When transport A listen observable completes\n      transportAKnownDevicesSubject.complete();\n\n      expect(onError).not.toHaveBeenCalled();\n      expect(onComplete).toHaveBeenCalledOnce(); // Should complete now because transportA has completed\n\n      // When transport B emits 0 known devices\n      transportBKnownDevicesSubject.next([]);\n\n      expect(observedDiscoveredDevices[1]).toEqual([]);\n\n      // When transport B listen observable completes\n      transportBKnownDevicesSubject.complete();\n\n      expect(onError).not.toHaveBeenCalled();\n      expect(onComplete).toHaveBeenCalledOnce(); // Should not rerun complete because transportB is not listened to\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["Just", "Subject", "DeviceModel", "deviceModelStubBuilder", "DefaultLoggerPublisherService", "DefaultTransportService", "ListenToAvailableDevicesUseCase", "transportService", "logger", "makeMockTransport", "props", "mockInternalDeviceModel", "makeMockDeviceModel", "id", "setup2MockTransports", "transportAKnownDevicesSubject", "transportBKnownDevicesSubject", "transportA", "transportB", "makeMockTransportDiscoveredDevice", "resolve", "reject", "useCase", "observedDiscoveredDevices", "devices", "error", "onError", "onComplete", "all"]
}
