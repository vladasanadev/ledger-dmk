var S=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=(s,r,e,i)=>{for(var o=i>1?void 0:i?g(r,e):r,t=s.length-1,n;t>=0;t--)(n=s[t])&&(o=(i?n(r,e,o):n(o))||o);return i&&o&&S(r,e,o),o},c=(s,r)=>(e,i)=>r(e,i,s);import{inject as a,injectable as m}from"inversify";import{EitherAsync as d}from"purify-ts";import{TransportNotSupportedError as f}from"../../../api/transport/model/Errors";import{deviceSessionTypes as h}from"../../device-session/di/deviceSessionTypes";import{loggerTypes as l}from"../../logger-publisher/di/loggerTypes";import{transportDiTypes as y}from"../../transport/di/transportDiTypes";let v=class{_transportService;_sessionService;_logger;constructor(r,e,i){this._sessionService=e,this._transportService=r,this._logger=i("DisconnectUseCase")}async execute({sessionId:r}){return this._logger.debug("Disconnecting from device",{data:{test:this._sessionService.getDeviceSessions().map(e=>e.id)}}),d(async({liftEither:e})=>{const i=await e(this._sessionService.getDeviceSessionById(r).ifLeft(n=>{this._logger.error("Device session not found",{data:{sessionId:r,error:n}})})),o=i.connectedDevice.transport,t=await e(this._transportService.getTransport(o).toEither(new f(new Error("Unknown transport"))));i.close(),this._sessionService.removeDeviceSession(r),await t.disconnect({connectedDevice:i.connectedDevice})}).caseOf({Left:e=>{throw this._logger.error("Error disconnecting from device",{data:{error:e}}),e},Right:()=>{}})}};v=p([m(),c(0,a(y.TransportService)),c(1,a(h.DeviceSessionService)),c(2,a(l.LoggerPublisherServiceFactory))],v);export{v as DisconnectUseCase};
//# sourceMappingURL=DisconnectUseCase.js.map
