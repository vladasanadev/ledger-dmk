import{Left as k,Maybe as m,Right as S}from"purify-ts";import{TransportMock as C}from"../../../api/transport/model/__mocks__/TransportMock";import{UnknownDeviceError as f}from"../../../api/transport/model/Errors";import{connectedDeviceStubBuilder as w}from"../../../api/transport/model/TransportConnectedDevice.stub";import{DefaultDeviceSessionService as I}from"../../device-session/service/DefaultDeviceSessionService";import{DefaultLoggerPublisherService as M}from"../../logger-publisher/service/DefaultLoggerPublisherService";import{AxiosManagerApiDataSource as T}from"../../manager-api/data/AxiosManagerApiDataSource";import{DefaultManagerApiService as h}from"../../manager-api/service/DefaultManagerApiService";import{DefaultSecureChannelDataSource as A}from"../../secure-channel/data/DefaultSecureChannelDataSource";import{DefaultSecureChannelService as b}from"../../secure-channel/service/DefaultSecureChannelService";import{DefaultTransportService as O}from"../../transport/service/DefaultTransportService";import{ConnectUseCase as p}from"./ConnectUseCase";vi.mock("uuid",()=>({v4:vi.fn().mockReturnValue("fakeSessionId")}));vi.mock("@internal/manager-api/data/AxiosManagerApiDataSource");vi.mock("@internal/transport/service/DefaultTransportService");let o,n,i,e,s,l,d,c;const x="fakeSessionId",D="fakeSessionIdConnectedDevice";describe("ConnectUseCase",()=>{const v={id:"",deviceModel:{},transport:"USB",name:"TEST"},u=w({id:"1"}),g={id:"1",sessionId:D,modelId:"model-id",name:"device-name",type:"MOCK",transport:"USB"},y="logger-tag";beforeAll(()=>{i=new M([],y),o=new C,e=new I(()=>i),l=new T({}),s=new h(l),d=new A({}),c=new b(d),n=new O}),afterEach(()=>{for(const t of e.getDeviceSessions())e.removeDeviceSession(t.id)}),afterAll(()=>{vi.restoreAllMocks()}),test("If connect use case encounter an error, return it",async()=>{vi.spyOn(o,"connect").mockResolvedValue(k(new f)),vi.spyOn(n,"getTransport").mockReturnValue(m.of(o));const t=new p(n,e,()=>i,s,c);await expect(t.execute({device:v})).rejects.toBeInstanceOf(f)}),test("If connect is in success, return a deviceSession id",async()=>{vi.spyOn(o,"connect").mockResolvedValue(S(u)),vi.spyOn(n,"getTransport").mockReturnValue(m.of(o)),vi.spyOn(e,"addDeviceSession").mockImplementation(a=>(a.setDeviceSessionState({}),e));const r=await new p(n,e,()=>i,s,c).execute({device:v});expect(r).toBe(x),e.removeDeviceSession(r)}),test("If connect is in success after a reconnect, return the same deviceSession id",async()=>{vi.spyOn(o,"connect").mockResolvedValue(S(u)),vi.spyOn(n,"getTransport").mockReturnValue(m.of(o)),vi.spyOn(e,"addDeviceSession").mockImplementation(a=>(a.setDeviceSessionState({}),e));const r=await new p(n,e,()=>i,s,c).execute({device:g});expect(r).toBe(D),e.removeDeviceSession(r)})});
//# sourceMappingURL=ConnectUseCase.test.js.map
