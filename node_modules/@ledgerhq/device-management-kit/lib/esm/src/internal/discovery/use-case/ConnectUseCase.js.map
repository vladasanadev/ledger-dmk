{
  "version": 3,
  "sources": ["../../../../../../src/internal/discovery/use-case/ConnectUseCase.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { EitherAsync } from \"purify-ts\";\n\nimport { DeviceSessionId } from \"@api/device-session/types\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { ConnectedDevice } from \"@api/transport/model/ConnectedDevice\";\nimport { DiscoveredDevice } from \"@api/transport/model/DiscoveredDevice\";\nimport { TransportNotSupportedError } from \"@api/transport/model/Errors\";\nimport { DeviceId } from \"@api/types\";\nimport { deviceSessionTypes } from \"@internal/device-session/di/deviceSessionTypes\";\nimport {\n  DeviceSession,\n  DeviceSessionRefresherOptions,\n} from \"@internal/device-session/model/DeviceSession\";\nimport type { DeviceSessionService } from \"@internal/device-session/service/DeviceSessionService\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\nimport { managerApiTypes } from \"@internal/manager-api/di/managerApiTypes\";\nimport type { ManagerApiService } from \"@internal/manager-api/service/ManagerApiService\";\nimport { secureChannelTypes } from \"@internal/secure-channel/di/secureChannelTypes\";\nimport type { SecureChannelService } from \"@internal/secure-channel/service/SecureChannelService\";\nimport { transportDiTypes } from \"@internal/transport/di/transportDiTypes\";\nimport { type TransportService } from \"@internal/transport/service/TransportService\";\n\n/**\n * The arguments for the ConnectUseCase.\n */\nexport type ConnectUseCaseArgs = {\n  /**\n   * Discovered device or connected device.\n   */\n  device: DiscoveredDevice | ConnectedDevice;\n\n  /**\n   * sessionRefresherOptions - optional\n   * isRefresherDisabled - whether the refresher is disabled\n   * pollingInterval - optional - the refresh interval in milliseconds\n   */\n  sessionRefresherOptions?: DeviceSessionRefresherOptions;\n};\n\n/**\n * Connects to a discovered device.\n */\n@injectable()\nexport class ConnectUseCase {\n  private readonly _transportService: TransportService;\n  private readonly _sessionService: DeviceSessionService;\n  private readonly _loggerFactory: (tag: string) => LoggerPublisherService;\n  private readonly _managerApi: ManagerApiService;\n  private readonly _secureChannel: SecureChannelService;\n  private readonly _logger: LoggerPublisherService;\n\n  constructor(\n    @inject(transportDiTypes.TransportService)\n    transportService: TransportService,\n    @inject(deviceSessionTypes.DeviceSessionService)\n    sessionService: DeviceSessionService,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerFactory: (tag: string) => LoggerPublisherService,\n    @inject(managerApiTypes.ManagerApiService)\n    managerApi: ManagerApiService,\n    @inject(secureChannelTypes.SecureChannelService)\n    secureChannel: SecureChannelService,\n  ) {\n    this._sessionService = sessionService;\n    this._transportService = transportService;\n    this._loggerFactory = loggerFactory;\n    this._logger = loggerFactory(\"ConnectUseCase\");\n    this._managerApi = managerApi;\n    this._secureChannel = secureChannel;\n  }\n\n  private handleDeviceDisconnect(deviceId: DeviceId) {\n    this._sessionService\n      .getDeviceSessionsByDeviceId(deviceId)\n      .ifRight((deviceSessions) => {\n        deviceSessions.forEach((deviceSession) => {\n          this._sessionService.removeDeviceSession(deviceSession.id);\n          this._logger.info(\"Session removed\", {\n            data: { deviceId, sessionId: deviceSession.id },\n          });\n        });\n      });\n  }\n\n  async execute({\n    device,\n    sessionRefresherOptions,\n  }: ConnectUseCaseArgs): Promise<DeviceSessionId> {\n    const transport = this._transportService.getTransport(device.transport);\n    // In case of a connected device, we reconnect using the same session id.\n    // If not provided, a new device session id will be generated.\n    const deviceSessionId =\n      \"sessionId\" in device ? device.sessionId : undefined;\n\n    return EitherAsync.liftEither(\n      transport.toEither(\n        new TransportNotSupportedError(new Error(\"Unknown transport\")),\n      ),\n    )\n      .chain(async (t) => {\n        return t.connect({\n          deviceId: device.id,\n          onDisconnect: (dId) => this.handleDeviceDisconnect(dId),\n        });\n      })\n      .ifLeft((error) => {\n        this._logger.error(\"Error connecting to device\", {\n          data: { deviceId: device.id, error },\n        });\n      })\n      .map(async (connectedDevice) => {\n        const deviceSession = new DeviceSession(\n          { connectedDevice, id: deviceSessionId },\n          this._loggerFactory,\n          this._managerApi,\n          this._secureChannel,\n          sessionRefresherOptions,\n        );\n        this._sessionService.addDeviceSession(deviceSession);\n        await deviceSession.initialiseSession();\n        return deviceSession.id;\n      })\n      .caseOf({\n        Left: (error) => {\n          throw error;\n        },\n        Right: (s) => s,\n      });\n  }\n}\n"],
  "mappings": "iOAAA,OAAS,UAAAA,EAAQ,cAAAC,MAAkB,YACnC,OAAS,eAAAC,MAAmB,YAM5B,OAAS,8BAAAC,MAAkC,8BAE3C,OAAS,sBAAAC,MAA0B,iDACnC,OACE,iBAAAC,MAEK,+CAEP,OAAS,eAAAC,MAAmB,4CAC5B,OAAS,mBAAAC,MAAuB,2CAEhC,OAAS,sBAAAC,MAA0B,iDAEnC,OAAS,oBAAAC,MAAwB,0CAwB1B,IAAMC,EAAN,KAAqB,CACT,kBACA,gBACA,eACA,YACA,eACA,QAEjB,YAEEC,EAEAC,EAEAC,EAEAC,EAEAC,EACA,CACA,KAAK,gBAAkBH,EACvB,KAAK,kBAAoBD,EACzB,KAAK,eAAiBE,EACtB,KAAK,QAAUA,EAAc,gBAAgB,EAC7C,KAAK,YAAcC,EACnB,KAAK,eAAiBC,CACxB,CAEQ,uBAAuBC,EAAoB,CACjD,KAAK,gBACF,4BAA4BA,CAAQ,EACpC,QAASC,GAAmB,CAC3BA,EAAe,QAASC,GAAkB,CACxC,KAAK,gBAAgB,oBAAoBA,EAAc,EAAE,EACzD,KAAK,QAAQ,KAAK,kBAAmB,CACnC,KAAM,CAAE,SAAAF,EAAU,UAAWE,EAAc,EAAG,CAChD,CAAC,CACH,CAAC,CACH,CAAC,CACL,CAEA,MAAM,QAAQ,CACZ,OAAAC,EACA,wBAAAC,CACF,EAAiD,CAC/C,MAAMC,EAAY,KAAK,kBAAkB,aAAaF,EAAO,SAAS,EAGhEG,EACJ,cAAeH,EAASA,EAAO,UAAY,OAE7C,OAAOI,EAAY,WACjBF,EAAU,SACR,IAAIG,EAA2B,IAAI,MAAM,mBAAmB,CAAC,CAC/D,CACF,EACG,MAAM,MAAOC,GACLA,EAAE,QAAQ,CACf,SAAUN,EAAO,GACjB,aAAeO,GAAQ,KAAK,uBAAuBA,CAAG,CACxD,CAAC,CACF,EACA,OAAQC,GAAU,CACjB,KAAK,QAAQ,MAAM,6BAA8B,CAC/C,KAAM,CAAE,SAAUR,EAAO,GAAI,MAAAQ,CAAM,CACrC,CAAC,CACH,CAAC,EACA,IAAI,MAAOC,GAAoB,CAC9B,MAAMV,EAAgB,IAAIW,EACxB,CAAE,gBAAAD,EAAiB,GAAIN,CAAgB,EACvC,KAAK,eACL,KAAK,YACL,KAAK,eACLF,CACF,EACA,YAAK,gBAAgB,iBAAiBF,CAAa,EACnD,MAAMA,EAAc,kBAAkB,EAC/BA,EAAc,EACvB,CAAC,EACA,OAAO,CACN,KAAOS,GAAU,CACf,MAAMA,CACR,EACA,MAAQG,GAAMA,CAChB,CAAC,CACL,CACF,EAtFapB,EAANqB,EAAA,CADNC,EAAW,EAUPC,EAAA,EAAAC,EAAOC,EAAiB,gBAAgB,GAExCF,EAAA,EAAAC,EAAOE,EAAmB,oBAAoB,GAE9CH,EAAA,EAAAC,EAAOG,EAAY,6BAA6B,GAEhDJ,EAAA,EAAAC,EAAOI,EAAgB,iBAAiB,GAExCL,EAAA,EAAAC,EAAOK,EAAmB,oBAAoB,IAjBtC7B",
  "names": ["inject", "injectable", "EitherAsync", "TransportNotSupportedError", "deviceSessionTypes", "DeviceSession", "loggerTypes", "managerApiTypes", "secureChannelTypes", "transportDiTypes", "ConnectUseCase", "transportService", "sessionService", "loggerFactory", "managerApi", "secureChannel", "deviceId", "deviceSessions", "deviceSession", "device", "sessionRefresherOptions", "transport", "deviceSessionId", "EitherAsync", "TransportNotSupportedError", "t", "dId", "error", "connectedDevice", "DeviceSession", "s", "__decorateClass", "injectable", "__decorateParam", "inject", "transportDiTypes", "deviceSessionTypes", "loggerTypes", "managerApiTypes", "secureChannelTypes"]
}
