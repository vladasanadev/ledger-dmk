{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DevicePinger.ts"],
  "sourcesContent": ["import { type Subscription } from \"rxjs\";\n\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport {\n  GetAppAndVersionCommand,\n  type GetAppAndVersionResponse,\n  GetOsVersionCommand,\n  type TransportConnectedDevice,\n} from \"@api/index\";\nimport {\n  type Command,\n  type CommandResult,\n  type LoggerPublisherService,\n} from \"@api/types\";\nimport { PINGER_TIMEOUT } from \"@internal/device-session/data/ApduResponseConst\";\nimport { DEVICE_SESSION_REFRESHER_POLLING_INTERVAL } from \"@internal/device-session/data/DeviceSessionRefresherConst\";\nimport {\n  type DeviceSessionEventDispatcher,\n  type NewEvent,\n  SessionEvents,\n} from \"@internal/device-session/model/DeviceSessionEventDispatcher\";\n\ntype SendCommandFunction = <Response, Args, ErrorStatusCodes>(\n  command: Command<Response, Args, ErrorStatusCodes>,\n  abortTimeout?: number,\n) => Promise<CommandResult<Response, ErrorStatusCodes>>;\n\nexport class DevicePinger {\n  private readonly _sendCommandFunction: SendCommandFunction;\n  private _subscription: Subscription;\n  private _logger: LoggerPublisherService;\n\n  constructor(\n    loggerModuleFactory: (tag: string) => LoggerPublisherService,\n    private connectedDevice: TransportConnectedDevice,\n    private _sessionEventDispatcher: DeviceSessionEventDispatcher,\n    sendCommandFunction: SendCommandFunction,\n  ) {\n    this._sendCommandFunction = sendCommandFunction;\n    this._logger = loggerModuleFactory(\"device-pinger\");\n    this._subscription = this._sessionEventDispatcher\n      .listen()\n      .subscribe(async (event) => await this.mapEventAction(event));\n  }\n\n  public async ping(): Promise<CommandResult<GetAppAndVersionResponse> | null> {\n    try {\n      const result = await this.mapDevicePingAction(\n        this.connectedDevice.deviceModel.id,\n      );\n      return result;\n    } catch (error) {\n      this._logger.error(\"Error while pinging device\", {\n        data: {\n          error,\n        },\n      });\n      throw error;\n    }\n  }\n\n  private mapEventAction = async (event: NewEvent) => {\n    switch (event.eventName) {\n      case SessionEvents.REFRESH_NEEDED:\n        return await this.ping();\n      default:\n        return null;\n    }\n  };\n\n  private async mapDevicePingAction(deviceModelId: DeviceModelId) {\n    switch (deviceModelId) {\n      case DeviceModelId.NANO_S: {\n        const chainPromise: () => Promise<\n          CommandResult<GetAppAndVersionResponse>\n        > = async () => {\n          const appVersionResult = await this._sendCommandFunction(\n            new GetAppAndVersionCommand(),\n            PINGER_TIMEOUT,\n          );\n\n          this._sendCommandFunction(new GetOsVersionCommand(), PINGER_TIMEOUT);\n          return appVersionResult;\n        };\n\n        const timeoutPromise: Promise<null> = new Promise((resolve) => {\n          setTimeout(\n            () => resolve(null),\n            DEVICE_SESSION_REFRESHER_POLLING_INTERVAL * 2 + 100,\n          );\n        });\n\n        const resultOrTimeout: CommandResult<GetAppAndVersionResponse> | null =\n          await Promise.race([chainPromise(), timeoutPromise]);\n\n        if (!resultOrTimeout) {\n          this._sessionEventDispatcher.dispatch({\n            eventName: SessionEvents.DEVICE_STATE_UPDATE_LOCKED,\n          });\n        } else {\n          this._sessionEventDispatcher.dispatch({\n            eventName: SessionEvents.COMMAND_SUCCEEDED,\n            eventData: resultOrTimeout,\n          });\n        }\n        return resultOrTimeout;\n      }\n      default: {\n        const result = await this._sendCommandFunction(\n          new GetAppAndVersionCommand(),\n          PINGER_TIMEOUT,\n        );\n        this._sessionEventDispatcher.dispatch({\n          eventName: SessionEvents.COMMAND_SUCCEEDED,\n          eventData: result,\n        });\n        return result;\n      }\n    }\n  }\n\n  public unsubscribe(): void {\n    this._subscription.unsubscribe();\n  }\n}\n"],
  "mappings": "AAEA,OAAS,iBAAAA,MAAqB,0BAC9B,OACE,2BAAAC,EAEA,uBAAAC,MAEK,aAMP,OAAS,kBAAAC,MAAsB,kDAC/B,OAAS,6CAAAC,MAAiD,4DAC1D,OAGE,iBAAAC,MACK,8DAOA,MAAMC,CAAa,CAKxB,YACEC,EACQC,EACAC,EACRC,EACA,CAHQ,qBAAAF,EACA,6BAAAC,EAGR,KAAK,qBAAuBC,EAC5B,KAAK,QAAUH,EAAoB,eAAe,EAClD,KAAK,cAAgB,KAAK,wBACvB,OAAO,EACP,UAAU,MAAOI,GAAU,MAAM,KAAK,eAAeA,CAAK,CAAC,CAChE,CAfiB,qBACT,cACA,QAeR,MAAa,MAAgE,CAC3E,GAAI,CAIF,OAHe,MAAM,KAAK,oBACxB,KAAK,gBAAgB,YAAY,EACnC,CAEF,OAASC,EAAO,CACd,WAAK,QAAQ,MAAM,6BAA8B,CAC/C,KAAM,CACJ,MAAAA,CACF,CACF,CAAC,EACKA,CACR,CACF,CAEQ,eAAiB,MAAOD,GAAoB,CAClD,OAAQA,EAAM,UAAW,CACvB,KAAKN,EAAc,eACjB,OAAO,MAAM,KAAK,KAAK,EACzB,QACE,OAAO,IACX,CACF,EAEA,MAAc,oBAAoBQ,EAA8B,CAC9D,OAAQA,EAAe,CACrB,KAAKb,EAAc,OAAQ,CACzB,MAAMc,EAEF,SAAY,CACd,MAAMC,EAAmB,MAAM,KAAK,qBAClC,IAAId,EACJE,CACF,EAEA,YAAK,qBAAqB,IAAID,EAAuBC,CAAc,EAC5DY,CACT,EAEMC,EAAgC,IAAI,QAASC,GAAY,CAC7D,WACE,IAAMA,EAAQ,IAAI,EAClBb,EAA4C,EAAI,GAClD,CACF,CAAC,EAEKc,EACJ,MAAM,QAAQ,KAAK,CAACJ,EAAa,EAAGE,CAAc,CAAC,EAErD,OAAKE,EAKH,KAAK,wBAAwB,SAAS,CACpC,UAAWb,EAAc,kBACzB,UAAWa,CACb,CAAC,EAPD,KAAK,wBAAwB,SAAS,CACpC,UAAWb,EAAc,0BAC3B,CAAC,EAOIa,CACT,CACA,QAAS,CACP,MAAMC,EAAS,MAAM,KAAK,qBACxB,IAAIlB,EACJE,CACF,EACA,YAAK,wBAAwB,SAAS,CACpC,UAAWE,EAAc,kBACzB,UAAWc,CACb,CAAC,EACMA,CACT,CACF,CACF,CAEO,aAAoB,CACzB,KAAK,cAAc,YAAY,CACjC,CACF",
  "names": ["DeviceModelId", "GetAppAndVersionCommand", "GetOsVersionCommand", "PINGER_TIMEOUT", "DEVICE_SESSION_REFRESHER_POLLING_INTERVAL", "SessionEvents", "DevicePinger", "loggerModuleFactory", "connectedDevice", "_sessionEventDispatcher", "sendCommandFunction", "event", "error", "deviceModelId", "chainPromise", "appVersionResult", "timeoutPromise", "resolve", "resultOrTimeout", "result"]
}
