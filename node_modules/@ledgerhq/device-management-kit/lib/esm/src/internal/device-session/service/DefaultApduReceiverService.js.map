{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/service/DefaultApduReceiverService.ts"],
  "sourcesContent": ["import { inject, injectable } from \"inversify\";\nimport { Either, Just, Left, Maybe, Nothing, Right } from \"purify-ts\";\nimport { v4 } from \"uuid\";\n\nimport { ApduResponse } from \"@api/device-session/ApduResponse\";\nimport {\n  APDU_DATA_LENGTH_LENGTH,\n  CHANNEL_LENGTH,\n  HEAD_TAG_LENGTH,\n  INDEX_LENGTH,\n} from \"@api/device-session/data/FramerConst\";\nimport {\n  type ApduReceiverConstructorArgs,\n  ApduReceiverService,\n} from \"@api/device-session/service/ApduReceiverService\";\nimport { FramerUtils } from \"@api/device-session/utils/FramerUtils\";\nimport { LoggerPublisherService } from \"@api/logger-publisher/service/LoggerPublisherService\";\nimport { APDU_RESPONSE_STATUS_CODE_LENGTH } from \"@internal/device-session/data/ApduResponseConst\";\nimport { ReceiverApduError } from \"@internal/device-session/model/Errors\";\nimport { Frame } from \"@internal/device-session/model/Frame\";\nimport { FrameHeader } from \"@internal/device-session/model/FrameHeader\";\nimport { loggerTypes } from \"@internal/logger-publisher/di/loggerTypes\";\n\n@injectable()\nexport class DefaultApduReceiverService implements ApduReceiverService {\n  private readonly _channel: Maybe<Uint8Array>;\n  private readonly _logger: LoggerPublisherService;\n  private _pendingFrames: Frame[];\n\n  constructor(\n    { channel = Maybe.zero() }: ApduReceiverConstructorArgs,\n    @inject(loggerTypes.LoggerPublisherServiceFactory)\n    loggerModuleFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    this._channel = channel;\n    this._logger = loggerModuleFactory(\"ApduReceiverService\");\n    this._pendingFrames = [];\n  }\n\n  /*\n   * Return\n   * - A complete ApduResponse\n   * - Or a Nothing if not all the data has been received\n   * - Or a ReceiverApduError if the apdu is not formatted correctly\n   *\n   * @param Uint8Array\n   */\n  public handleFrame(\n    frameBytes: Uint8Array,\n  ): Either<ReceiverApduError, Maybe<ApduResponse>> {\n    const frame = this.getFrameFromBytes(frameBytes);\n\n    return frame.map((value) => {\n      this._pendingFrames.push(value);\n      if (!this._pendingFrames[0]) {\n        return Nothing;\n      }\n      const dataSize = this._pendingFrames[0].getHeader().getDataLength();\n      return this.getCompleteFrame(dataSize);\n    });\n  }\n\n  /*\n   * Return\n   * - A complete ApduResponse\n   * - Or a Nothing if not all the data has been received\n   *\n   * @param Maybe<number>\n   */\n  private getCompleteFrame(dataSize: Maybe<number>): Maybe<ApduResponse> {\n    return dataSize.chain((value) => {\n      if (!this.isComplete(value)) {\n        this._logger.debug(\"frame is not complete, waiting for more\");\n        return Nothing;\n      }\n\n      const concatenatedFramesData = FramerUtils.getFirstBytesFrom(\n        this.concatFrames(this._pendingFrames),\n        value,\n      );\n      const data = FramerUtils.getFirstBytesFrom(\n        concatenatedFramesData,\n        concatenatedFramesData.length - APDU_RESPONSE_STATUS_CODE_LENGTH,\n      );\n      const statusCode = FramerUtils.getLastBytesFrom(\n        concatenatedFramesData,\n        APDU_RESPONSE_STATUS_CODE_LENGTH,\n      );\n\n      this._pendingFrames = [];\n\n      return Just(\n        new ApduResponse({\n          data: data,\n          statusCode,\n        }),\n      );\n    });\n  }\n\n  /*\n   * Parse an Uint8Array to a Frame\n   * Return an error if the frame is not formatted correctly\n   *\n   * @param Uint8Array\n   */\n  private getFrameFromBytes(\n    rawFrame: Uint8Array,\n  ): Either<ReceiverApduError, Frame> {\n    const channelSize = this._channel.caseOf({\n      Just: () => CHANNEL_LENGTH,\n      Nothing: () => 0,\n    });\n\n    const headTag = rawFrame.slice(channelSize, channelSize + HEAD_TAG_LENGTH);\n    const index = rawFrame.slice(\n      channelSize + HEAD_TAG_LENGTH,\n      channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH,\n    );\n\n    const isFirstIndex = index.reduce((curr, val) => curr + val, 0) === 0;\n\n    if (!isFirstIndex && this._pendingFrames.length === 0) {\n      return Left(new ReceiverApduError());\n    }\n\n    const dataSizeIndex = channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH;\n    const dataSizeLength = isFirstIndex ? APDU_DATA_LENGTH_LENGTH : 0;\n\n    if (\n      rawFrame.length <\n      channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH + dataSizeLength\n    ) {\n      return Left(new ReceiverApduError(\"Unable to parse header from apdu\"));\n    }\n\n    const dataSize = isFirstIndex\n      ? Just(rawFrame.slice(dataSizeIndex, dataSizeIndex + dataSizeLength))\n      : Nothing;\n\n    const dataIndex = dataSizeIndex + dataSizeLength;\n    const data = rawFrame.slice(dataIndex);\n\n    const frame = new Frame({\n      header: new FrameHeader({\n        uuid: v4(),\n        channel: this._channel,\n        dataSize,\n        headTag,\n        index,\n        length: channelSize + HEAD_TAG_LENGTH + INDEX_LENGTH + dataSizeLength,\n      }),\n      data,\n    });\n\n    return Right(frame);\n  }\n\n  /*\n   * Return true if all the datas has been received\n   *\n   * @param number\n   */\n  private isComplete(dataSize: number): boolean {\n    const totalReceiveLength = this._pendingFrames.reduce(\n      (prev, curr) => prev + curr.getData().length,\n      0,\n    );\n\n    return totalReceiveLength >= dataSize;\n  }\n\n  private concatFrames(frames: Frame[]): Uint8Array {\n    return frames.reduce(\n      (prev: Uint8Array, curr: Frame) =>\n        Uint8Array.from([...prev, ...curr.getData()]),\n      new Uint8Array(0),\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["inject", "injectable", "Just", "Left", "Maybe", "Nothing", "Right", "v4", "ApduResponse", "APDU_DATA_LENGTH_LENGTH", "CHANNEL_LENGTH", "HEAD_TAG_LENGTH", "INDEX_LENGTH", "FramerUtils", "APDU_RESPONSE_STATUS_CODE_LENGTH", "ReceiverApduError", "Frame", "FrameHeader", "loggerTypes", "DefaultApduReceiverService", "channel", "Maybe", "loggerModuleFactory", "frameBytes", "value", "Nothing", "dataSize", "concatenatedFramesData", "FramerUtils", "data", "APDU_RESPONSE_STATUS_CODE_LENGTH", "statusCode", "Just", "ApduResponse", "rawFrame", "channelSize", "CHANNEL_LENGTH", "headTag", "HEAD_TAG_LENGTH", "index", "INDEX_LENGTH", "isFirstIndex", "curr", "val", "Left", "ReceiverApduError", "dataSizeIndex", "dataSizeLength", "APDU_DATA_LENGTH_LENGTH", "dataIndex", "frame", "Frame", "FrameHeader", "v4", "Right", "prev", "frames", "__decorateClass", "injectable", "__decorateParam", "inject", "loggerTypes"]
}
