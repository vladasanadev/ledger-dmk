{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DeviceSessionStateHandler.ts"],
  "sourcesContent": ["import { type BehaviorSubject, type Subscription } from \"rxjs\";\n\nimport { type DeviceSessionState } from \"@api/device-session/DeviceSessionState\";\nimport {\n  DeviceSessionStateType,\n  DeviceStatus,\n  type GetAppAndVersionResponse,\n  isSuccessCommandResult,\n  type TransportConnectedDevice,\n} from \"@api/index\";\nimport { type CommandResult, type LoggerPublisherService } from \"@api/types\";\nimport {\n  type DeviceSessionEventDispatcher,\n  type NewEvent,\n  SessionEvents,\n} from \"@internal/device-session/model/DeviceSessionEventDispatcher\";\n\nexport type SetDeviceSessionStateFn = (state: DeviceSessionState) => void;\n\ntype NewDeviceStatus = {\n  sessionStateType: DeviceSessionStateType;\n  deviceStatus: DeviceStatus;\n  currentApp: {\n    name: string;\n    version: string;\n  };\n};\n\nexport class DeviceSessionStateHandler {\n  private _subscription: Subscription;\n  private readonly _logger: LoggerPublisherService;\n\n  constructor(\n    loggerModuleFactory: (tag: string) => LoggerPublisherService,\n    private _sessionEventDispatcher: DeviceSessionEventDispatcher,\n    private _connectedDevice: TransportConnectedDevice,\n    private _deviceState: BehaviorSubject<DeviceSessionState>,\n    private setDeviceSessionState: SetDeviceSessionStateFn,\n  ) {\n    this._subscription = this._sessionEventDispatcher\n      .listen()\n      .subscribe((event) => this.mapEventAction(event));\n    this._logger = loggerModuleFactory(\"device-session-state-handler\");\n  }\n\n  private _updateDeviceState(\n    parsedResponse: CommandResult<GetAppAndVersionResponse>,\n  ): void {\n    const newDeviceStatus = this._parseDeviceStatus(parsedResponse);\n\n    if (newDeviceStatus) {\n      const { sessionStateType, deviceStatus, currentApp } = newDeviceStatus;\n      const state = this._deviceState.getValue();\n      if (state.sessionStateType === DeviceSessionStateType.Connected) {\n        // When device is connected, initialize fields to default values\n        this.setDeviceSessionState({\n          sessionStateType,\n          deviceStatus,\n          deviceModelId: this._connectedDevice.deviceModel.id,\n          currentApp,\n          installedApps: [],\n          isSecureConnectionAllowed: false,\n        });\n      } else {\n        // When device is ready, keep un-modified state fields\n        this.setDeviceSessionState({\n          ...state,\n          sessionStateType,\n          deviceStatus,\n          deviceModelId: this._connectedDevice.deviceModel.id,\n          currentApp,\n        });\n      }\n    }\n  }\n\n  private mapEventAction = (event: NewEvent) => {\n    switch (event.eventName) {\n      case SessionEvents.COMMAND_SUCCEEDED:\n        return this._updateDeviceState(event.eventData);\n      case SessionEvents.DEVICE_STATE_UPDATE_BUSY:\n        return this.setDeviceSessionState({\n          ...this._deviceState.getValue(),\n          deviceStatus: DeviceStatus.BUSY,\n        });\n      case SessionEvents.DEVICE_STATE_UPDATE_LOCKED:\n        return this.setDeviceSessionState({\n          ...this._deviceState.getValue(),\n          deviceStatus: DeviceStatus.LOCKED,\n        });\n      case SessionEvents.DEVICE_STATE_UPDATE_CONNECTED:\n        return this.setDeviceSessionState({\n          ...this._deviceState.getValue(),\n          deviceStatus: DeviceStatus.CONNECTED,\n        });\n      default:\n        return null;\n    }\n  };\n\n  private _parseDeviceStatus(\n    parsedResponse: CommandResult<GetAppAndVersionResponse>,\n  ): NewDeviceStatus | null {\n    if (isSuccessCommandResult(parsedResponse)) {\n      return {\n        sessionStateType: DeviceSessionStateType.ReadyWithoutSecureChannel,\n        deviceStatus: DeviceStatus.CONNECTED,\n        currentApp: {\n          name: parsedResponse.data.name,\n          version: parsedResponse.data.version,\n        },\n      };\n    } else {\n      this._logger.debug(\"Error while parsing APDU response\", {\n        data: { parsedResponse },\n      });\n      return null;\n    }\n  }\n\n  public unsubscribe(): void {\n    this._subscription.unsubscribe();\n  }\n}\n"],
  "mappings": "AAGA,OACE,0BAAAA,EACA,gBAAAC,EAEA,0BAAAC,MAEK,aAEP,OAGE,iBAAAC,MACK,8DAaA,MAAMC,CAA0B,CAIrC,YACEC,EACQC,EACAC,EACAC,EACAC,EACR,CAJQ,6BAAAH,EACA,sBAAAC,EACA,kBAAAC,EACA,2BAAAC,EAER,KAAK,cAAgB,KAAK,wBACvB,OAAO,EACP,UAAWC,GAAU,KAAK,eAAeA,CAAK,CAAC,EAClD,KAAK,QAAUL,EAAoB,8BAA8B,CACnE,CAdQ,cACS,QAeT,mBACNM,EACM,CACN,MAAMC,EAAkB,KAAK,mBAAmBD,CAAc,EAE9D,GAAIC,EAAiB,CACnB,KAAM,CAAE,iBAAAC,EAAkB,aAAAC,EAAc,WAAAC,CAAW,EAAIH,EACjDI,EAAQ,KAAK,aAAa,SAAS,EACrCA,EAAM,mBAAqBhB,EAAuB,UAEpD,KAAK,sBAAsB,CACzB,iBAAAa,EACA,aAAAC,EACA,cAAe,KAAK,iBAAiB,YAAY,GACjD,WAAAC,EACA,cAAe,CAAC,EAChB,0BAA2B,EAC7B,CAAC,EAGD,KAAK,sBAAsB,CACzB,GAAGC,EACH,iBAAAH,EACA,aAAAC,EACA,cAAe,KAAK,iBAAiB,YAAY,GACjD,WAAAC,CACF,CAAC,CAEL,CACF,CAEQ,eAAkBL,GAAoB,CAC5C,OAAQA,EAAM,UAAW,CACvB,KAAKP,EAAc,kBACjB,OAAO,KAAK,mBAAmBO,EAAM,SAAS,EAChD,KAAKP,EAAc,yBACjB,OAAO,KAAK,sBAAsB,CAChC,GAAG,KAAK,aAAa,SAAS,EAC9B,aAAcF,EAAa,IAC7B,CAAC,EACH,KAAKE,EAAc,2BACjB,OAAO,KAAK,sBAAsB,CAChC,GAAG,KAAK,aAAa,SAAS,EAC9B,aAAcF,EAAa,MAC7B,CAAC,EACH,KAAKE,EAAc,8BACjB,OAAO,KAAK,sBAAsB,CAChC,GAAG,KAAK,aAAa,SAAS,EAC9B,aAAcF,EAAa,SAC7B,CAAC,EACH,QACE,OAAO,IACX,CACF,EAEQ,mBACNU,EACwB,CACxB,OAAIT,EAAuBS,CAAc,EAChC,CACL,iBAAkBX,EAAuB,0BACzC,aAAcC,EAAa,UAC3B,WAAY,CACV,KAAMU,EAAe,KAAK,KAC1B,QAASA,EAAe,KAAK,OAC/B,CACF,GAEA,KAAK,QAAQ,MAAM,oCAAqC,CACtD,KAAM,CAAE,eAAAA,CAAe,CACzB,CAAC,EACM,KAEX,CAEO,aAAoB,CACzB,KAAK,cAAc,YAAY,CACjC,CACF",
  "names": ["DeviceSessionStateType", "DeviceStatus", "isSuccessCommandResult", "SessionEvents", "DeviceSessionStateHandler", "loggerModuleFactory", "_sessionEventDispatcher", "_connectedDevice", "_deviceState", "setDeviceSessionState", "event", "parsedResponse", "newDeviceStatus", "sessionStateType", "deviceStatus", "currentApp", "state"]
}
