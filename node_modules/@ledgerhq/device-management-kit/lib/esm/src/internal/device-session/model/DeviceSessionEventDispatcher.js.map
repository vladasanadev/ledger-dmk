{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DeviceSessionEventDispatcher.ts"],
  "sourcesContent": ["import { type Observable, Subject } from \"rxjs\";\n\nimport { type GetAppAndVersionResponse } from \"@api/index\";\nimport { type CommandResult } from \"@api/types\";\n\nexport enum SessionEvents {\n  NEW_STATE = \"NEW_STATE\",\n  REFRESH_NEEDED = \"REFRESH_NEEDED\",\n  COMMAND_SUCCEEDED = \"COMMAND_SUCCEEDED\",\n  DEVICE_STATE_UPDATE_BUSY = \"DEVICE_STATE_UPDATE_BUSY\",\n  DEVICE_STATE_UPDATE_LOCKED = \"DEVICE_STATE_UPDATE_LOCKED\",\n  DEVICE_STATE_UPDATE_CONNECTED = \"DEVICE_STATE_UPDATE_CONNECTED\",\n}\n\ninterface SessionEventPayloads {\n  [SessionEvents.NEW_STATE]: undefined;\n  [SessionEvents.REFRESH_NEEDED]: undefined;\n  [SessionEvents.DEVICE_STATE_UPDATE_BUSY]: undefined;\n  [SessionEvents.DEVICE_STATE_UPDATE_LOCKED]: undefined;\n  [SessionEvents.DEVICE_STATE_UPDATE_CONNECTED]: undefined;\n  [SessionEvents.COMMAND_SUCCEEDED]: CommandResult<GetAppAndVersionResponse>;\n}\n\nexport type NewEvent = {\n  [K in SessionEvents]: SessionEventPayloads[K] extends undefined\n    ? { eventName: K; eventData?: undefined }\n    : { eventName: K; eventData: SessionEventPayloads[K] };\n}[SessionEvents];\n\nexport class DeviceSessionEventDispatcher {\n  private _eventEmitter: Subject<NewEvent> = new Subject();\n\n  public listen(): Observable<NewEvent> {\n    return this._eventEmitter.asObservable();\n  }\n\n  public dispatch(event: NewEvent): void {\n    this._eventEmitter.next(event);\n  }\n}\n"],
  "mappings": "AAAA,OAA0B,WAAAA,MAAe,OAKlC,IAAKC,OACVA,EAAA,UAAY,YACZA,EAAA,eAAiB,iBACjBA,EAAA,kBAAoB,oBACpBA,EAAA,yBAA2B,2BAC3BA,EAAA,2BAA6B,6BAC7BA,EAAA,8BAAgC,gCANtBA,OAAA,IAwBL,MAAMC,CAA6B,CAChC,cAAmC,IAAIF,EAExC,QAA+B,CACpC,OAAO,KAAK,cAAc,aAAa,CACzC,CAEO,SAASG,EAAuB,CACrC,KAAK,cAAc,KAAKA,CAAK,CAC/B,CACF",
  "names": ["Subject", "SessionEvents", "DeviceSessionEventDispatcher", "event"]
}
