{
  "version": 3,
  "sources": ["../../../../../../src/internal/device-session/model/DevicePinger.test.ts"],
  "sourcesContent": ["import { Subject } from \"rxjs\";\nimport { afterEach, beforeEach, describe, expect, it, vi } from \"vitest\";\n\nimport { DeviceModelId } from \"@api/device/DeviceModel\";\nimport {\n  GetAppAndVersionCommand,\n  type TransportConnectedDevice,\n} from \"@api/index\";\nimport type { LoggerPublisherService } from \"@api/types\";\nimport { DEVICE_SESSION_REFRESHER_POLLING_INTERVAL } from \"@internal/device-session/data/DeviceSessionRefresherConst\";\nimport {\n  type DeviceSessionEventDispatcher,\n  type NewEvent,\n  SessionEvents,\n} from \"@internal/device-session/model/DeviceSessionEventDispatcher\";\n\nimport { DevicePinger } from \"./DevicePinger\";\n\ndescribe(\"DevicePinger\", () => {\n  let dummySendCommandFunction: ReturnType<typeof vi.fn>;\n  let mockLogger: LoggerPublisherService & {\n    info: ReturnType<typeof vi.fn>;\n    warn: ReturnType<typeof vi.fn>;\n    error: ReturnType<typeof vi.fn>;\n  };\n  const mockedLoggerModuleFactory = vi.fn(() => mockLogger);\n  let eventSubject: Subject<NewEvent>;\n  let mockSessionEventDispatcher: DeviceSessionEventDispatcher;\n  let dummyConnectedDevice: TransportConnectedDevice;\n  let devicePinger: DevicePinger;\n\n  beforeEach(() => {\n    eventSubject = new Subject<NewEvent>();\n    mockSessionEventDispatcher = {\n      listen: () => eventSubject.asObservable(),\n      dispatch: vi.fn(),\n    } as unknown as DeviceSessionEventDispatcher;\n\n    dummySendCommandFunction = vi.fn();\n    mockLogger = {\n      info: vi.fn(),\n      warn: vi.fn(),\n      error: vi.fn(),\n      debug: vi.fn(),\n      subscribers: [],\n    };\n\n    dummyConnectedDevice = {\n      deviceModel: {\n        id: DeviceModelId.NANO_X,\n      },\n    } as unknown as TransportConnectedDevice;\n\n    devicePinger = new DevicePinger(\n      mockedLoggerModuleFactory,\n      dummyConnectedDevice,\n      mockSessionEventDispatcher,\n      dummySendCommandFunction,\n    );\n  });\n\n  afterEach(() => {\n    devicePinger.unsubscribe();\n    vi.restoreAllMocks();\n  });\n\n  it(\"should call sendCommandFunction and dispatch COMMAND_SUCCEEDED event on successful ping for non-NANO_S\", async () => {\n    // given\n    const dummyResult = {\n      status: \"success\",\n      data: { foo: \"bar\" },\n    };\n    dummySendCommandFunction.mockResolvedValue(dummyResult);\n\n    // when\n    const result = await devicePinger.ping();\n\n    // then\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n    const commandArg = dummySendCommandFunction.mock\n      .calls[0]![0] as GetAppAndVersionCommand;\n    expect(commandArg).toBeInstanceOf(GetAppAndVersionCommand);\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.COMMAND_SUCCEEDED,\n      eventData: dummyResult,\n    });\n    expect(result).toEqual(dummyResult);\n  });\n\n  it(\"should log error and throw error on ping failure\", async () => {\n    // given\n    const dummyError = new Error(\"ping failed\");\n    dummySendCommandFunction.mockRejectedValue(dummyError);\n\n    // then\n    await expect(devicePinger.ping()).rejects.toThrow(\"ping failed\");\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n  });\n\n  it(\"should dispatch DEVICE_STATE_UPDATE_LOCKED and return null on timeout for NANO_S\", async () => {\n    // given\n    dummyConnectedDevice.deviceModel.id = DeviceModelId.NANO_S;\n    devicePinger.unsubscribe();\n    devicePinger = new DevicePinger(\n      mockedLoggerModuleFactory,\n      dummyConnectedDevice,\n      mockSessionEventDispatcher,\n      dummySendCommandFunction,\n    );\n    const neverResolvingPromise = new Promise(() => {});\n    dummySendCommandFunction.mockReturnValueOnce(neverResolvingPromise);\n    vi.useFakeTimers();\n\n    // when\n    const pingPromise = devicePinger.ping();\n    vi.advanceTimersByTime(DEVICE_SESSION_REFRESHER_POLLING_INTERVAL * 4);\n\n    const result = await pingPromise;\n\n    // then\n    expect(result).toBeNull();\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.DEVICE_STATE_UPDATE_LOCKED,\n    });\n    expect(dummySendCommandFunction).toHaveBeenCalledTimes(1);\n\n    vi.useRealTimers();\n  });\n\n  it(\"should call ping on REFRESH_NEEDED event\", async () => {\n    // given\n    const dummyResult = {\n      status: \"success\",\n      data: { foo: \"bar\" },\n    };\n    dummySendCommandFunction.mockResolvedValue(dummyResult);\n\n    // when\n    eventSubject.next({\n      eventName: SessionEvents.REFRESH_NEEDED,\n      eventData: undefined,\n    });\n    await Promise.resolve();\n\n    // then\n    expect(dummySendCommandFunction).toHaveBeenCalled();\n    expect(mockSessionEventDispatcher.dispatch).toHaveBeenCalledWith({\n      eventName: SessionEvents.COMMAND_SUCCEEDED,\n      eventData: dummyResult,\n    });\n  });\n\n  it(\"should not process events after unsubscribe is called\", async () => {\n    // given\n    devicePinger.unsubscribe();\n    dummySendCommandFunction.mockClear();\n\n    // when\n    eventSubject.next({\n      eventName: SessionEvents.REFRESH_NEEDED,\n      eventData: undefined,\n    });\n    await Promise.resolve();\n\n    // then\n    expect(dummySendCommandFunction).not.toHaveBeenCalled();\n  });\n});\n"],
  "mappings": "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",
  "names": ["Subject", "afterEach", "beforeEach", "describe", "expect", "it", "vi", "DeviceModelId", "GetAppAndVersionCommand", "DEVICE_SESSION_REFRESHER_POLLING_INTERVAL", "SessionEvents", "DevicePinger", "dummySendCommandFunction", "mockLogger", "mockedLoggerModuleFactory", "eventSubject", "mockSessionEventDispatcher", "dummyConnectedDevice", "devicePinger", "dummyResult", "result", "commandArg", "dummyError", "neverResolvingPromise", "pingPromise"]
}
