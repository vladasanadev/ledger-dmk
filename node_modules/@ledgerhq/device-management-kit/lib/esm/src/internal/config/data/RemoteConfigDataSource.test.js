import{Either as e,Left as o}from"purify-ts";import{ApiCallError as c,JSONParseError as l,ParseResponseError as i}from"../../config/model/Errors";import{RestRemoteConfigDataSource as s}from"./RemoteConfigDataSource";let r;const t=vi.spyOn(s.prototype,"_callApi"),n=vi.spyOn(s.prototype,"_parseResponse");describe("RemoteRestConfigDataSource",()=>{describe("RestRemoteConfigDataSource",()=>{beforeEach(()=>{t.mockClear(),n.mockClear(),r=new s}),it("should return an Either<never, Config>",async()=>{t.mockResolvedValue(e.of({ok:!0,json:()=>Promise.resolve(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"}))})),n.mockReturnValue(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"})),expect(await r.getConfig()).toStrictEqual(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"}))}),it("should return an Either<ApiCallError, never> if _callApi throws",async()=>{const a=new Error("_callApi error");t.mockResolvedValue(o(a)),expect(await r.getConfig()).toStrictEqual(o(new c(a)))}),it("should return an Either<ApiCallError, never> if _callApi returns a non-ok response",async()=>{t.mockResolvedValue(e.of({ok:!1,json:()=>Promise.resolve(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"}))})),expect(await r.getConfig()).toStrictEqual(o(new c(new Error("response not ok"))))}),it("should return an Either<JSONParseError, never> if deserializing json fails",async()=>{const a=new Error("deserializing json failure");t.mockResolvedValue(e.of({ok:!0,json:()=>Promise.resolve(o(a))})),expect(await r.getConfig()).toStrictEqual(o(new l))}),it("should return an Either<ParseResponseError, never> if _parseResponse throws",async()=>{t.mockResolvedValue(e.of({ok:!0,json:()=>Promise.resolve(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"}))})),n.mockImplementation(()=>o(new i)),expect(await r.getConfig()).toStrictEqual(o(new i))}),it("should return an Either<ParseResponseError, never> if `name` is missing in Dto",async()=>{n.mockRestore(),t.mockResolvedValue(e.of({ok:!0,json:()=>Promise.resolve(e.of({version:"0.0.0-fake.1",yolo:"yolo"}))})),expect(await r.getConfig()).toStrictEqual(o(new i))}),describe("without private methods spy",()=>{beforeEach(()=>{t.mockRestore(),n.mockRestore()}),it("should return an Either<never, Config>",async()=>{expect(await r.getConfig()).toStrictEqual(e.of({name:"DeviceSDK",version:"0.0.0-fake.1"}))})})})});
//# sourceMappingURL=RemoteConfigDataSource.test.js.map
