import{DeviceConnectionStateMachine as C,DeviceNotRecognizedError as m,LEDGER_VENDOR_ID as l,NoAccessibleDeviceError as g,OpeningConnectionError as u,TransportConnectedDevice as y,UnknownDeviceError as b}from"@ledgerhq/device-management-kit";import*as a from"@sentry/minimal";import{EitherAsync as _,Left as d,Maybe as f,Right as v}from"purify-ts";import{BehaviorSubject as H,from as E,map as S,switchMap as T}from"rxjs";import{v4 as I}from"uuid";import{RECONNECT_DEVICE_TIMEOUT as A}from"../data/WebHidConfig";import{WebHidTransportNotSupportedError as w}from"../model/Errors";import{WebHidApduSender as M}from"./WebHidApduSender";const P="WEB-HID";class R{constructor(e,i,t,n,o=c=>new C(c),s=(c,p)=>new M(c,p)){this._deviceModelDataSource=e;this._loggerServiceFactory=i;this._apduSenderFactory=t;this._apduReceiverFactory=n;this._deviceConnectionStateMachineFactory=o;this._deviceApduSenderFactory=s;this._logger=i("WebWebHidTransport"),this.startListeningToConnectionEvents()}_transportDiscoveredDevices=new H([]);_deviceConnectionsByHidDevice=new Map;_deviceConnectionsPendingReconnection=new Set;_connectionListenersAbortController=new AbortController;_logger;connectionType="USB";identifier=P;get hidApi(){return this.isSupported()?v(navigator.hid):d(new w("WebHID not supported"))}isSupported(){try{const e=!!navigator?.hid;return this._logger.debug(`isSupported: ${e}`),e}catch(e){return this._logger.error("isSupported: error",{data:{error:e}}),!1}}getIdentifier(){return this.identifier}async getDevices(){return _.liftEither(this.hidApi).map(async e=>{try{return(await e.getDevices()).filter(t=>t.vendorId===l)}catch(i){const t=new g(i);throw this._logger.error("getDevices: error getting devices",{data:{error:i}}),a.captureException(t),t}})}mapHIDDeviceToTransportDiscoveredDevice(e){const i=this._transportDiscoveredDevices.getValue().find(o=>o.hidDevice===e);if(i)return i;const t=this._deviceConnectionsByHidDevice.get(e);return this.getDeviceModel(e).caseOf({Just:o=>{const s=t?.getDeviceId()??I(),c={id:s,deviceModel:o,hidDevice:e,transport:this.identifier};return this._logger.debug(`Discovered device ${s} ${c.deviceModel.productName}`),c},Nothing:()=>{throw this._logger.warn(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`),new m(`Device not recognized: hidDevice.productId: 0x${e.productId.toString(16)}`)}})}listenToAvailableDevices(){return this.updateTransportDiscoveredDevices(),this._transportDiscoveredDevices.pipe(S(e=>e.map(({hidDevice:i,...t})=>t)))}async updateTransportDiscoveredDevices(){(await this.getDevices()).caseOf({Left:i=>{this._logger.error("Error while getting accessible device",{data:{error:i}}),a.captureException(i)},Right:i=>{this._transportDiscoveredDevices.next(i.map(t=>this.mapHIDDeviceToTransportDiscoveredDevice(t)))}})}async promptDeviceAccess(){return _.liftEither(this.hidApi).map(async e=>{let i=[];try{i=await e.requestDevice({filters:[{vendorId:l}]}),await this.updateTransportDiscoveredDevices()}catch(n){const o=new g(n);throw this._logger.error("promptDeviceAccess: error requesting device",{data:{error:n}}),a.captureException(o),o}if(this._logger.debug(`promptDeviceAccess: hidDevices len ${i.length}`),i.length===0)throw this._logger.warn("No device was selected"),new g("No selected device");const t=[];for(const n of i)t.push(n),this._logger.debug("promptDeviceAccess: selected device",{data:{hidDevice:n}});return t}).run()}startDiscovering(){return this._logger.debug("startDiscovering"),E(this.promptDeviceAccess()).pipe(T(e=>e.caseOf({Left:i=>{throw this._logger.error("Error while getting accessible device",{data:{error:i}}),a.captureException(i),i},Right:i=>{this._logger.info(`Got access to ${i.length} HID devices`);const t=i.map(n=>this.mapHIDDeviceToTransportDiscoveredDevice(n));return E(t)}})))}stopDiscovering(){}startListeningToConnectionEvents(){this._logger.debug("startListeningToConnectionEvents"),this.hidApi.map(e=>{e.addEventListener("connect",i=>this.handleDeviceConnectionEvent(i),{signal:this._connectionListenersAbortController.signal}),e.addEventListener("disconnect",i=>this.handleDeviceDisconnectionEvent(i),{signal:this._connectionListenersAbortController.signal})})}stopListeningToConnectionEvents(){this._logger.debug("stopListeningToConnectionEvents"),this._connectionListenersAbortController.abort()}async connect({deviceId:e,onDisconnect:i}){this._logger.debug("connect",{data:{deviceId:e}});const t=this._transportDiscoveredDevices.getValue().find(r=>r.id===e);if(!t)return this._logger.error(`Unknown device ${e}`),d(new b(`Unknown device ${e}`));const{deviceModel:n}=t,o=this._deviceConnectionsByHidDevice.get(t.hidDevice);if(o)return v(new y({id:e,deviceModel:n,type:this.connectionType,sendApdu:(...r)=>o.sendApdu(...r),transport:this.identifier}));const s=this._deviceApduSenderFactory({apduSenderFactory:this._apduSenderFactory,apduReceiverFactory:this._apduReceiverFactory,dependencies:{device:t.hidDevice}},this._loggerServiceFactory),c=this._deviceConnectionStateMachineFactory({deviceId:e,deviceApduSender:s,timeoutDuration:A,tryToReconnect:()=>{this._deviceConnectionsByHidDevice.forEach((r,D)=>{r.getDeviceId()===e&&(this._deviceConnectionsPendingReconnection.add(r),this._deviceConnectionsByHidDevice.delete(D))})},onTerminated:()=>{this._deviceConnectionsPendingReconnection.forEach(r=>{r.getDeviceId()===e&&(this._deviceConnectionsPendingReconnection.delete(r),i(r.getDeviceId()))}),this._deviceConnectionsByHidDevice.forEach((r,D)=>{r.getDeviceId()===e&&(this._deviceConnectionsByHidDevice.delete(D),i(r.getDeviceId()))})}});try{await s.setupConnection()}catch(r){return r instanceof u?d(r):d(new u(r))}this._deviceConnectionsByHidDevice.set(t.hidDevice,c);const p=new y({sendApdu:(...r)=>c.sendApdu(...r),deviceModel:n,id:e,type:this.connectionType,transport:this.identifier});return v(p)}getDeviceModel(e){const{productId:i}=e,t=this._deviceModelDataSource.getAllDeviceModels().find(n=>n.usbProductId===i>>8||n.bootloaderUsbProductId===i);return t?f.of(t):f.zero()}getHidUsbProductId(e){return this.getDeviceModel(e).caseOf({Just:i=>i.usbProductId,Nothing:()=>e.productId>>8})}async disconnect(e){this._logger.debug("disconnect",{data:{connectedDevice:e}});const i=Array.from(this._deviceConnectionsByHidDevice.values()).find(t=>t.getDeviceId()===e.connectedDevice.id);return i?(i.closeConnection(),Promise.resolve(v(void 0))):(this._logger.error("No matching device connection found",{data:{connectedDevice:e}}),Promise.resolve(d(new b(`Unknown device ${e.connectedDevice.id}`))))}isHIDConnectionEvent(e){return"device"in e&&typeof e.device=="object"&&e.device!==null&&"productId"in e.device&&typeof e.device.productId=="number"}async handleDeviceDisconnectionEvent(e){if(!this.isHIDConnectionEvent(e)){this._logger.error("Invalid event",{data:{event:e}});return}this._logger.info("[handleDeviceDisconnectionEvent] Device disconnected",{data:{event:e}}),this.updateTransportDiscoveredDevices();try{await e.device.close()}catch(t){this._logger.error("Error while closing device ",{data:{event:e,error:t}})}const i=this._deviceConnectionsByHidDevice.get(e.device);i&&i.eventDeviceDisconnected()}async handleDeviceReconnection(e,i){this._deviceConnectionsPendingReconnection.delete(e),this._deviceConnectionsByHidDevice.set(i,e);try{e.setDependencies({device:i}),await e.setupConnection(),e.eventDeviceConnected()}catch(t){this._logger.error("Error while reconnecting to device",{data:{event,error:t}}),e.closeConnection()}}async handleDeviceConnectionEvent(e){if(!this.isHIDConnectionEvent(e)){this._logger.error("Invalid event",{data:{event:e}});return}this._logger.info("[handleDeviceConnectionEvent] Device connected",{data:{event:e}});const i=Array.from(this._deviceConnectionsPendingReconnection).find(t=>this.getHidUsbProductId(t.getDependencies().device)===this.getHidUsbProductId(e.device));i&&await this.handleDeviceReconnection(i,e.device),this.updateTransportDiscoveredDevices()}destroy(){this.stopListeningToConnectionEvents(),this._deviceConnectionsByHidDevice.forEach(e=>{e.closeConnection()}),this._deviceConnectionsPendingReconnection.clear()}}const U=({deviceModelDataSource:h,loggerServiceFactory:e,apduSenderServiceFactory:i,apduReceiverServiceFactory:t})=>new R(h,e,i,t);export{R as WebHidTransport,P as webHidIdentifier,U as webHidTransportFactory};
//# sourceMappingURL=WebHidTransport.js.map
