{
  "version": 3,
  "sources": ["../../../../src/api/transport/WebHidTransport.test.ts"],
  "sourcesContent": ["/* eslint @typescript-eslint/consistent-type-imports: off */\nimport {\n  type ApduReceiverServiceFactory,\n  type ApduResponse,\n  type ApduSenderServiceFactory,\n  connectedDeviceStubBuilder,\n  DeviceConnectionStateMachine,\n  type DeviceConnectionStateMachineParams,\n  type DeviceModel,\n  DeviceModelId,\n  DeviceNotRecognizedError,\n  type LoggerPublisherService,\n  type LoggerSubscriberService,\n  NoAccessibleDeviceError,\n  OpeningConnectionError,\n  StaticDeviceModelDataSource,\n  type TransportDeviceModel,\n  type TransportDiscoveredDevice,\n  UnknownDeviceError,\n} from \"@ledgerhq/device-management-kit\";\nimport { Left, Right } from \"purify-ts\";\nimport { lastValueFrom, Subject, toArray } from \"rxjs\";\n\nimport { RECONNECT_DEVICE_TIMEOUT } from \"@api/data/WebHidConfig\";\nimport { WebHidTransportNotSupportedError } from \"@api/model/Errors\";\nimport { hidDeviceStubBuilder } from \"@api/model/HIDDevice.stub\";\n\nimport { WebHidApduSender } from \"./WebHidApduSender\";\nimport { WebHidTransport } from \"./WebHidTransport\";\n\nclass LoggerPublisherServiceStub implements LoggerPublisherService {\n  constructor(subscribers: LoggerSubscriberService[], tag: string) {\n    this.subscribers = subscribers;\n    this.tag = tag;\n  }\n  subscribers: LoggerSubscriberService[] = [];\n  tag: string = \"\";\n  error = vi.fn();\n  warn = vi.fn();\n  info = vi.fn();\n  debug = vi.fn();\n}\n\n// Our StaticDeviceModelDataSource can directly be used in our unit tests\nconst usbDeviceModelDataSource = new StaticDeviceModelDataSource();\nconst logger = new LoggerPublisherServiceStub([], \"web-usb-hid\");\n\nconst stubDevice: HIDDevice = hidDeviceStubBuilder();\n\n/**\n * Flushes all pending promises\n */\nconst flushPromises = async () => {\n  const timers = await vi.importActual<typeof import(\"timers\")>(\"timers\");\n  return new Promise(timers.setImmediate);\n};\n\ndescribe(\"WebHidTransport\", () => {\n  let transport: WebHidTransport;\n  let apduReceiverServiceFactoryStub: ApduReceiverServiceFactory;\n  let apduSenderServiceFactoryStub: ApduSenderServiceFactory;\n\n  let mockDeviceConnectionStateMachineFactory = vi.fn();\n  const mockEventDeviceConnected = vi.fn();\n  const mockEventDeviceDisconnected = vi.fn();\n\n  const mockDeviceApduSender = {\n    sendApdu: vi\n      .fn()\n      .mockResolvedValue(Right({ data: new Uint8Array() } as ApduResponse)),\n    getDependencies: vi.fn().mockReturnValue({ device: stubDevice }),\n    setDependencies: vi.fn(),\n    closeConnection: vi.fn(),\n    setupConnection: vi.fn(),\n  };\n\n  const mockDeviceConnectionStateMachine = {\n    getDependencies: vi.fn().mockReturnValue({ device: stubDevice }),\n    setDependencies: vi.fn(),\n    getDeviceId: vi.fn(),\n    sendApdu: vi\n      .fn()\n      .mockResolvedValue(Right({ data: new Uint8Array() } as ApduResponse)),\n    setupConnection: vi.fn(),\n    eventDeviceConnected: mockEventDeviceConnected,\n    eventDeviceDisconnected: mockEventDeviceDisconnected,\n    closeConnection: vi.fn(),\n  };\n\n  function initializeTransport() {\n    apduReceiverServiceFactoryStub = vi.fn();\n    apduSenderServiceFactoryStub = vi.fn();\n    mockDeviceConnectionStateMachineFactory = vi.fn(\n      (params: DeviceConnectionStateMachineParams<{ device: HIDDevice }>) => {\n        return {\n          ...mockDeviceConnectionStateMachine,\n          getDeviceId: vi.fn().mockReturnValue(params.deviceId),\n          getDependencies: params.deviceApduSender.getDependencies,\n          setDependencies: params.deviceApduSender.setDependencies,\n        } as unknown as DeviceConnectionStateMachine<{ device: HIDDevice }>;\n      },\n    );\n    const mockDeviceApduSenderFactory = vi.fn((params) => {\n      return {\n        ...mockDeviceApduSender,\n        getDependencies: () => params.dependencies,\n        setDependencies: (dependencies: { device: HIDDevice }) =>\n          (params.dependencies = dependencies),\n      } as unknown as WebHidApduSender;\n    });\n    transport = new WebHidTransport(\n      usbDeviceModelDataSource,\n      () => logger,\n      apduSenderServiceFactoryStub,\n      apduReceiverServiceFactoryStub,\n      mockDeviceConnectionStateMachineFactory,\n      mockDeviceApduSenderFactory,\n    );\n  }\n\n  beforeEach(() => {\n    initializeTransport();\n    vi.useFakeTimers();\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  const discoverDevice = (\n    onSuccess: (discoveredDevice: TransportDiscoveredDevice) => void,\n    onError?: (error: unknown) => void,\n  ) => {\n    transport.startDiscovering().subscribe({\n      next: onSuccess,\n      error: onError,\n    });\n  };\n\n  describe(\"When WebHID API is not supported\", () => {\n    it(\"should not support the transport\", () => {\n      expect(transport.isSupported()).toBe(false);\n    });\n\n    it(\"should emit a startDiscovering error\", () =>\n      new Promise<void>((resolve, reject) => {\n        discoverDevice(\n          () => {\n            reject(\"Should not emit any value\");\n          },\n          (error) => {\n            expect(error).toBeInstanceOf(WebHidTransportNotSupportedError);\n            resolve();\n          },\n        );\n      }));\n  });\n\n  describe(\"When WebHID API is supported\", () => {\n    const mockedGetDevices = vi.fn();\n    const mockedRequestDevice = vi.fn();\n\n    const connectionEventsSubject = new Subject<HIDConnectionEvent>();\n    const disconnectionEventsSubject = new Subject<HIDConnectionEvent>();\n\n    function emitHIDConnectionEvent(device: HIDDevice) {\n      connectionEventsSubject.next({\n        device,\n      } as HIDConnectionEvent);\n    }\n\n    function emitHIDDisconnectionEvent(device: HIDDevice) {\n      disconnectionEventsSubject.next({\n        device,\n      } as HIDConnectionEvent);\n    }\n\n    beforeEach(() => {\n      global.navigator = {\n        hid: {\n          getDevices: mockedGetDevices,\n          requestDevice: mockedRequestDevice,\n          addEventListener: (\n            eventName: string,\n            callback: (event: HIDConnectionEvent) => void,\n          ) => {\n            if (eventName === \"disconnect\") {\n              disconnectionEventsSubject.subscribe(callback);\n            } else if (eventName === \"connect\") {\n              connectionEventsSubject.subscribe(callback);\n            }\n          },\n        },\n      } as unknown as Navigator;\n      initializeTransport();\n    });\n\n    afterEach(() => {\n      vi.clearAllMocks();\n      global.navigator = undefined as unknown as Navigator;\n    });\n\n    it(\"should support the transport\", () => {\n      expect(transport.isSupported()).toBe(true);\n    });\n\n    describe(\"startDiscovering\", () => {\n      const testCases = usbDeviceModelDataSource\n        .getAllDeviceModels()\n        .flatMap((deviceModel) => {\n          return [\n            {\n              testTitle: `should emit device if user grants access through hid.requestDevice (${deviceModel.productName})`,\n              hidDevice: hidDeviceStubBuilder({\n                productId: deviceModel.usbProductId << 8,\n                productName: deviceModel.productName,\n              }),\n              expectedDeviceModel: deviceModel,\n            },\n            {\n              testTitle: `should emit device if user grants access through hid.requestDevice (${deviceModel.productName}, bootloader)`,\n              hidDevice: hidDeviceStubBuilder({\n                productId: deviceModel.bootloaderUsbProductId,\n                productName: deviceModel.productName,\n              }),\n              expectedDeviceModel: deviceModel,\n            },\n          ];\n        });\n\n      testCases.forEach((testCase) => {\n        it(\n          testCase.testTitle,\n          () =>\n            new Promise<void>((resolve, reject) => {\n              mockedRequestDevice.mockResolvedValueOnce([testCase.hidDevice]);\n\n              discoverDevice(\n                (discoveredDevice) => {\n                  try {\n                    expect(discoveredDevice).toEqual(\n                      expect.objectContaining({\n                        deviceModel: testCase.expectedDeviceModel,\n                      }),\n                    );\n\n                    resolve();\n                  } catch (expectError) {\n                    reject(expectError as Error);\n                  }\n                },\n                (error) => {\n                  reject(error as Error);\n                },\n              );\n            }),\n        );\n      });\n\n      // It does not seem possible for a user to select several devices on the browser popup.\n      // But if it was possible, we should emit them\n      it(\"should emit devices if new grant accesses\", () =>\n        new Promise<void>((resolve, reject) => {\n          mockedRequestDevice.mockResolvedValueOnce([\n            stubDevice,\n            {\n              ...stubDevice,\n              productId: 0x5011,\n              productName: \"Ledger Nano S Plus\",\n            },\n          ]);\n\n          let count = 0;\n          discoverDevice(\n            (discoveredDevice) => {\n              try {\n                switch (count) {\n                  case 0:\n                    expect(discoveredDevice).toEqual(\n                      expect.objectContaining({\n                        deviceModel: expect.objectContaining({\n                          id: DeviceModelId.NANO_X,\n                          productName: \"Ledger Nano X\",\n                          usbProductId: 0x40,\n                        }) as DeviceModel,\n                      }),\n                    );\n                    break;\n                  case 1:\n                    expect(discoveredDevice).toEqual(\n                      expect.objectContaining({\n                        deviceModel: expect.objectContaining({\n                          id: DeviceModelId.NANO_SP,\n                          productName: \"Ledger Nano S Plus\",\n                          usbProductId: 0x50,\n                        }) as DeviceModel,\n                      }),\n                    );\n\n                    resolve();\n                    break;\n                }\n\n                count++;\n              } catch (expectError) {\n                reject(expectError as Error);\n              }\n            },\n            (error) => {\n              reject(error as Error);\n            },\n          );\n        }));\n\n      it(\"should throw DeviceNotRecognizedError if the device is not recognized\", () =>\n        new Promise<void>((resolve, reject) => {\n          mockedRequestDevice.mockResolvedValueOnce([\n            {\n              ...stubDevice,\n              productId: 0x4242,\n            },\n          ]);\n\n          discoverDevice(\n            () => {\n              reject(\"should not return a device\");\n            },\n            (error) => {\n              expect(error).toBeInstanceOf(DeviceNotRecognizedError);\n              resolve();\n            },\n          );\n        }));\n\n      it(\"should emit an error if the request device is in error\", () =>\n        new Promise<void>((resolve, reject) => {\n          const message = \"request device error\";\n          mockedRequestDevice.mockImplementationOnce(() => {\n            throw new Error(message);\n          });\n\n          discoverDevice(\n            () => {\n              reject(\"should not return a device\");\n            },\n            (error) => {\n              expect(error).toBeInstanceOf(NoAccessibleDeviceError);\n              expect(error).toStrictEqual(\n                new NoAccessibleDeviceError(new Error(message)),\n              );\n              resolve();\n            },\n          );\n        }));\n\n      // [ASK] Is this the behavior we want when the user does not select any device ?\n      it(\"should emit an error if the user did not grant us access to a device (clicking on cancel on the browser popup for ex)\", () =>\n        new Promise<void>((resolve, reject) => {\n          // When the user does not select any device, the `requestDevice` will return an empty array\n          mockedRequestDevice.mockResolvedValueOnce([]);\n\n          discoverDevice(\n            (discoveredDevice) => {\n              reject(\n                `Should not emit any value, but emitted ${JSON.stringify(\n                  discoveredDevice,\n                )}`,\n              );\n            },\n            (error) => {\n              try {\n                expect(error).toBeInstanceOf(NoAccessibleDeviceError);\n                resolve();\n              } catch (expectError) {\n                reject(expectError as Error);\n              }\n            },\n          );\n        }));\n\n      it(\"should emit the same discoveredDevice object if its discovered twice in a row\", async () => {\n        mockedRequestDevice.mockResolvedValue([stubDevice]);\n        mockedGetDevices.mockResolvedValue([stubDevice]);\n\n        const firstDiscoveredDevice = await new Promise<void>(\n          (resolve, reject) => {\n            discoverDevice(\n              () => resolve(),\n              (err) => reject(err),\n            );\n          },\n        );\n        const secondDiscoveredDevice = await new Promise<void>(\n          (resolve, reject) => {\n            discoverDevice(\n              () => resolve(),\n              (err) => reject(err),\n            );\n          },\n        );\n        expect(secondDiscoveredDevice).toBe(firstDiscoveredDevice);\n      });\n    });\n\n    describe(\"destroy\", () => {\n      it(\"should stop monitoring connections if the discovery process is halted\", () => {\n        const abortSpy = vi.spyOn(AbortController.prototype, \"abort\");\n\n        transport.destroy();\n\n        expect(abortSpy).toHaveBeenCalled();\n      });\n    });\n\n    describe(\"connect\", () => {\n      it(\"should throw UnknownDeviceError if no internal device\", async () => {\n        const connectParams = {\n          deviceId: \"fake\",\n          onDisconnect: vi.fn(),\n        };\n\n        const connect = await transport.connect(connectParams);\n\n        expect(connect).toStrictEqual(\n          Left(new UnknownDeviceError(\"Unknown device fake\")),\n        );\n      });\n\n      it(\"should throw OpeningConnectionError if the device cannot be opened\", async () => {\n        const message = \"cannot be opened\";\n        mockDeviceApduSender.setupConnection.mockRejectedValue(\n          new OpeningConnectionError(message),\n        );\n        mockedRequestDevice.mockResolvedValueOnce([stubDevice]);\n        mockedGetDevices.mockResolvedValue([stubDevice]);\n\n        const discoveredDevice = await lastValueFrom(\n          transport.startDiscovering(),\n        );\n        const connected = await transport.connect({\n          deviceId: discoveredDevice.id,\n          onDisconnect: vi.fn(),\n        });\n        expect(connected).toStrictEqual(\n          Left(new OpeningConnectionError(message)),\n        );\n      });\n\n      it(\"should return a device if available\", async () => {\n        mockedRequestDevice.mockResolvedValueOnce([stubDevice]);\n        mockedGetDevices.mockResolvedValue([stubDevice]);\n\n        const discoveredDevice = await lastValueFrom(\n          transport.startDiscovering(),\n        );\n        const connected = await transport.connect({\n          deviceId: discoveredDevice.id,\n          onDisconnect: vi.fn(),\n        });\n        expect(connected.isRight()).toStrictEqual(true);\n        expect(connected.extract()).toEqual(\n          expect.objectContaining({ id: discoveredDevice.id }),\n        );\n      });\n\n      it(\"should return an existing connected device\", async () => {\n        mockedRequestDevice.mockResolvedValueOnce([stubDevice]);\n        mockedGetDevices.mockResolvedValue([stubDevice]);\n\n        const discoveredDevice = await lastValueFrom(\n          transport.startDiscovering(),\n        );\n        await transport.connect({\n          deviceId: discoveredDevice.id,\n          onDisconnect: vi.fn(),\n        });\n        const connected = await transport.connect({\n          deviceId: discoveredDevice.id,\n          onDisconnect: vi.fn(),\n        });\n        expect(connected.isRight()).toStrictEqual(true);\n        expect(connected.extract()).toEqual(\n          expect.objectContaining({ id: discoveredDevice.id }),\n        );\n      });\n    });\n\n    describe(\"disconnect\", () => {\n      it(\"should throw an error if the device is not connected\", async () => {\n        // given\n        const connectedDevice = connectedDeviceStubBuilder();\n\n        // when\n        const disconnect = await transport.disconnect({\n          connectedDevice,\n        });\n\n        expect(disconnect).toStrictEqual(\n          Left(new UnknownDeviceError(`Unknown device ${connectedDevice.id}`)),\n        );\n      });\n\n      it(\"should disconnect if the device is connected\", async () => {\n        mockedRequestDevice.mockResolvedValueOnce([stubDevice]);\n        mockedGetDevices.mockResolvedValue([stubDevice]);\n\n        const discoveredDevice = await lastValueFrom(\n          transport.startDiscovering(),\n        );\n        const connected = await transport.connect({\n          deviceId: discoveredDevice.id,\n          onDisconnect: vi.fn(),\n        });\n        expect(connected.isRight()).toStrictEqual(true);\n        const result = await transport.disconnect({\n          connectedDevice: connected.unsafeCoerce(),\n        });\n        expect(result).toStrictEqual(Right(undefined));\n      });\n\n      it(\"should call disconnect handler if a connected device is unplugged\", async () => {\n        // Get onTerminated for the first connection only\n        let onTerminated1 = vi.fn();\n        mockDeviceConnectionStateMachineFactory.mockImplementationOnce(\n          (params) => {\n            onTerminated1 = params.onTerminated;\n            return {\n              ...mockDeviceConnectionStateMachine,\n              getDeviceId: vi.fn().mockReturnValue(params.deviceId),\n            } as unknown as DeviceConnectionStateMachine<{ device: HIDDevice }>;\n          },\n        );\n\n        // Add 2 discoverable devices\n        const hidDevice1 = hidDeviceStubBuilder();\n        const hidDevice2 = hidDeviceStubBuilder();\n        mockedRequestDevice.mockResolvedValueOnce([hidDevice1, hidDevice2]);\n        mockedGetDevices.mockResolvedValue([hidDevice1, hidDevice2]);\n\n        // Connect the 2 devices\n        const discoveredDevices = await lastValueFrom(\n          transport.startDiscovering().pipe(toArray()),\n        );\n        expect(discoveredDevices.length).toStrictEqual(2);\n        const onDisconnect1 = vi.fn();\n        const connected1 = await transport.connect({\n          deviceId: discoveredDevices[0]!.id,\n          onDisconnect: onDisconnect1,\n        });\n        const onDisconnect2 = vi.fn();\n        const connected2 = await transport.connect({\n          deviceId: discoveredDevices[1]!.id,\n          onDisconnect: onDisconnect2,\n        });\n        expect(connected1.isRight()).toStrictEqual(true);\n        expect(connected2.isRight()).toStrictEqual(true);\n\n        // unplug the first device\n        onTerminated1();\n        expect(onDisconnect1).toHaveBeenCalled();\n        expect(onDisconnect2).not.toHaveBeenCalled();\n      });\n\n      it(\"should call disconnect handler if a connected device is unplugged while reconnecting\", async () => {\n        // Get onTerminated for the first connection only\n        let onTerminated1 = vi.fn();\n        let tryToReconnect1 = vi.fn();\n        mockDeviceConnectionStateMachineFactory.mockImplementationOnce(\n          (params) => {\n            onTerminated1 = params.onTerminated;\n            tryToReconnect1 = params.tryToReconnect;\n            return {\n              ...mockDeviceConnectionStateMachine,\n              getDeviceId: vi.fn().mockReturnValue(params.deviceId),\n            } as unknown as DeviceConnectionStateMachine<{ device: HIDDevice }>;\n          },\n        );\n\n        // Add 2 discoverable devices\n        const hidDevice1 = hidDeviceStubBuilder();\n        const hidDevice2 = hidDeviceStubBuilder();\n        mockedRequestDevice.mockResolvedValueOnce([hidDevice1, hidDevice2]);\n        mockedGetDevices.mockResolvedValue([hidDevice1, hidDevice2]);\n\n        // Connect the 2 devices\n        const discoveredDevices = await lastValueFrom(\n          transport.startDiscovering().pipe(toArray()),\n        );\n        expect(discoveredDevices.length).toStrictEqual(2);\n        const onDisconnect1 = vi.fn();\n        const connected1 = await transport.connect({\n          deviceId: discoveredDevices[0]!.id,\n          onDisconnect: onDisconnect1,\n        });\n        const onDisconnect2 = vi.fn();\n        const connected2 = await transport.connect({\n          deviceId: discoveredDevices[1]!.id,\n          onDisconnect: onDisconnect2,\n        });\n        expect(connected1.isRight()).toStrictEqual(true);\n        expect(connected2.isRight()).toStrictEqual(true);\n\n        // Try to reconnect the first device\n        tryToReconnect1();\n\n        // unplug the first device\n        onTerminated1();\n        expect(onDisconnect1).toHaveBeenCalled();\n        expect(onDisconnect2).not.toHaveBeenCalled();\n      });\n    });\n\n    describe(\"reconnect\", () => {\n      it(\"should stop disconnection if reconnection happen\", () =>\n        new Promise<void>((resolve, reject) => {\n          // given\n          const onDisconnect = vi.fn();\n          let tryToReconnect = vi.fn();\n\n          const hidDevice1 = hidDeviceStubBuilder();\n          const hidDevice2 = hidDeviceStubBuilder();\n\n          mockedRequestDevice.mockResolvedValueOnce([hidDevice1]);\n          mockedGetDevices.mockResolvedValue([hidDevice1, hidDevice2]);\n          mockDeviceConnectionStateMachineFactory.mockImplementationOnce(\n            (params) => {\n              tryToReconnect = params.tryToReconnect;\n              return {\n                ...mockDeviceConnectionStateMachine,\n                getDeviceId: vi.fn().mockReturnValue(params.deviceId),\n                getDependencies: params.deviceApduSender.getDependencies,\n                setDependencies: params.deviceApduSender.setDependencies,\n              } as unknown as DeviceConnectionStateMachine<{\n                device: HIDDevice;\n              }>;\n            },\n          );\n\n          discoverDevice(async (discoveredDevice) => {\n            try {\n              await transport.connect({\n                deviceId: discoveredDevice.id,\n                onDisconnect,\n              });\n\n              /* Disconnection */\n              emitHIDDisconnectionEvent(hidDevice1);\n              expect(hidDevice1.close).toHaveBeenCalled();\n              await Promise.resolve(); // wait for the next tick so the hidDevice1.close promise is resolved\n              expect(mockEventDeviceDisconnected).toHaveBeenCalled();\n\n              tryToReconnect();\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT / 3);\n\n              /* Reconnection */\n              emitHIDConnectionEvent(hidDevice2);\n\n              await Promise.resolve(); // wait for the next tick so the hidDevice2.open promise is resolved\n              expect(mockEventDeviceConnected).toHaveBeenCalled();\n\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT);\n              expect(onDisconnect).not.toHaveBeenCalled();\n              resolve();\n            } catch (error) {\n              reject(error as Error);\n            }\n          });\n        }));\n\n      it(\"should be able to reconnect twice in a row if the device is unplugged and replugged twice\", () =>\n        new Promise<void>((resolve, reject) => {\n          // given\n          const onDisconnect = vi.fn();\n          let tryToReconnect = vi.fn();\n\n          const hidDevice1 = hidDeviceStubBuilder();\n          const hidDevice2 = hidDeviceStubBuilder();\n          const hidDevice3 = hidDeviceStubBuilder();\n\n          mockedRequestDevice.mockResolvedValueOnce([hidDevice1]);\n          mockedGetDevices.mockResolvedValue([\n            hidDevice1,\n            hidDevice2,\n            hidDevice3,\n          ]);\n          mockDeviceConnectionStateMachineFactory.mockImplementationOnce(\n            (params) => {\n              tryToReconnect = params.tryToReconnect;\n              return {\n                ...mockDeviceConnectionStateMachine,\n                getDeviceId: vi.fn().mockReturnValue(params.deviceId),\n                getDependencies: params.deviceApduSender.getDependencies,\n                setDependencies: params.deviceApduSender.setDependencies,\n              } as unknown as DeviceConnectionStateMachine<{\n                device: HIDDevice;\n              }>;\n            },\n          );\n\n          // when\n          discoverDevice(async (discoveredDevice) => {\n            await transport.connect({\n              deviceId: discoveredDevice.id,\n              onDisconnect,\n            });\n            try {\n              /* First disconnection */\n              emitHIDDisconnectionEvent(hidDevice1);\n              expect(hidDevice1.close).toHaveBeenCalled();\n              await Promise.resolve(); // wait for the next tick so the hidDevice1.close promise is resolved\n              expect(mockEventDeviceDisconnected).toHaveBeenCalled();\n              tryToReconnect();\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT / 3);\n\n              /* First reconnection */\n              emitHIDConnectionEvent(hidDevice2);\n\n              await Promise.resolve(); // wait for the next tick so the hidDevice2.open promise is resolved\n              expect(mockEventDeviceConnected).toHaveBeenCalled();\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT);\n              expect(onDisconnect).not.toHaveBeenCalled();\n\n              /* Second disconnection */\n              emitHIDDisconnectionEvent(hidDevice2);\n              expect(hidDevice2.close).toHaveBeenCalled();\n              await Promise.resolve(); // wait for the next tick so the hidDevice2.close promise is resolved\n              expect(mockEventDeviceDisconnected).toHaveBeenCalled();\n              tryToReconnect();\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT / 3);\n\n              /* Second reconnection */\n              emitHIDConnectionEvent(hidDevice3);\n\n              await Promise.resolve(); // wait for the next tick so the hidDevice3.open promise is resolved\n              expect(mockEventDeviceConnected).toHaveBeenCalled();\n              vi.advanceTimersByTime(RECONNECT_DEVICE_TIMEOUT);\n              expect(onDisconnect).not.toHaveBeenCalled();\n\n              resolve();\n            } catch (error) {\n              reject(error as Error);\n            }\n          });\n        }));\n    });\n\n    describe(\"Connection event typeguard\", () => {\n      it(\"should validate type of an HIDConnectionEvent\", () => {\n        // given\n        const event = {\n          device: stubDevice,\n        } as HIDConnectionEvent;\n        // when\n        // @ts-expect-error trying to access private member\n        const result = transport.isHIDConnectionEvent(event);\n        // then\n        expect(result).toBe(true);\n      });\n\n      it(\"should not validate type of another event\", () => {\n        // given\n        const event = new Event(\"disconnect\", {});\n        // when\n        // @ts-expect-error trying to access private member\n        const result = transport.isHIDConnectionEvent(event);\n        // then\n        expect(result).toBe(false);\n      });\n    });\n\n    describe(\"listenToAvailableDevices\", () => {\n      it(\"should emit the devices already connected before listening\", async () => {\n        // given\n        const hidDevice = hidDeviceStubBuilder();\n        mockedGetDevices.mockResolvedValue([hidDevice]);\n\n        const onComplete = vi.fn();\n        const onError = vi.fn();\n\n        let observedDevices: TransportDiscoveredDevice[] = [];\n        // when\n        transport.listenToAvailableDevices().subscribe({\n          next: (knownDevices) => {\n            observedDevices = knownDevices;\n          },\n          complete: onComplete,\n          error: onError,\n        });\n\n        await flushPromises();\n\n        expect(observedDevices).toEqual([\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.NANO_X,\n            }) as TransportDeviceModel,\n          }),\n        ]);\n        expect(onComplete).not.toHaveBeenCalled();\n        expect(onError).not.toHaveBeenCalled();\n      });\n\n      it(\"should emit the new list of devices after connection and disconnection events\", async () => {\n        initializeTransport();\n        // given\n        const hidDevice1 = hidDeviceStubBuilder({\n          productId:\n            usbDeviceModelDataSource.getDeviceModel({\n              id: DeviceModelId.NANO_X,\n            }).usbProductId << 8,\n        });\n        const hidDevice2 = hidDeviceStubBuilder({\n          productId:\n            usbDeviceModelDataSource.getDeviceModel({ id: DeviceModelId.STAX })\n              .usbProductId << 8,\n        });\n        mockedGetDevices.mockResolvedValue([hidDevice1]);\n\n        const onComplete = vi.fn();\n        const onError = vi.fn();\n\n        let observedDevices: TransportDiscoveredDevice[] = [];\n        // when\n        transport.listenToAvailableDevices().subscribe({\n          next: (knownDevices) => {\n            observedDevices = knownDevices;\n          },\n          complete: onComplete,\n          error: onError,\n        });\n\n        await flushPromises();\n\n        expect(observedDevices).toEqual([\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.NANO_X,\n            }) as TransportDeviceModel,\n          }),\n        ]);\n\n        // When a new device is connected\n        mockedGetDevices.mockResolvedValue([hidDevice1, hidDevice2]);\n        emitHIDConnectionEvent(hidDevice2);\n        await flushPromises();\n\n        expect(observedDevices).toEqual([\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.NANO_X,\n            }) as TransportDeviceModel,\n          }),\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.STAX,\n            }) as TransportDeviceModel,\n          }),\n        ]);\n\n        // When a device is disconnected\n        mockedGetDevices.mockResolvedValue([hidDevice2]);\n        emitHIDDisconnectionEvent(hidDevice1);\n        await flushPromises();\n\n        expect(observedDevices).toEqual([\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.STAX,\n            }) as TransportDeviceModel,\n          }),\n        ]);\n\n        expect(onComplete).not.toHaveBeenCalled();\n        expect(onError).not.toHaveBeenCalled();\n      });\n\n      it(\"should preserve DeviceId in case the device has been disconnected and reconnected before the timeout\", async () => {\n        // given\n        const hidDevice = hidDeviceStubBuilder();\n\n        mockedGetDevices.mockResolvedValue([hidDevice]);\n\n        const onComplete = vi.fn();\n        const onError = vi.fn();\n        let observedDevices: TransportDiscoveredDevice[] = [];\n        // when\n        transport.listenToAvailableDevices().subscribe({\n          next: (knownDevices) => {\n            observedDevices = knownDevices;\n          },\n          complete: onComplete,\n          error: onError,\n        });\n\n        await flushPromises();\n\n        const firstObservedDeviceId = observedDevices[0]?.id;\n        expect(firstObservedDeviceId).toBeTruthy();\n        expect(observedDevices[0]?.deviceModel?.id).toBe(DeviceModelId.NANO_X);\n\n        // Start a connection with the device\n        await transport.connect({\n          deviceId: observedDevices[0]!.id,\n          onDisconnect: vi.fn(),\n        });\n        await flushPromises();\n\n        // When the device is disconnected\n        mockedGetDevices.mockResolvedValue([]);\n        emitHIDDisconnectionEvent(hidDevice);\n        await flushPromises();\n\n        expect(observedDevices).toEqual([]);\n\n        // When the device is reconnected\n        mockedGetDevices.mockResolvedValue([hidDevice]);\n        emitHIDConnectionEvent(hidDevice);\n        await flushPromises();\n\n        expect(observedDevices).toEqual([\n          expect.objectContaining({\n            deviceModel: expect.objectContaining({\n              id: DeviceModelId.NANO_X,\n            }) as TransportDeviceModel,\n          }),\n        ]);\n\n        expect(observedDevices[0]?.id).toBeTruthy();\n        expect(observedDevices[0]?.id).toBe(firstObservedDeviceId);\n      });\n    });\n  });\n});\n"],
  "mappings": "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",
  "names": ["connectedDeviceStubBuilder", "DeviceModelId", "DeviceNotRecognizedError", "NoAccessibleDeviceError", "OpeningConnectionError", "StaticDeviceModelDataSource", "UnknownDeviceError", "Left", "Right", "lastValueFrom", "Subject", "toArray", "RECONNECT_DEVICE_TIMEOUT", "WebHidTransportNotSupportedError", "hidDeviceStubBuilder", "WebHidTransport", "LoggerPublisherServiceStub", "subscribers", "tag", "usbDeviceModelDataSource", "logger", "stubDevice", "flushPromises", "timers", "transport", "apduReceiverServiceFactoryStub", "apduSenderServiceFactoryStub", "mockDeviceConnectionStateMachineFactory", "mockEventDeviceConnected", "mockEventDeviceDisconnected", "mockDeviceApduSender", "mockDeviceConnectionStateMachine", "initializeTransport", "params", "mockDeviceApduSenderFactory", "dependencies", "discoverDevice", "onSuccess", "onError", "resolve", "reject", "error", "mockedGetDevices", "mockedRequestDevice", "connectionEventsSubject", "disconnectionEventsSubject", "emitHIDConnectionEvent", "device", "emitHIDDisconnectionEvent", "eventName", "callback", "deviceModel", "testCase", "discoveredDevice", "expectError", "count", "message", "firstDiscoveredDevice", "err", "secondDiscoveredDevice", "abortSpy", "connectParams", "connect", "connected", "connectedDevice", "disconnect", "result", "onTerminated1", "hidDevice1", "hidDevice2", "discoveredDevices", "onDisconnect1", "connected1", "onDisconnect2", "connected2", "tryToReconnect1", "onDisconnect", "tryToReconnect", "hidDevice3", "event", "hidDevice", "onComplete", "observedDevices", "knownDevices", "firstObservedDeviceId"]
}
