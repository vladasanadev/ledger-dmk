{
  "version": 3,
  "sources": ["../../../../src/api/transport/WebHidTransport.ts"],
  "sourcesContent": ["import {\n  type ApduReceiverServiceFactory,\n  type ApduSenderServiceFactory,\n  type ConnectError,\n  type ConnectionType,\n  DeviceConnectionStateMachine,\n  type DeviceConnectionStateMachineParams,\n  type DeviceId,\n  type DeviceModelDataSource,\n  DeviceNotRecognizedError,\n  type DisconnectHandler,\n  type DmkError,\n  LEDGER_VENDOR_ID,\n  type LoggerPublisherService,\n  NoAccessibleDeviceError,\n  OpeningConnectionError,\n  type Transport,\n  TransportConnectedDevice,\n  type TransportDeviceModel,\n  type TransportDiscoveredDevice,\n  type TransportFactory,\n  type TransportIdentifier,\n  UnknownDeviceError,\n} from \"@ledgerhq/device-management-kit\";\nimport * as Sentry from \"@sentry/minimal\";\nimport { type Either, EitherAsync, Left, Maybe, Right } from \"purify-ts\";\nimport { BehaviorSubject, from, map, type Observable, switchMap } from \"rxjs\";\nimport { v4 as uuid } from \"uuid\";\n\nimport { RECONNECT_DEVICE_TIMEOUT } from \"@api/data/WebHidConfig\";\nimport { WebHidTransportNotSupportedError } from \"@api/model/Errors\";\n\nimport {\n  WebHidApduSender,\n  type WebHidApduSenderConstructorArgs,\n  type WebHidApduSenderDependencies,\n} from \"./WebHidApduSender\";\n\ntype PromptDeviceAccessError =\n  | NoAccessibleDeviceError\n  | WebHidTransportNotSupportedError;\n\ntype WebHidTransportDiscoveredDevice = TransportDiscoveredDevice & {\n  hidDevice: HIDDevice;\n};\n\nexport const webHidIdentifier: TransportIdentifier = \"WEB-HID\";\n\nexport class WebHidTransport implements Transport {\n  /** List of HID devices that have been discovered */\n  private _transportDiscoveredDevices: BehaviorSubject<\n    Array<WebHidTransportDiscoveredDevice>\n  > = new BehaviorSubject<Array<WebHidTransportDiscoveredDevice>>([]);\n\n  /** Map of *connected* HIDDevice to their device connection */\n  private _deviceConnectionsByHidDevice: Map<\n    HIDDevice,\n    DeviceConnectionStateMachine<WebHidApduSenderDependencies>\n  > = new Map();\n\n  /**\n   * Set of device connections for which the HIDDevice has been\n   * disconnected, so they are waiting for a reconnection\n   */\n  private _deviceConnectionsPendingReconnection: Set<\n    DeviceConnectionStateMachine<WebHidApduSenderDependencies>\n  > = new Set();\n\n  /** AbortController to stop listening to HID connection events */\n  private _connectionListenersAbortController: AbortController =\n    new AbortController();\n  private _logger: LoggerPublisherService;\n  private readonly connectionType: ConnectionType = \"USB\";\n  private readonly identifier: TransportIdentifier = webHidIdentifier;\n\n  constructor(\n    private readonly _deviceModelDataSource: DeviceModelDataSource,\n    private readonly _loggerServiceFactory: (\n      tag: string,\n    ) => LoggerPublisherService,\n    private readonly _apduSenderFactory: ApduSenderServiceFactory,\n    private readonly _apduReceiverFactory: ApduReceiverServiceFactory,\n    private readonly _deviceConnectionStateMachineFactory: (\n      args: DeviceConnectionStateMachineParams<WebHidApduSenderDependencies>,\n    ) => DeviceConnectionStateMachine<WebHidApduSenderDependencies> = (args) =>\n      new DeviceConnectionStateMachine(args),\n    private readonly _deviceApduSenderFactory: (\n      args: WebHidApduSenderConstructorArgs,\n      loggerFactory: (tag: string) => LoggerPublisherService,\n    ) => WebHidApduSender = (args, loggerFactory) =>\n      new WebHidApduSender(args, loggerFactory),\n  ) {\n    this._logger = _loggerServiceFactory(\"WebWebHidTransport\");\n\n    this.startListeningToConnectionEvents();\n  }\n\n  /**\n   * Get the WebHID API if supported or error\n   * @returns `Either<WebHidTransportNotSupportedError, HID>`\n   */\n  private get hidApi(): Either<WebHidTransportNotSupportedError, HID> {\n    if (this.isSupported()) {\n      return Right(navigator.hid);\n    }\n\n    return Left(new WebHidTransportNotSupportedError(\"WebHID not supported\"));\n  }\n\n  isSupported() {\n    try {\n      const result = !!navigator?.hid;\n      this._logger.debug(`isSupported: ${result}`);\n      return result;\n    } catch (error) {\n      this._logger.error(`isSupported: error`, { data: { error } });\n      return false;\n    }\n  }\n\n  getIdentifier(): TransportIdentifier {\n    return this.identifier;\n  }\n\n  /**\n   * Wrapper around `navigator.hid.getDevices()`.\n   * It will return the list of plugged in HID devices to which the user has\n   * previously granted access through `navigator.hid.requestDevice()`.\n   */\n  private async getDevices(): Promise<Either<DmkError, HIDDevice[]>> {\n    return EitherAsync.liftEither(this.hidApi).map(async (hidApi) => {\n      try {\n        const allDevices = await hidApi.getDevices();\n\n        return allDevices.filter(\n          (hidDevice) => hidDevice.vendorId === LEDGER_VENDOR_ID,\n        );\n      } catch (error) {\n        const deviceError = new NoAccessibleDeviceError(error);\n        this._logger.error(`getDevices: error getting devices`, {\n          data: { error },\n        });\n        Sentry.captureException(deviceError);\n        throw deviceError;\n      }\n    });\n  }\n\n  /**\n   * Map a HIDDevice to an TransportDiscoveredDevice, either by creating a new one or returning an existing one\n   */\n  private mapHIDDeviceToTransportDiscoveredDevice(\n    hidDevice: HIDDevice,\n  ): WebHidTransportDiscoveredDevice {\n    const existingDiscoveredDevice = this._transportDiscoveredDevices\n      .getValue()\n      .find((internalDevice) => internalDevice.hidDevice === hidDevice);\n\n    if (existingDiscoveredDevice) {\n      return existingDiscoveredDevice;\n    }\n\n    const existingDeviceConnection =\n      this._deviceConnectionsByHidDevice.get(hidDevice);\n\n    const maybeDeviceModel = this.getDeviceModel(hidDevice);\n    return maybeDeviceModel.caseOf({\n      Just: (deviceModel) => {\n        const id = existingDeviceConnection?.getDeviceId() ?? uuid();\n\n        const discoveredDevice = {\n          id,\n          deviceModel,\n          hidDevice,\n          transport: this.identifier,\n        };\n\n        this._logger.debug(\n          `Discovered device ${id} ${discoveredDevice.deviceModel.productName}`,\n        );\n\n        return discoveredDevice;\n      },\n      Nothing: () => {\n        // [ASK] Or we just ignore the not recognized device ? And log them\n        this._logger.warn(\n          `Device not recognized: hidDevice.productId: 0x${hidDevice.productId.toString(16)}`,\n        );\n        throw new DeviceNotRecognizedError(\n          `Device not recognized: hidDevice.productId: 0x${hidDevice.productId.toString(16)}`,\n        );\n      },\n    });\n  }\n\n  /**\n   * Listen to known devices (devices to which the user has granted access)\n   */\n  public listenToAvailableDevices(): Observable<TransportDiscoveredDevice[]> {\n    this.updateTransportDiscoveredDevices();\n    return this._transportDiscoveredDevices.pipe(\n      map((devices) => devices.map(({ hidDevice, ...device }) => device)),\n    );\n  }\n\n  private async updateTransportDiscoveredDevices(): Promise<void> {\n    const eitherDevices = await this.getDevices();\n\n    eitherDevices.caseOf({\n      Left: (error) => {\n        this._logger.error(\"Error while getting accessible device\", {\n          data: { error },\n        });\n        Sentry.captureException(error);\n      },\n      Right: (hidDevices) => {\n        this._transportDiscoveredDevices.next(\n          hidDevices.map((hidDevice) =>\n            this.mapHIDDeviceToTransportDiscoveredDevice(hidDevice),\n          ),\n        );\n      },\n    });\n  }\n\n  /**\n   * Wrapper around navigator.hid.requestDevice()\n   * In a browser, it will show a native dialog to select a HID device.\n   */\n  private async promptDeviceAccess(): Promise<\n    Either<PromptDeviceAccessError, HIDDevice[]>\n  > {\n    return EitherAsync.liftEither(this.hidApi)\n      .map(async (hidApi) => {\n        // `requestDevice` returns an array. but normally the user can select only one device at a time.\n        let hidDevices: HIDDevice[] = [];\n\n        try {\n          hidDevices = await hidApi.requestDevice({\n            filters: [{ vendorId: LEDGER_VENDOR_ID }],\n          });\n          await this.updateTransportDiscoveredDevices();\n        } catch (error) {\n          const deviceError = new NoAccessibleDeviceError(error);\n          this._logger.error(`promptDeviceAccess: error requesting device`, {\n            data: { error },\n          });\n          Sentry.captureException(deviceError);\n          throw deviceError;\n        }\n\n        this._logger.debug(\n          `promptDeviceAccess: hidDevices len ${hidDevices.length}`,\n        );\n\n        // Granted access to 0 device (by clicking on cancel for ex) results in an error\n        if (hidDevices.length === 0) {\n          this._logger.warn(\"No device was selected\");\n          throw new NoAccessibleDeviceError(\"No selected device\");\n        }\n\n        const discoveredHidDevices: HIDDevice[] = [];\n\n        for (const hidDevice of hidDevices) {\n          discoveredHidDevices.push(hidDevice);\n\n          this._logger.debug(`promptDeviceAccess: selected device`, {\n            data: { hidDevice },\n          });\n        }\n\n        return discoveredHidDevices;\n      })\n      .run();\n  }\n\n  startDiscovering(): Observable<TransportDiscoveredDevice> {\n    this._logger.debug(\"startDiscovering\");\n\n    return from(this.promptDeviceAccess()).pipe(\n      switchMap((either) => {\n        return either.caseOf({\n          Left: (error) => {\n            this._logger.error(\"Error while getting accessible device\", {\n              data: { error },\n            });\n            Sentry.captureException(error);\n            throw error;\n          },\n          Right: (hidDevices) => {\n            this._logger.info(`Got access to ${hidDevices.length} HID devices`);\n\n            const discoveredDevices = hidDevices.map((hidDevice) => {\n              return this.mapHIDDeviceToTransportDiscoveredDevice(hidDevice);\n            });\n\n            return from(discoveredDevices);\n          },\n        });\n      }),\n    );\n  }\n\n  stopDiscovering(): void {\n    /**\n     * This does nothing because the startDiscovering method is just a\n     * promise wrapped into an observable. So there is no need to stop it.\n     */\n  }\n\n  private startListeningToConnectionEvents(): void {\n    this._logger.debug(\"startListeningToConnectionEvents\");\n\n    this.hidApi.map((hidApi) => {\n      hidApi.addEventListener(\n        \"connect\",\n        (event) => this.handleDeviceConnectionEvent(event),\n        { signal: this._connectionListenersAbortController.signal },\n      );\n\n      hidApi.addEventListener(\n        \"disconnect\",\n        (event) => this.handleDeviceDisconnectionEvent(event),\n        { signal: this._connectionListenersAbortController.signal },\n      );\n    });\n  }\n\n  private stopListeningToConnectionEvents(): void {\n    this._logger.debug(\"stopListeningToConnectionEvents\");\n    this._connectionListenersAbortController.abort();\n  }\n\n  /**\n   * Connect to a HID USB device and update the internal state of the associated device\n   */\n  async connect({\n    deviceId,\n    onDisconnect,\n  }: {\n    deviceId: DeviceId;\n    onDisconnect: DisconnectHandler;\n  }): Promise<Either<ConnectError, TransportConnectedDevice>> {\n    this._logger.debug(\"connect\", { data: { deviceId } });\n\n    const matchingInternalDevice = this._transportDiscoveredDevices\n      .getValue()\n      .find((internalDevice) => internalDevice.id === deviceId);\n\n    if (!matchingInternalDevice) {\n      this._logger.error(`Unknown device ${deviceId}`);\n      return Left(new UnknownDeviceError(`Unknown device ${deviceId}`));\n    }\n\n    const { deviceModel } = matchingInternalDevice;\n    const existing = this._deviceConnectionsByHidDevice.get(\n      matchingInternalDevice.hidDevice,\n    );\n    if (existing) {\n      return Right(\n        new TransportConnectedDevice({\n          id: deviceId,\n          deviceModel,\n          type: this.connectionType,\n          sendApdu: (...args) => existing.sendApdu(...args),\n          transport: this.identifier,\n        }),\n      );\n    }\n\n    const deviceApduSender = this._deviceApduSenderFactory(\n      {\n        apduSenderFactory: this._apduSenderFactory,\n        apduReceiverFactory: this._apduReceiverFactory,\n        dependencies: { device: matchingInternalDevice.hidDevice },\n      },\n      this._loggerServiceFactory,\n    );\n    const deviceConnectionStateMachine =\n      this._deviceConnectionStateMachineFactory({\n        deviceId,\n        deviceApduSender,\n        timeoutDuration: RECONNECT_DEVICE_TIMEOUT,\n        tryToReconnect: () => {\n          this._deviceConnectionsByHidDevice.forEach(\n            (deviceConnection, hidDevice) => {\n              if (deviceConnection.getDeviceId() === deviceId) {\n                this._deviceConnectionsPendingReconnection.add(\n                  deviceConnection,\n                );\n                this._deviceConnectionsByHidDevice.delete(hidDevice);\n              }\n            },\n          );\n        },\n        onTerminated: () => {\n          this._deviceConnectionsPendingReconnection.forEach(\n            (deviceConnection) => {\n              if (deviceConnection.getDeviceId() === deviceId) {\n                this._deviceConnectionsPendingReconnection.delete(\n                  deviceConnection,\n                );\n                onDisconnect(deviceConnection.getDeviceId());\n              }\n            },\n          );\n          this._deviceConnectionsByHidDevice.forEach(\n            (deviceConnection, hidDevice) => {\n              if (deviceConnection.getDeviceId() === deviceId) {\n                this._deviceConnectionsByHidDevice.delete(hidDevice);\n                onDisconnect(deviceConnection.getDeviceId());\n              }\n            },\n          );\n        },\n      });\n\n    try {\n      await deviceApduSender.setupConnection();\n    } catch (error) {\n      if (error instanceof OpeningConnectionError) {\n        return Left(error);\n      }\n      // Should not happen\n      return Left(new OpeningConnectionError(error));\n    }\n\n    this._deviceConnectionsByHidDevice.set(\n      matchingInternalDevice.hidDevice,\n      deviceConnectionStateMachine,\n    );\n\n    const connectedDevice = new TransportConnectedDevice({\n      sendApdu: (...args) => deviceConnectionStateMachine.sendApdu(...args),\n      deviceModel,\n      id: deviceId,\n      type: this.connectionType,\n      transport: this.identifier,\n    });\n\n    return Right(connectedDevice);\n  }\n\n  private getDeviceModel(hidDevice: HIDDevice): Maybe<TransportDeviceModel> {\n    const { productId } = hidDevice;\n    const matchingModel = this._deviceModelDataSource.getAllDeviceModels().find(\n      (deviceModel) =>\n        // outside of bootloader mode, the value that we need to identify a device model is the first byte of the actual hidDevice.productId\n        deviceModel.usbProductId === productId >> 8 ||\n        deviceModel.bootloaderUsbProductId === productId,\n    );\n    return matchingModel ? Maybe.of(matchingModel) : Maybe.zero();\n  }\n\n  private getHidUsbProductId(hidDevice: HIDDevice): number {\n    return this.getDeviceModel(hidDevice).caseOf({\n      Just: (deviceModel) => deviceModel.usbProductId,\n      Nothing: () => hidDevice.productId >> 8,\n    });\n  }\n\n  /**\n   * Disconnect from a HID USB device\n   */\n  async disconnect(params: {\n    connectedDevice: TransportConnectedDevice;\n  }): Promise<Either<DmkError, void>> {\n    this._logger.debug(\"disconnect\", { data: { connectedDevice: params } });\n\n    const matchingDeviceConnection = Array.from(\n      this._deviceConnectionsByHidDevice.values(),\n    ).find(\n      (deviceConnection) =>\n        deviceConnection.getDeviceId() === params.connectedDevice.id,\n    );\n\n    if (!matchingDeviceConnection) {\n      this._logger.error(\"No matching device connection found\", {\n        data: { connectedDevice: params },\n      });\n      return Promise.resolve(\n        Left(\n          new UnknownDeviceError(`Unknown device ${params.connectedDevice.id}`),\n        ),\n      );\n    }\n\n    matchingDeviceConnection.closeConnection();\n    return Promise.resolve(Right(undefined));\n  }\n\n  /**\n   * Type guard to check if the event is a HID connection event\n   * @param event\n   * @private\n   */\n  private isHIDConnectionEvent(event: Event): event is HIDConnectionEvent {\n    return (\n      \"device\" in event &&\n      typeof event.device === \"object\" &&\n      event.device !== null &&\n      \"productId\" in event.device &&\n      typeof event.device.productId === \"number\"\n    );\n  }\n\n  /**\n   * Handle the disconnection event of a HID device\n   * @param event\n   */\n  private async handleDeviceDisconnectionEvent(event: Event) {\n    if (!this.isHIDConnectionEvent(event)) {\n      this._logger.error(\"Invalid event\", { data: { event } });\n      return;\n    }\n\n    this._logger.info(\"[handleDeviceDisconnectionEvent] Device disconnected\", {\n      data: { event },\n    });\n\n    this.updateTransportDiscoveredDevices();\n\n    try {\n      await event.device.close();\n    } catch (error) {\n      this._logger.error(\"Error while closing device \", {\n        data: { event, error },\n      });\n    }\n\n    const matchingDeviceConnection = this._deviceConnectionsByHidDevice.get(\n      event.device,\n    );\n\n    if (matchingDeviceConnection) {\n      matchingDeviceConnection.eventDeviceDisconnected();\n    }\n  }\n\n  private async handleDeviceReconnection(\n    deviceConnection: DeviceConnectionStateMachine<WebHidApduSenderDependencies>,\n    hidDevice: HIDDevice,\n  ) {\n    this._deviceConnectionsPendingReconnection.delete(deviceConnection);\n    this._deviceConnectionsByHidDevice.set(hidDevice, deviceConnection);\n\n    try {\n      deviceConnection.setDependencies({\n        device: hidDevice,\n      });\n      await deviceConnection.setupConnection();\n      deviceConnection.eventDeviceConnected();\n    } catch (error) {\n      this._logger.error(\"Error while reconnecting to device\", {\n        data: { event, error },\n      });\n      deviceConnection.closeConnection();\n    }\n  }\n\n  /**\n   * Handle the connection event of a HID device\n   * @param event\n   */\n  private async handleDeviceConnectionEvent(event: Event) {\n    if (!this.isHIDConnectionEvent(event)) {\n      this._logger.error(\"Invalid event\", { data: { event } });\n      return;\n    }\n\n    this._logger.info(\"[handleDeviceConnectionEvent] Device connected\", {\n      data: { event },\n    });\n\n    const matchingDeviceConnection = Array.from(\n      this._deviceConnectionsPendingReconnection,\n    ).find(\n      (deviceConnection) =>\n        this.getHidUsbProductId(deviceConnection.getDependencies().device) ===\n        this.getHidUsbProductId(event.device),\n    );\n\n    if (matchingDeviceConnection) {\n      await this.handleDeviceReconnection(\n        matchingDeviceConnection,\n        event.device,\n      );\n    }\n\n    /**\n     * Note: we do this after handling the reconnection to allow the newly\n     * discovered device to keep the same DeviceId as the previous one in case\n     * of a reconnection.\n     */\n    this.updateTransportDiscoveredDevices();\n  }\n\n  public destroy() {\n    this.stopListeningToConnectionEvents();\n    this._deviceConnectionsByHidDevice.forEach((connection) => {\n      connection.closeConnection();\n    });\n    this._deviceConnectionsPendingReconnection.clear();\n  }\n}\n\nexport const webHidTransportFactory: TransportFactory = ({\n  deviceModelDataSource,\n  loggerServiceFactory,\n  apduSenderServiceFactory,\n  apduReceiverServiceFactory,\n}) =>\n  new WebHidTransport(\n    deviceModelDataSource,\n    loggerServiceFactory,\n    apduSenderServiceFactory,\n    apduReceiverServiceFactory,\n  );\n"],
  "mappings": "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",
  "names": ["DeviceConnectionStateMachine", "DeviceNotRecognizedError", "LEDGER_VENDOR_ID", "NoAccessibleDeviceError", "OpeningConnectionError", "TransportConnectedDevice", "UnknownDeviceError", "Sentry", "EitherAsync", "Left", "Maybe", "Right", "BehaviorSubject", "from", "map", "switchMap", "uuid", "RECONNECT_DEVICE_TIMEOUT", "WebHidTransportNotSupportedError", "WebHidApduSender", "webHidIdentifier", "WebHidTransport", "_deviceModelDataSource", "_loggerServiceFactory", "_apduSenderFactory", "_apduReceiverFactory", "_deviceConnectionStateMachineFactory", "args", "_deviceApduSenderFactory", "loggerFactory", "result", "error", "hidApi", "hidDevice", "deviceError", "existingDiscoveredDevice", "internalDevice", "existingDeviceConnection", "deviceModel", "id", "discoveredDevice", "devices", "device", "hidDevices", "discoveredHidDevices", "either", "discoveredDevices", "event", "deviceId", "onDisconnect", "matchingInternalDevice", "existing", "deviceApduSender", "deviceConnectionStateMachine", "deviceConnection", "connectedDevice", "productId", "matchingModel", "params", "matchingDeviceConnection", "connection", "webHidTransportFactory", "deviceModelDataSource", "loggerServiceFactory", "apduSenderServiceFactory", "apduReceiverServiceFactory"]
}
