{
  "version": 3,
  "sources": ["../../../../src/api/transport/WebHidApduSender.ts"],
  "sourcesContent": ["import {\n  type ApduReceiverService,\n  type ApduReceiverServiceFactory,\n  type ApduResponse,\n  type ApduSenderService,\n  type ApduSenderServiceFactory,\n  type DeviceApduSender,\n  type DmkError,\n  FramerUtils,\n  type LoggerPublisherService,\n  OpeningConnectionError,\n  SendApduTimeoutError,\n} from \"@ledgerhq/device-management-kit\";\nimport * as Sentry from \"@sentry/minimal\";\nimport { type Either, Left, Maybe, Nothing, Right } from \"purify-ts\";\n\nimport { FRAME_SIZE } from \"@api/data/WebHidConfig\";\nimport { WebHidSendReportError } from \"@api/model/Errors\";\n\nexport type WebHidApduSenderConstructorArgs = {\n  dependencies: WebHidApduSenderDependencies;\n  apduSenderFactory: ApduSenderServiceFactory;\n  apduReceiverFactory: ApduReceiverServiceFactory;\n};\n\nexport type WebHidApduSenderDependencies = {\n  device: HIDDevice;\n};\n\nexport class WebHidApduSender\n  implements DeviceApduSender<WebHidApduSenderDependencies>\n{\n  private dependencies: WebHidApduSenderDependencies;\n  private readonly apduSender: ApduSenderService;\n  private readonly apduReceiver: ApduReceiverService;\n  private sendApduPromiseResolver: Maybe<\n    (value: Either<DmkError, ApduResponse>) => void\n  >;\n  private readonly logger: LoggerPublisherService;\n\n  constructor(\n    {\n      dependencies,\n      apduSenderFactory,\n      apduReceiverFactory,\n    }: WebHidApduSenderConstructorArgs,\n    loggerServiceFactory: (tag: string) => LoggerPublisherService,\n  ) {\n    const channel = Maybe.of(\n      FramerUtils.numberToByteArray(Math.floor(Math.random() * 0xffff), 2),\n    );\n    this.logger = loggerServiceFactory(\"WebHidApduSender\");\n    this.apduSender = apduSenderFactory({\n      frameSize: FRAME_SIZE,\n      channel,\n      padding: true,\n    });\n    this.apduReceiver = apduReceiverFactory({ channel });\n    this.sendApduPromiseResolver = Nothing;\n    this.dependencies = dependencies;\n    this.logger.info(\"\uD83D\uDD0C Connected to device\");\n  }\n\n  async sendApdu(\n    apdu: Uint8Array,\n    _triggersDisconnection?: boolean,\n    abortTimeout?: number,\n  ): Promise<Either<DmkError, ApduResponse>> {\n    let timeout: ReturnType<typeof setTimeout> | undefined;\n\n    const resultPromise = new Promise<Either<DmkError, ApduResponse>>(\n      (resolve) => {\n        this.sendApduPromiseResolver = Maybe.of((...args) => {\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n          return resolve(...args);\n        });\n      },\n    );\n\n    for (const frame of this.apduSender.getFrames(apdu)) {\n      try {\n        await this.dependencies.device.sendReport(\n          0,\n          new Uint8Array(frame.getRawData()),\n        );\n      } catch (error) {\n        this.logger.info(\"Error sending frame\", { data: { error } });\n        return Promise.resolve(Left(new WebHidSendReportError(error)));\n      }\n    }\n\n    if (abortTimeout) {\n      timeout = setTimeout(() => {\n        this.logger.debug(\"[sendApdu] Abort timeout\", {\n          data: { abortTimeout },\n        });\n        this.sendApduPromiseResolver.map((resolve) =>\n          resolve(Left(new SendApduTimeoutError(\"Abort timeout\"))),\n        );\n      }, abortTimeout);\n    }\n\n    return resultPromise;\n  }\n\n  private receiveHidInputReport(event: HIDInputReportEvent) {\n    const data = new Uint8Array(event.data.buffer);\n    const maybeApduResponse = this.apduReceiver.handleFrame(data);\n\n    maybeApduResponse\n      .map((response) => {\n        response.map((apduResponse) => {\n          this.sendApduPromiseResolver.map((resolve) =>\n            resolve(Right(apduResponse)),\n          );\n        });\n      })\n      .mapLeft((error) => {\n        this.sendApduPromiseResolver.map((resolve) => resolve(Left(error)));\n      });\n  }\n\n  public getDependencies() {\n    return this.dependencies;\n  }\n\n  public setDependencies(dependencies: WebHidApduSenderDependencies) {\n    this.dependencies = dependencies;\n  }\n\n  public async setupConnection() {\n    try {\n      this.dependencies.device.oninputreport = (event) =>\n        this.receiveHidInputReport(event);\n      await this.dependencies.device.open();\n    } catch (error) {\n      if (error instanceof DOMException && error.name === \"InvalidStateError\") {\n        this.logger.info(`Device is already opened`);\n      } else {\n        const connectionError = new OpeningConnectionError(error);\n        this.logger.error(`Error while opening device`, {\n          data: { error },\n        });\n        Sentry.captureException(connectionError);\n        throw error;\n      }\n    }\n  }\n\n  public closeConnection() {\n    this.logger.info(\"\uD83D\uDD1A Disconnect\");\n    try {\n      this.dependencies.device.close();\n    } catch (error) {\n      this.logger.error(\"Error while closing device\", {\n        data: { device: this.dependencies.device, error },\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["FramerUtils", "OpeningConnectionError", "SendApduTimeoutError", "Sentry", "Left", "Maybe", "Nothing", "Right", "FRAME_SIZE", "WebHidSendReportError", "WebHidApduSender", "dependencies", "apduSenderFactory", "apduReceiverFactory", "loggerServiceFactory", "channel", "apdu", "_triggersDisconnection", "abortTimeout", "timeout", "resultPromise", "resolve", "args", "frame", "error", "event", "data", "response", "apduResponse", "connectionError"]
}
