import{connectedDeviceStubBuilder as L,DeviceModelId as p,DeviceNotRecognizedError as X,NoAccessibleDeviceError as A,OpeningConnectionError as O,StaticDeviceModelDataSource as F,UnknownDeviceError as P}from"@ledgerhq/device-management-kit";import{Left as B,Right as V}from"purify-ts";import{lastValueFrom as b,Subject as q,toArray as j}from"rxjs";import{RECONNECT_DEVICE_TIMEOUT as x}from"../data/WebHidConfig";import{WebHidTransportNotSupportedError as W}from"../model/Errors";import{hidDeviceStubBuilder as v}from"../model/HIDDevice.stub";import{WebHidTransport as _}from"./WebHidTransport";class U{constructor(S,E){this.subscribers=S,this.tag=E}subscribers=[];tag="";error=vi.fn();warn=vi.fn();info=vi.fn();debug=vi.fn()}const R=new F,z=new U([],"web-usb-hid"),a=v(),m=async()=>{const i=await vi.importActual("timers");return new Promise(i.setImmediate)};describe("WebHidTransport",()=>{let i,S,E,h=vi.fn();const k=vi.fn(),y=vi.fn(),M={sendApdu:vi.fn().mockResolvedValue(V({data:new Uint8Array})),getDependencies:vi.fn().mockReturnValue({device:a}),setDependencies:vi.fn(),closeConnection:vi.fn(),setupConnection:vi.fn()},w={getDependencies:vi.fn().mockReturnValue({device:a}),setDependencies:vi.fn(),getDeviceId:vi.fn(),sendApdu:vi.fn().mockResolvedValue(V({data:new Uint8Array})),setupConnection:vi.fn(),eventDeviceConnected:k,eventDeviceDisconnected:y,closeConnection:vi.fn()};function T(){S=vi.fn(),E=vi.fn(),h=vi.fn(s=>({...w,getDeviceId:vi.fn().mockReturnValue(s.deviceId),getDependencies:s.deviceApduSender.getDependencies,setDependencies:s.deviceApduSender.setDependencies}));const d=vi.fn(s=>({...M,getDependencies:()=>s.dependencies,setDependencies:f=>s.dependencies=f}));i=new _(R,()=>z,E,S,h,d)}beforeEach(()=>{T(),vi.useFakeTimers()}),afterEach(()=>{vi.restoreAllMocks()});const D=(d,s)=>{i.startDiscovering().subscribe({next:d,error:s})};describe("When WebHID API is not supported",()=>{it("should not support the transport",()=>{expect(i.isSupported()).toBe(!1)}),it("should emit a startDiscovering error",()=>new Promise((d,s)=>{D(()=>{s("Should not emit any value")},f=>{expect(f).toBeInstanceOf(W),d()})}))}),describe("When WebHID API is supported",()=>{const d=vi.fn(),s=vi.fn(),f=new q,N=new q;function C(t){f.next({device:t})}function I(t){N.next({device:t})}beforeEach(()=>{global.navigator={hid:{getDevices:d,requestDevice:s,addEventListener:(t,e)=>{t==="disconnect"?N.subscribe(e):t==="connect"&&f.subscribe(e)}}},T()}),afterEach(()=>{vi.clearAllMocks(),global.navigator=void 0}),it("should support the transport",()=>{expect(i.isSupported()).toBe(!0)}),describe("startDiscovering",()=>{R.getAllDeviceModels().flatMap(e=>[{testTitle:`should emit device if user grants access through hid.requestDevice (${e.productName})`,hidDevice:v({productId:e.usbProductId<<8,productName:e.productName}),expectedDeviceModel:e},{testTitle:`should emit device if user grants access through hid.requestDevice (${e.productName}, bootloader)`,hidDevice:v({productId:e.bootloaderUsbProductId,productName:e.productName}),expectedDeviceModel:e}]).forEach(e=>{it(e.testTitle,()=>new Promise((o,n)=>{s.mockResolvedValueOnce([e.hidDevice]),D(c=>{try{expect(c).toEqual(expect.objectContaining({deviceModel:e.expectedDeviceModel})),o()}catch(r){n(r)}},c=>{n(c)})}))}),it("should emit devices if new grant accesses",()=>new Promise((e,o)=>{s.mockResolvedValueOnce([a,{...a,productId:20497,productName:"Ledger Nano S Plus"}]);let n=0;D(c=>{try{switch(n){case 0:expect(c).toEqual(expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_X,productName:"Ledger Nano X",usbProductId:64})}));break;case 1:expect(c).toEqual(expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_SP,productName:"Ledger Nano S Plus",usbProductId:80})})),e();break}n++}catch(r){o(r)}},c=>{o(c)})})),it("should throw DeviceNotRecognizedError if the device is not recognized",()=>new Promise((e,o)=>{s.mockResolvedValueOnce([{...a,productId:16962}]),D(()=>{o("should not return a device")},n=>{expect(n).toBeInstanceOf(X),e()})})),it("should emit an error if the request device is in error",()=>new Promise((e,o)=>{const n="request device error";s.mockImplementationOnce(()=>{throw new Error(n)}),D(()=>{o("should not return a device")},c=>{expect(c).toBeInstanceOf(A),expect(c).toStrictEqual(new A(new Error(n))),e()})})),it("should emit an error if the user did not grant us access to a device (clicking on cancel on the browser popup for ex)",()=>new Promise((e,o)=>{s.mockResolvedValueOnce([]),D(n=>{o(`Should not emit any value, but emitted ${JSON.stringify(n)}`)},n=>{try{expect(n).toBeInstanceOf(A),e()}catch(c){o(c)}})})),it("should emit the same discoveredDevice object if its discovered twice in a row",async()=>{s.mockResolvedValue([a]),d.mockResolvedValue([a]);const e=await new Promise((n,c)=>{D(()=>n(),r=>c(r))}),o=await new Promise((n,c)=>{D(()=>n(),r=>c(r))});expect(o).toBe(e)})}),describe("destroy",()=>{it("should stop monitoring connections if the discovery process is halted",()=>{const t=vi.spyOn(AbortController.prototype,"abort");i.destroy(),expect(t).toHaveBeenCalled()})}),describe("connect",()=>{it("should throw UnknownDeviceError if no internal device",async()=>{const t={deviceId:"fake",onDisconnect:vi.fn()},e=await i.connect(t);expect(e).toStrictEqual(B(new P("Unknown device fake")))}),it("should throw OpeningConnectionError if the device cannot be opened",async()=>{const t="cannot be opened";M.setupConnection.mockRejectedValue(new O(t)),s.mockResolvedValueOnce([a]),d.mockResolvedValue([a]);const e=await b(i.startDiscovering()),o=await i.connect({deviceId:e.id,onDisconnect:vi.fn()});expect(o).toStrictEqual(B(new O(t)))}),it("should return a device if available",async()=>{s.mockResolvedValueOnce([a]),d.mockResolvedValue([a]);const t=await b(i.startDiscovering()),e=await i.connect({deviceId:t.id,onDisconnect:vi.fn()});expect(e.isRight()).toStrictEqual(!0),expect(e.extract()).toEqual(expect.objectContaining({id:t.id}))}),it("should return an existing connected device",async()=>{s.mockResolvedValueOnce([a]),d.mockResolvedValue([a]);const t=await b(i.startDiscovering());await i.connect({deviceId:t.id,onDisconnect:vi.fn()});const e=await i.connect({deviceId:t.id,onDisconnect:vi.fn()});expect(e.isRight()).toStrictEqual(!0),expect(e.extract()).toEqual(expect.objectContaining({id:t.id}))})}),describe("disconnect",()=>{it("should throw an error if the device is not connected",async()=>{const t=L(),e=await i.disconnect({connectedDevice:t});expect(e).toStrictEqual(B(new P(`Unknown device ${t.id}`)))}),it("should disconnect if the device is connected",async()=>{s.mockResolvedValueOnce([a]),d.mockResolvedValue([a]);const t=await b(i.startDiscovering()),e=await i.connect({deviceId:t.id,onDisconnect:vi.fn()});expect(e.isRight()).toStrictEqual(!0);const o=await i.disconnect({connectedDevice:e.unsafeCoerce()});expect(o).toStrictEqual(V(void 0))}),it("should call disconnect handler if a connected device is unplugged",async()=>{let t=vi.fn();h.mockImplementationOnce(g=>(t=g.onTerminated,{...w,getDeviceId:vi.fn().mockReturnValue(g.deviceId)}));const e=v(),o=v();s.mockResolvedValueOnce([e,o]),d.mockResolvedValue([e,o]);const n=await b(i.startDiscovering().pipe(j()));expect(n.length).toStrictEqual(2);const c=vi.fn(),r=await i.connect({deviceId:n[0].id,onDisconnect:c}),l=vi.fn(),u=await i.connect({deviceId:n[1].id,onDisconnect:l});expect(r.isRight()).toStrictEqual(!0),expect(u.isRight()).toStrictEqual(!0),t(),expect(c).toHaveBeenCalled(),expect(l).not.toHaveBeenCalled()}),it("should call disconnect handler if a connected device is unplugged while reconnecting",async()=>{let t=vi.fn(),e=vi.fn();h.mockImplementationOnce(H=>(t=H.onTerminated,e=H.tryToReconnect,{...w,getDeviceId:vi.fn().mockReturnValue(H.deviceId)}));const o=v(),n=v();s.mockResolvedValueOnce([o,n]),d.mockResolvedValue([o,n]);const c=await b(i.startDiscovering().pipe(j()));expect(c.length).toStrictEqual(2);const r=vi.fn(),l=await i.connect({deviceId:c[0].id,onDisconnect:r}),u=vi.fn(),g=await i.connect({deviceId:c[1].id,onDisconnect:u});expect(l.isRight()).toStrictEqual(!0),expect(g.isRight()).toStrictEqual(!0),e(),t(),expect(r).toHaveBeenCalled(),expect(u).not.toHaveBeenCalled()})}),describe("reconnect",()=>{it("should stop disconnection if reconnection happen",()=>new Promise((t,e)=>{const o=vi.fn();let n=vi.fn();const c=v(),r=v();s.mockResolvedValueOnce([c]),d.mockResolvedValue([c,r]),h.mockImplementationOnce(l=>(n=l.tryToReconnect,{...w,getDeviceId:vi.fn().mockReturnValue(l.deviceId),getDependencies:l.deviceApduSender.getDependencies,setDependencies:l.deviceApduSender.setDependencies})),D(async l=>{try{await i.connect({deviceId:l.id,onDisconnect:o}),I(c),expect(c.close).toHaveBeenCalled(),await Promise.resolve(),expect(y).toHaveBeenCalled(),n(),vi.advanceTimersByTime(x/3),C(r),await Promise.resolve(),expect(k).toHaveBeenCalled(),vi.advanceTimersByTime(x),expect(o).not.toHaveBeenCalled(),t()}catch(u){e(u)}})})),it("should be able to reconnect twice in a row if the device is unplugged and replugged twice",()=>new Promise((t,e)=>{const o=vi.fn();let n=vi.fn();const c=v(),r=v(),l=v();s.mockResolvedValueOnce([c]),d.mockResolvedValue([c,r,l]),h.mockImplementationOnce(u=>(n=u.tryToReconnect,{...w,getDeviceId:vi.fn().mockReturnValue(u.deviceId),getDependencies:u.deviceApduSender.getDependencies,setDependencies:u.deviceApduSender.setDependencies})),D(async u=>{await i.connect({deviceId:u.id,onDisconnect:o});try{I(c),expect(c.close).toHaveBeenCalled(),await Promise.resolve(),expect(y).toHaveBeenCalled(),n(),vi.advanceTimersByTime(x/3),C(r),await Promise.resolve(),expect(k).toHaveBeenCalled(),vi.advanceTimersByTime(x),expect(o).not.toHaveBeenCalled(),I(r),expect(r.close).toHaveBeenCalled(),await Promise.resolve(),expect(y).toHaveBeenCalled(),n(),vi.advanceTimersByTime(x/3),C(l),await Promise.resolve(),expect(k).toHaveBeenCalled(),vi.advanceTimersByTime(x),expect(o).not.toHaveBeenCalled(),t()}catch(g){e(g)}})}))}),describe("Connection event typeguard",()=>{it("should validate type of an HIDConnectionEvent",()=>{const t={device:a},e=i.isHIDConnectionEvent(t);expect(e).toBe(!0)}),it("should not validate type of another event",()=>{const t=new Event("disconnect",{}),e=i.isHIDConnectionEvent(t);expect(e).toBe(!1)})}),describe("listenToAvailableDevices",()=>{it("should emit the devices already connected before listening",async()=>{const t=v();d.mockResolvedValue([t]);const e=vi.fn(),o=vi.fn();let n=[];i.listenToAvailableDevices().subscribe({next:c=>{n=c},complete:e,error:o}),await m(),expect(n).toEqual([expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_X})})]),expect(e).not.toHaveBeenCalled(),expect(o).not.toHaveBeenCalled()}),it("should emit the new list of devices after connection and disconnection events",async()=>{T();const t=v({productId:R.getDeviceModel({id:p.NANO_X}).usbProductId<<8}),e=v({productId:R.getDeviceModel({id:p.STAX}).usbProductId<<8});d.mockResolvedValue([t]);const o=vi.fn(),n=vi.fn();let c=[];i.listenToAvailableDevices().subscribe({next:r=>{c=r},complete:o,error:n}),await m(),expect(c).toEqual([expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_X})})]),d.mockResolvedValue([t,e]),C(e),await m(),expect(c).toEqual([expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_X})}),expect.objectContaining({deviceModel:expect.objectContaining({id:p.STAX})})]),d.mockResolvedValue([e]),I(t),await m(),expect(c).toEqual([expect.objectContaining({deviceModel:expect.objectContaining({id:p.STAX})})]),expect(o).not.toHaveBeenCalled(),expect(n).not.toHaveBeenCalled()}),it("should preserve DeviceId in case the device has been disconnected and reconnected before the timeout",async()=>{const t=v();d.mockResolvedValue([t]);const e=vi.fn(),o=vi.fn();let n=[];i.listenToAvailableDevices().subscribe({next:r=>{n=r},complete:e,error:o}),await m();const c=n[0]?.id;expect(c).toBeTruthy(),expect(n[0]?.deviceModel?.id).toBe(p.NANO_X),await i.connect({deviceId:n[0].id,onDisconnect:vi.fn()}),await m(),d.mockResolvedValue([]),I(t),await m(),expect(n).toEqual([]),d.mockResolvedValue([t]),C(t),await m(),expect(n).toEqual([expect.objectContaining({deviceModel:expect.objectContaining({id:p.NANO_X})})]),expect(n[0]?.id).toBeTruthy(),expect(n[0]?.id).toBe(c)})})})});
//# sourceMappingURL=WebHidTransport.test.js.map
